    ColumnFamilyStore(String table, String columnFamilyName, boolean isSuper, int indexValue) throws IOException
    {
        table_ = table;
        columnFamily_ = columnFamilyName;
        isSuper_ = isSuper;
        fileIndexGenerator_.set(indexValue);
        memtable_ = new Memtable(table_, columnFamily_);
        binaryMemtable_ = new AtomicReference<BinaryMemtable>(new BinaryMemtable(this));

        if (logger_.isDebugEnabled())
            logger_.debug("Starting CFS " + columnFamily_);
        // scan for data files corresponding to this CF
        List<File> sstableFiles = new ArrayList<File>();
        Pattern auxFilePattern = Pattern.compile("(.*)(-Filter\\.db$|-Index\\.db$)");
        for (File file : files())
        {
            String filename = file.getName();

            /* look for and remove orphans. An orphan is a -Filter.db or -Index.db with no corresponding -Data.db. */
            Matcher matcher = auxFilePattern.matcher(file.getAbsolutePath());
            if (matcher.matches())
            {
                String basePath = matcher.group(1);
                if (!new File(basePath + "-Data.db").exists())
                {
                    logger_.info(String.format("Removing orphan %s", file.getAbsolutePath()));
                    FileUtils.deleteWithConfirm(file);
                    continue;
                }
            }

            if (((file.length() == 0 && !filename.endsWith("-Compacted")) || (filename.contains("-" + SSTable.TEMPFILE_MARKER))))
            {
                FileUtils.deleteWithConfirm(file);
                continue;
            }

            if (filename.contains("-Data.db"))
            {
                sstableFiles.add(file.getAbsoluteFile());
            }
        }
        Collections.sort(sstableFiles, new FileUtils.FileComparator());

        /* Load the index files and the Bloom Filters associated with them. */
        List<SSTableReader> sstables = new ArrayList<SSTableReader>();
        for (File file : sstableFiles)
        {
            String filename = file.getAbsolutePath();
            if (SSTable.deleteIfCompacted(filename))
                continue;

            SSTableReader sstable;
            try
            {
                sstable = SSTableReader.open(filename);
            }
            catch (IOException ex)
            {
                logger_.error("Corrupt file " + filename + "; skipped", ex);
                continue;
            }
            sstables.add(sstable);
        }
        ssTables_ = new SSTableTracker();
        ssTables_.add(sstables);

        double v = DatabaseDescriptor.getRowsCachedFraction(table, columnFamilyName);
        int cacheSize;
        if (0 < v && v < 1)
            cacheSize = Math.max(1, (int)(v * ssTables_.estimatedKeys()));
        else
            cacheSize = (int)v;
        if (logger_.isDebugEnabled())
            logger_.debug("row cache capacity for " + columnFamilyName + " is " + cacheSize);
        rowCache = new JMXInstrumentedCache<String, ColumnFamily>(table, columnFamilyName + "RowCache", cacheSize);

        // we don't need to keep a reference to the key cache aggregator, just create it so it registers itself w/ JMX
        new JMXAggregatingCache(new Iterable<IAggregatableCacheProvider>()
        {
            public Iterator<IAggregatableCacheProvider> iterator()
            {
                final Iterator<SSTableReader> iter = ssTables_.iterator();
                return new AbstractIterator<IAggregatableCacheProvider>()
                {
                    @Override
                    protected IAggregatableCacheProvider computeNext()
                    {
                        if (!iter.hasNext())
                            return endOfData();

                        return new IAggregatableCacheProvider()
                        {
                            SSTableReader sstable = iter.next();

                            public InstrumentedCache getCache()
                            {
                                return sstable.getKeyCache();
                            }

                            public long getObjectCount()
                            {
                                return sstable.getIndexPositions().size() * SSTableReader.indexInterval();
                            }
                        };
                    }
                };
            }
        }, table, columnFamilyName + "KeyCache");
    }

