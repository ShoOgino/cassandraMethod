    /**
     * Run final process of repair.
     * This removes all resources held by parent repair session, after performing anti compaction if necessary.
     *
     * @param parentSession Parent session ID
     * @param neighbors Repair participants (not including self)
     * @throws InterruptedException
     * @throws ExecutionException
     */
    public synchronized ListenableFuture<?> finishParentSession(UUID parentSession, Set<InetAddress> neighbors, boolean doAntiCompaction) throws InterruptedException, ExecutionException
    {
        // We want to remove parent repair session whether we succeeded or not, so send AnticompactionRequest anyway.
        // Each replica node determines if anticompaction is needed.
        List<ListenableFuture<?>> tasks = new ArrayList<>(neighbors.size() + 1);
        for (InetAddress neighbor : neighbors)
        {
            AnticompactionTask task = new AnticompactionTask(parentSession, neighbor, doAntiCompaction);
            tasks.add(task);
            task.run(); // 'run' is just sending message
        }
        if (doAntiCompaction)
        {
            tasks.add(doAntiCompaction(parentSession));
        }
        else
        {
            removeParentRepairSession(parentSession);
        }
        return Futures.successfulAsList(tasks);
    }

