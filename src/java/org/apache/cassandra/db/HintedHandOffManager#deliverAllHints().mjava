    /** hintStore must be the hints columnfamily from the system table */
    private static void deliverAllHints() throws DigestMismatchException, IOException, InvalidRequestException, TimeoutException
    {
        if (logger_.isDebugEnabled())
          logger_.debug("Started deliverAllHints");

        // 1. Scan through all the keys that we need to handoff
        // 2. For each key read the list of recipients and send
        // 3. Delete that recipient from the key if write was successful
        // 4. If all writes were success for a given key we can even delete the key .
        // 5. Now force a flush
        // 6. Do major compaction to clean up all deletes etc.
        // 7. I guess we are done
        ColumnFamilyStore hintStore = Table.open(Table.SYSTEM_TABLE).getColumnFamilyStore(HINTS_CF);
        for (String tableName : DatabaseDescriptor.getTables())
        {
            byte[] startColumn = ArrayUtils.EMPTY_BYTE_ARRAY;
            while (true)
            {
                QueryFilter filter = new SliceQueryFilter(tableName, new QueryPath(HINTS_CF), startColumn, ArrayUtils.EMPTY_BYTE_ARRAY, false, PAGE_SIZE);
                ColumnFamily hintColumnFamily = ColumnFamilyStore.removeDeleted(hintStore.getColumnFamily(filter), Integer.MAX_VALUE);
                if (hintColumnFamily == null)
                    break;
                Collection<IColumn> keys = hintColumnFamily.getSortedColumns();

                for (IColumn keyColumn : keys)
                {
                    Collection<IColumn> endpoints = keyColumn.getSubColumns();
                    String keyStr = new String(keyColumn.name(), "UTF-8");
                    int deleted = 0;
                    for (IColumn endpoint : endpoints)
                    {
                        if (sendMessage(InetAddress.getByAddress(endpoint.name()), tableName, keyStr))
                        {
                            deleteEndPoint(endpoint.name(), tableName, keyColumn.name(), System.currentTimeMillis());
                            deleted++;
                        }
                    }
                    if (deleted == endpoints.size())
                    {
                        deleteHintKey(tableName, keyColumn.name());
                    }

                    startColumn = keyColumn.name(); // repeating the last as the first is fine since we just deleted it
                }
            }
        }
        hintStore.forceFlush();
        try
        {
            CompactionManager.instance.submitMajor(hintStore).get();
        }
        catch (Exception e)
        {
            throw new RuntimeException(e);
        }

        if (logger_.isDebugEnabled())
          logger_.debug("Finished deliverAllHints");
    }

