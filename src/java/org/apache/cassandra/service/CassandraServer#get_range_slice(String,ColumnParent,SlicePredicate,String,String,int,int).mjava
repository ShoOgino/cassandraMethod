    public List<KeySlice> get_range_slice(String keyspace, ColumnParent column_parent, SlicePredicate predicate, String start_key, String finish_key, int maxRows, int consistency_level)
            throws InvalidRequestException, UnavailableException, TException, TimedOutException
    {
        if (logger.isDebugEnabled())
            logger.debug("range_slice");

        ThriftValidation.validatePredicate(keyspace, column_parent, predicate);
        if (!StorageService.getPartitioner().preservesOrder())
        {
            throw new InvalidRequestException("range queries may only be performed against an order-preserving partitioner");
        }
        if (maxRows <= 0)
        {
            throw new InvalidRequestException("maxRows must be positive");
        }

        List<Pair<String, ColumnFamily>> rows;
        try
        {
            DecoratedKey startKey = StorageService.getPartitioner().decorateKey(start_key);
            DecoratedKey finishKey = StorageService.getPartitioner().decorateKey(finish_key);
            rows = StorageProxy.getRangeSlice(new RangeSliceCommand(keyspace, column_parent, predicate, startKey, finishKey, maxRows), consistency_level);
            assert rows != null;
        }
        catch (TimeoutException e)
        {
        	throw new TimedOutException();
        }
        catch (IOException e)
        {
            throw new RuntimeException(e);
        }

        List<KeySlice> keySlices = new ArrayList<KeySlice>(rows.size());
        boolean reversed = predicate.slice_range != null && predicate.slice_range.reversed;
        for (Pair<String, ColumnFamily> row : rows)
        {
            List<ColumnOrSuperColumn> thriftifiedColumns = thriftifyColumnFamily(row.right, column_parent.super_column != null, reversed);
            keySlices.add(new KeySlice(row.left, thriftifiedColumns));
        }

        return keySlices;
    }

