        public Iterable<Row> next()
        {
            final int[] limit = position.clone();
            int remainingSize = batchSize;
            for (int i = 0 ; i < limit.length && remainingSize > 0 ; i++)
            {
                limit[i] += remainingSize / generator.clusteringChildAverages[i];
                remainingSize %= generator.clusteringChildAverages[i];
            }
            assert remainingSize == 0;
            for (int i = limit.length - 1 ; i > 0 ; i--)
            {
                if (limit[i] > generator.clusteringChildAverages[i])
                {
                    limit[i - 1] += limit[i] / generator.clusteringChildAverages[i];
                    limit[i] %= generator.clusteringChildAverages[i];
                }
            }
            for (int i = 0 ; i < limit.length ; i++)
            {
                if (limit[i] < this.limit[i])
                    break;
                limit[i] = Math.min(limit[i], this.limit[i]);
            }
            return new Iterable<Row>()
            {
                public Iterator<Row> iterator()
                {
                    return new Iterator<Row>()
                    {

                        public boolean hasNext()
                        {
                            if (done())
                                return false;
                            for (int i = 0 ; i < position.length ; i++)
                                if (position[i] < limit[i])
                                    return true;
                            return false;
                        }

                        public Row next()
                        {
                            advance();
                            return row;
                        }

                        public void remove()
                        {
                            throw new UnsupportedOperationException();
                        }
                    };
                }
            };
        }

