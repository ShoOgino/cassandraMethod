    @Test
    public void testCounterTable() throws Throwable
    {
        /*
         * We can't use CQL to insert counters as both the timestamp and counter ID are automatically assigned and unpredictable.
         * So we need to built it ourselves in a way that is totally equivalent between 2.2 and 3.0 which makes the test a little
         * bit less readable. In any case, the code to generate the equivalent mutation on 2.2 is:
         * ColumnFamily cf = ArrayBackedSortedColumns.factory.create(getCurrentColumnFamilyStore().metadata);
         * ByteBuffer value = CounterContext.instance().createGlobal(CounterId.fromInt(1), 1L, 42L);
         * cf.addColumn(new BufferCounterCell(CellNames.simpleSparse(new ColumnIdentifier("c", true)) , value, 0L, Long.MIN_VALUE));
         * new Mutation(KEYSPACE, ByteBufferUtil.bytes(key), cf).applyUnsafe();
         *
         * Also note that we use COMPACT STORAGE only because it has no bearing on the test and was slightly easier in 2.2 to create
         * the mutation.
         */

        createTable("CREATE TABLE %s (k text PRIMARY KEY, c counter) WITH COMPACT STORAGE");

        String key = "someKey";

        CFMetaData metadata = getCurrentColumnFamilyStore().metadata;
        ColumnDefinition column = metadata.getColumnDefinition(ByteBufferUtil.bytes("c"));
        ByteBuffer value = CounterContext.instance().createGlobal(CounterId.fromInt(1), 1L, 42L);
        Row row = BTreeRow.singleCellRow(Clustering.STATIC_CLUSTERING, BufferCell.live(column, 0L, value));

        new Mutation(PartitionUpdate.singleRowUpdate(metadata, Util.dk(key), row)).applyUnsafe();

        assertDigest("3a5f7b48c320538b4cd2f829e05c6db3", readAndDigest(key));
    }

