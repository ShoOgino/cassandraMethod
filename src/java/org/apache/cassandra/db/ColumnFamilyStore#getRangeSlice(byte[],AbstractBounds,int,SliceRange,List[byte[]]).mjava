    /**
     *
     * @param super_column
     * @param range: either a Bounds, which includes start key, or a Range, which does not.
     * @param keyMax maximum number of keys to process, regardless of startKey/finishKey
     * @param sliceRange may be null if columnNames is specified. specifies contiguous columns to return in what order.
     * @param columnNames may be null if sliceRange is specified. specifies which columns to return in what order.      @return list of key->list<column> tuples.
     * @throws IOException
     * @throws ExecutionException
     * @throws InterruptedException
     */
    public RangeSliceReply getRangeSlice(byte[] super_column, final AbstractBounds range, int keyMax, SliceRange sliceRange, List<byte[]> columnNames)
    throws IOException, ExecutionException, InterruptedException
    {
        List<String> keys = new ArrayList<String>();
        boolean completed;
        if ((range instanceof Bounds || !((Range)range).isWrapAround()))
        {
            completed = getKeyRange(keys, range, keyMax);
        }
        else
        {
            // wrapped range
            Token min = StorageService.getPartitioner().getMinimumToken();
            Range first = new Range(range.left, min);
            completed = getKeyRange(keys, first, keyMax);
            if (!completed && min.compareTo(range.right) < 0)
            {
                Range second = new Range(min, range.right);
                getKeyRange(keys, second, keyMax);
            }
        }
        List<Row> rows = new ArrayList<Row>(keys.size());
        final QueryPath queryPath =  new QueryPath(columnFamily_, super_column, null);
        final SortedSet<byte[]> columnNameSet = new TreeSet<byte[]>(getComparator());
        if (columnNames != null)
            columnNameSet.addAll(columnNames);
        for (String key : keys)
        {
            QueryFilter filter = sliceRange == null ? new NamesQueryFilter(key, queryPath, columnNameSet) : new SliceQueryFilter(key, queryPath, sliceRange.start, sliceRange.finish, sliceRange.bitmasks, sliceRange.reversed, sliceRange.count);
            rows.add(new Row(key, getColumnFamily(filter)));
        }

        return new RangeSliceReply(rows);
    }

