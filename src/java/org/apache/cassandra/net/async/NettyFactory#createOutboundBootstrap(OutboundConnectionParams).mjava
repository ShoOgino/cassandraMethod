    /**
     * Create the {@link Bootstrap} for connecting to a remote peer. This method does <b>not</b> attempt to connect to the peer,
     * and thus does not block.
     */
    @VisibleForTesting
    public Bootstrap createOutboundBootstrap(OutboundConnectionParams params)
    {
        logger.debug("creating outbound bootstrap to peer {}, compression: {}, encryption: {}, coalesce: {}, protocolVersion: {}",
                     params.connectionId.connectionAddress(),
                     params.compress, encryptionLogStatement(params.encryptionOptions),
                     params.coalescingStrategy.isPresent() ? params.coalescingStrategy.get() : CoalescingStrategies.Strategy.DISABLED,
                     params.protocolVersion);
        Class<? extends Channel> transport = useEpoll ? EpollSocketChannel.class : NioSocketChannel.class;
        Bootstrap bootstrap = new Bootstrap().group(params.mode == Mode.MESSAGING ? outboundGroup : streamingGroup)
                              .channel(transport)
                              .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, params.tcpConnectTimeoutInMS)
                              .option(ChannelOption.SO_KEEPALIVE, true)
                              .option(ChannelOption.SO_REUSEADDR, true)
                              .option(ChannelOption.SO_SNDBUF, params.sendBufferSize)
                              .option(ChannelOption.SO_RCVBUF, OUTBOUND_CHANNEL_RECEIVE_BUFFER_SIZE)
                              .option(ChannelOption.TCP_NODELAY, params.tcpNoDelay)
                              .option(ChannelOption.WRITE_BUFFER_WATER_MARK, params.waterMark)
                              .handler(new OutboundInitializer(params));
        if (useEpoll)
            bootstrap.option(EpollChannelOption.TCP_USER_TIMEOUT, params.tcpUserTimeoutInMS);

        InetAddressAndPort remoteAddress = params.connectionId.connectionAddress();
        bootstrap.remoteAddress(new InetSocketAddress(remoteAddress.address, remoteAddress.port));
        return bootstrap;
    }

