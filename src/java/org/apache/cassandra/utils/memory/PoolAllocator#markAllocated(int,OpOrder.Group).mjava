    // mark ourselves as owning memory from the tracker.  meant to be called by subclass
    // allocate method that actually allocates and returns a ByteBuffer
    protected void markAllocated(int size, OpOrder.Group opGroup)
    {
        while (true)
        {
            if (pool.tryAllocate(size))
            {
                acquired(size);
                return;
            }
            WaitQueue.Signal signal = opGroup.isBlockingSignal(pool.hasRoom.register());
            boolean allocated = pool.tryAllocate(size);
            if (allocated || opGroup.isBlocking())
            {
                signal.cancel();
                if (allocated) // if we allocated, take ownership
                    acquired(size);
                else // otherwise we're blocking so we're permitted to overshoot our constraints, to just allocate without blocking
                    allocated(size);
                return;
            }
            else
                signal.awaitUninterruptibly();
        }
    }

