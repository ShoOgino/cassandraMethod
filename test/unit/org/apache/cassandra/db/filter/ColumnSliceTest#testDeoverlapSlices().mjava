    @Test
    public void testDeoverlapSlices()
    {
        ColumnSlice[] slices;
        ColumnSlice[] deoverlapped;

        // Preserve correct slices
        slices = slices(s(0, 3), s(4, 5), s(6, 9));
        assertSlicesValid(slices);
        assertSlicesEquals(slices, deoverlapSlices(slices));

        // Simple overlap
        slices = slices(s(0, 3), s(2, 5), s(8, 9));
        assertSlicesInvalid(slices);
        assertSlicesEquals(slices(s(0, 5), s(8, 9)), deoverlapSlices(slices));

        // Slice overlaps others fully
        slices = slices(s(0, 10), s(2, 5), s(8, 9));
        assertSlicesInvalid(slices);
        assertSlicesEquals(slices(s(0, 10)), deoverlapSlices(slices));

        // Slice with empty end overlaps others fully
        slices = slices(s(0, -1), s(2, 5), s(8, 9));
        assertSlicesInvalid(slices);
        assertSlicesEquals(slices(s(0, -1)), deoverlapSlices(slices));

        // Overlap with slices selecting only one element
        slices = slices(s(0, 4), s(4, 4), s(4, 8));
        assertSlicesInvalid(slices);
        assertSlicesEquals(slices(s(0, 8)), deoverlapSlices(slices));

        // Unordered slices (without overlap)
        slices = slices(s(4, 8), s(0, 3), s(9, 9));
        assertSlicesInvalid(slices);
        assertSlicesEquals(slices(s(0, 3), s(4, 8), s(9, 9)), deoverlapSlices(slices));

        // All range select but not by a single slice
        slices = slices(s(5, -1), s(2, 5), s(-1, 2));
        assertSlicesInvalid(slices);
        assertSlicesEquals(slices(s(-1, -1)), deoverlapSlices(slices));
    }

