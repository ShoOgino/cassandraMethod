    public void closeIfFinished() throws IOException
    {
        if (files.isEmpty())
        {
            // wait for bloom filters and row indexes to finish building
            HashMap <ColumnFamilyStore, List<SSTableReader>> cfstores = new HashMap<ColumnFamilyStore, List<SSTableReader>>();
            for (Future<SSTableReader> future : buildFutures)
            {
                try
                {
                    SSTableReader sstable = future.get();
                    assert sstable.getTableName().equals(table);
                    ColumnFamilyStore cfs = Table.open(sstable.getTableName()).getColumnFamilyStore(sstable.getColumnFamilyName());
                    cfs.addSSTable(sstable);
                    if (!cfstores.containsKey(cfs))
                        cfstores.put(cfs, new ArrayList<SSTableReader>());
                    cfstores.get(cfs).add(sstable);
                }
                catch (InterruptedException e)
                {
                    throw new AssertionError(e);
                }
                catch (ExecutionException e)
                {
                    throw new RuntimeException(e);
                }
            }
            
            for (SSTableReader sstable : readers)
            {
                assert sstable.getTableName().equals(table);
                ColumnFamilyStore cfs = Table.open(sstable.getTableName()).getColumnFamilyStore(sstable.getColumnFamilyName());
                cfs.addSSTable(sstable);
                if (!cfstores.containsKey(cfs))
                    cfstores.put(cfs, new ArrayList<SSTableReader>());
                cfstores.get(cfs).add(sstable);
            }

            // build secondary indexes
            for (Map.Entry<ColumnFamilyStore, List<SSTableReader>> entry : cfstores.entrySet())
            {
                if (entry.getKey() != null && !entry.getKey().getIndexedColumns().isEmpty())
                    entry.getKey().buildSecondaryIndexes(entry.getValue(), entry.getKey().getIndexedColumns());
            }

            // send reply to source that we're done
            StreamReply reply = new StreamReply("", getSessionId(), StreamReply.Status.SESSION_FINISHED);
            logger.info("Finished streaming session {} from {}", getSessionId(), getHost());
            MessagingService.instance().sendOneWay(reply.getMessage(Gossiper.instance.getVersion(getHost())), getHost());

            if (callback != null)
                callback.run();
            sessions.remove(context);
        }
    }

