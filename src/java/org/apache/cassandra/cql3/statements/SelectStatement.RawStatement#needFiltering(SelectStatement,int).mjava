        /**
         * Checks if the specified statement will need to filter the data.
         *
         * @param stmt the statement to test.
         * @param numberOfRestrictionsEvaluatedWithSlices the number of restrictions that can be evaluated with slices
         * @return <code>true</code> if the specified statement will need to filter the data, <code>false</code>
         * otherwise.
         */
        private static boolean needFiltering(SelectStatement stmt, int numberOfRestrictionsEvaluatedWithSlices)
        {
            boolean needFiltering = stmt.restrictedColumns.size() > 1
                    || (stmt.restrictedColumns.isEmpty() && !stmt.columnFilterIsIdentity())
                    || (!stmt.restrictedColumns.isEmpty()
                            && stmt.isRestrictedByMultipleContains(Iterables.getOnlyElement(stmt.restrictedColumns.keySet())));

            // For some secondary index queries, that were having some restrictions on non-indexed clustering columns,
            // were not requiring ALLOW FILTERING as we should. The first time such a query is executed we will log a
            // warning to notify the user (CASSANDRA-8418)
            if (!needFiltering
                    && !hasLoggedMissingAllowFilteringWarning
                    && (stmt.restrictedColumns.size() + numberOfRestrictionsEvaluatedWithSlices) > 1)
            {
                hasLoggedMissingAllowFilteringWarning = true;

                String msg = "Some secondary index queries with restrictions on non-indexed clustering columns "
                           + "were executed without ALLOW FILTERING. In Cassandra 3.0, these queries will require "
                           + "ALLOW FILTERING (see CASSANDRA-8418 for details).";

                logger.warn(msg);
            }

            return needFiltering;
        }

