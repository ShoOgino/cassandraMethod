    /**
     * Call this whenever a compaction might be needed on the given columnfamily.
     * It's okay to over-call (within reason) since the compactions are single-threaded,
     * and if a call is unnecessary, it will just be no-oped in the bucketing phase.
     */
    public Future<Integer> submitBackground(final ColumnFamilyStore cfs)
    {
        logger.debug("Scheduling a background task check for {}.{} with {}",
                     new Object[] {cfs.table.name,
                                   cfs.columnFamily,
                                   cfs.getCompactionStrategy().getClass().getSimpleName()});
        Callable<Integer> callable = new Callable<Integer>()
        {
            public Integer call() throws IOException
            {
                compactionLock.readLock().lock();
                try
                {
                    logger.debug("Checking {}.{}", cfs.table.name, cfs.columnFamily); // log after we get the lock so we can see delays from that if any
                    if (!cfs.isValid())
                    {
                        logger.debug("Aborting compaction for dropped CF");
                        return 0;
                    }

                    boolean taskExecuted = false;
                    AbstractCompactionStrategy strategy = cfs.getCompactionStrategy();
                    List<AbstractCompactionTask> tasks = strategy.getBackgroundTasks(getDefaultGcBefore(cfs));
                    logger.debug("{} minor compaction tasks available", tasks.size());
                    for (AbstractCompactionTask task : tasks)
                    {
                        if (!task.markSSTablesForCompaction())
                        {
                            logger.debug("Skipping {}; sstables are busy", task);
                            continue;
                        }

                        taskExecuted = true;
                        try
                        {
                            task.execute(executor);
                        }
                        finally
                        {
                            task.unmarkSSTables();
                        }
                    }

                    // newly created sstables might have made other compactions eligible
                    if (taskExecuted)
                        submitBackground(cfs);
                }
                finally 
                {
                    compactionLock.readLock().unlock();
                }
                return 0;
            }
        };
        return executor.submit(callable);
    }

