    /*
     * Inserts a new element starting at index i. This method assumes that:
     *    ends[i-1] <= start <= ends[i]
     *
     * A RangeTombstoneList is a list of range [s_0, e_0]...[s_n, e_n] such that:
     *   - s_i <= e_i
     *   - e_i <= s_i+1
     *   - if s_i == e_i and e_i == s_i+1 then s_i+1 < e_i+1
     * Basically, range are non overlapping except for their bound and in order. And while
     * we allow ranges with the same value for the start and end, we don't allow repeating
     * such range (so we can't have [0, 0][0, 0] even though it would respect the first 2
     * conditions).
     *
     */
    private void insertFrom(int i, ByteBuffer start, ByteBuffer end, long markedAt, int delTime)
    {
        while (i < size)
        {
            assert i == 0 || comparator.compare(ends[i-1], start) <= 0;

            int c = comparator.compare(start, ends[i]);
            assert c <= 0;
            if (c == 0)
            {
                // If start == ends[i], then we can insert from the next one (basically the new element
                // really start at the next element), except for the case where starts[i] == ends[i].
                // In this latter case, if we were to move to next element, we could end up with ...[x, x][x, x]...
                if (comparator.compare(starts[i], ends[i]) == 0)
                {
                    // The current element cover a single value which is equal to the start of the inserted
                    // element. If the inserted element overwrites the current one, just remove the current
                    // (it's included in what we insert) and proceed with the insert.
                    if (markedAt > markedAts[i])
                    {
                        removeInternal(i);
                        continue;
                    }

                    // Otherwise (the current singleton interval override the new one), we want to leave the
                    // current element and move to the next, unless start == end since that means the new element
                    // is in fact fully covered by the current one (so we're done)
                    if (comparator.compare(start, end) == 0)
                        return;
                }
                i++;
                continue;
            }

            // Do we overwrite the current element?
            if (markedAt > markedAts[i])
            {
                // We do overwrite.

                // First deal with what might come before the newly added one.
                if (comparator.compare(starts[i], start) < 0)
                {
                    addInternal(i, starts[i], start, markedAts[i], delTimes[i]);
                    i++;
                    // We don't need to do the following line, but in spirit that's what we want to do
                    // setInternal(i, start, ends[i], markedAts, delTime])
                }

                // now, start <= starts[i]

                // Does the new element stops before/at the current one,
                int endCmp = comparator.compare(end, starts[i]);
                if (endCmp <= 0)
                {
                    // Here start <= starts[i] and end <= starts[i]
                    // This means the current element is before the current one. However, one special
                    // case is if end == starts[i] and starts[i] == ends[i]. In that case,
                    // the new element entirely overwrite the current one and we can just overwrite
                    if (endCmp == 0 && comparator.compare(starts[i], ends[i]) == 0)
                        setInternal(i, start, end, markedAt, delTime);
                    else
                        addInternal(i, start, end, markedAt, delTime);
                    return;
                }

                // Do we overwrite the current element fully?
                int cmp = comparator.compare(ends[i], end);
                if (cmp <= 0)
                {
                    // We do overwrite fully:
                    // update the current element until it's end and continue
                    // on with the next element (with the new inserted start == current end).

                    // If we're on the last element, we can optimize
                    if (i == size-1)
                    {
                        setInternal(i, start, end, markedAt, delTime);
                        return;
                    }

                    setInternal(i, start, ends[i], markedAt, delTime);
                    if (cmp == 0)
                        return;

                    start = ends[i];
                    i++;
                }
                else
                {
                    // We don't ovewrite fully. Insert the new interval, and then update the now next
                    // one to reflect the not overwritten parts. We're then done.
                    addInternal(i, start, end, markedAt, delTime);
                    i++;
                    setInternal(i, end, ends[i], markedAts[i], delTimes[i]);
                    return;
                }
            }
            else
            {
                // we don't overwrite the current element

                // If the new interval starts before the current one, insert that new interval
                if (comparator.compare(start, starts[i]) < 0)
                {
                    // If we stop before the start of the current element, just insert the new
                    // interval and we're done; otherwise insert until the beginning of the
                    // current element
                    if (comparator.compare(end, starts[i]) <= 0)
                    {
                        addInternal(i, start, end, markedAt, delTime);
                        return;
                    }
                    addInternal(i, start, starts[i], markedAt, delTime);
                    i++;
                }

                // After that, we're overwritten on the current element but might have
                // some residual parts after ...

                // ... unless we don't extend beyond it.
                if (comparator.compare(end, ends[i]) <= 0)
                    return;

                start = ends[i];
                i++;
            }
        }

        // If we got there, then just insert the remainder at the end
        addInternal(i, start, end, markedAt, delTime);
    }

