    private static void mergeColumnFamilies(Map<DecoratedKey, ColumnFamily> old, Map<DecoratedKey, ColumnFamily> updated)
            throws ConfigurationException, IOException
    {
        // calculate the difference between old and new states (note that entriesOnlyLeft() will be always empty)
        MapDifference<DecoratedKey, ColumnFamily> diff = Maps.difference(old, updated);

        // check if any new Keyspaces with ColumnFamilies were added.
        for (Map.Entry<DecoratedKey, ColumnFamily> entry : diff.entriesOnlyOnRight().entrySet())
        {
            ColumnFamily cfAttrs = entry.getValue();

            if (!cfAttrs.isEmpty())
            {
               Map<String, CfDef> cfDefs = KSMetaData.deserializeColumnFamilies(cfAttrs);

                for (CfDef cfDef : cfDefs.values())
                    MigrationHelper.addColumnFamily(cfDef);
            }
        }

        // deal with modified ColumnFamilies (remember that all of the keyspace nested ColumnFamilies are put to the single row)
        Map<DecoratedKey, MapDifference.ValueDifference<ColumnFamily>> modifiedEntries = diff.entriesDiffering();

        for (DecoratedKey keyspace : modifiedEntries.keySet())
        {
            MapDifference.ValueDifference<ColumnFamily> valueDiff = modifiedEntries.get(keyspace);

            ColumnFamily prevValue = valueDiff.leftValue(); // state before external modification
            ColumnFamily newValue = valueDiff.rightValue(); // updated state

            if (prevValue.isEmpty()) // whole keyspace was deleted and now it's re-created
            {
                for (CfDef cfDef : KSMetaData.deserializeColumnFamilies(newValue).values())
                    MigrationHelper.addColumnFamily(cfDef);
            }
            else if (newValue.isEmpty()) // whole keyspace is deleted
            {
                for (CfDef cfDef : KSMetaData.deserializeColumnFamilies(prevValue).values())
                    MigrationHelper.dropColumnFamily(cfDef.keyspace, cfDef.name);
            }
            else // has modifications in the nested ColumnFamilies, need to perform nested diff to determine what was really changed
            {
                String ksName = AsciiType.instance.getString(keyspace.key);

                Map<String, CfDef> oldCfDefs = new HashMap<String, CfDef>();
                for (CFMetaData cfm : Schema.instance.getKSMetaData(ksName).cfMetaData().values())
                    oldCfDefs.put(cfm.cfName, cfm.toThrift());

                Map<String, CfDef> newCfDefs = KSMetaData.deserializeColumnFamilies(newValue);

                MapDifference<String, CfDef> cfDefDiff = Maps.difference(oldCfDefs, newCfDefs);

                for (CfDef cfDef : cfDefDiff.entriesOnlyOnRight().values())
                    MigrationHelper.addColumnFamily(cfDef);

                for (CfDef cfDef : cfDefDiff.entriesOnlyOnLeft().values())
                    MigrationHelper.dropColumnFamily(cfDef.keyspace, cfDef.name);

                for (MapDifference.ValueDifference<CfDef> cfDef : cfDefDiff.entriesDiffering().values())
                    MigrationHelper.updateColumnFamily(cfDef.rightValue());
            }
        }
    }

