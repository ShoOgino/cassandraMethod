    private static void mergeTypes(List<Row> old, List<Row> updated)
    {
        MapDifference<ByteBuffer, UserType> diff = Maps.difference(UTMetaData.fromSchema(old).getAllTypes(),
                                                                   UTMetaData.fromSchema(updated).getAllTypes());

        // New types
        for (UserType newType : diff.entriesOnlyOnRight().values())
            Schema.instance.loadType(newType);

        // Dropped types
        for (UserType droppedType : diff.entriesOnlyOnLeft().values())
            Schema.instance.dropType(droppedType);

        // Now deal with modified types: if one is 'extended' compared to the other, we always prefer that
        // one. But otherwise (if it's a field rename for instance) we just pick the more recent one
        // (timestamp wise).
        for (MapDifference.ValueDifference<UserType> modified : diff.entriesDiffering().values())
        {
            UserType u1 = modified.leftValue();
            UserType u2 = modified.rightValue();
            // Note that that loadType is a 'load or update'
            if (u1.isCompatibleWith(u2) && !u2.isCompatibleWith(u1))
            {
                Schema.instance.loadType(u1);
            }
            else if (u2.isCompatibleWith(u1) && !u1.isCompatibleWith(u2))
            {
                Schema.instance.loadType(u2);
            }
            else
            {
                long leftTimestamp = firstTimestampOf(u1.name, old);
                long rightTimestamp = firstTimestampOf(u1.name, updated);
                Schema.instance.loadType(leftTimestamp > rightTimestamp ? u1 : u2);
            }
        }
    }

