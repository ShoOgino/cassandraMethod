    /**
     * Checks if a new worker can be added with respect to current pool state
     * and the given bound (either core or maximum). If so, the worker count is
     * adjusted accordingly, and, if possible, a new worker is created and
     * started running firstTask as its first task. This method returns false if
     * the pool is stopped or eligible to shut down. It also returns false if
     * the thread factory fails to create a thread when asked, which requires a
     * backout of workerCount, and a recheck for termination, in case the
     * existence of this worker was holding up termination.
     * 
     * @param firstTask
     *            the task the new thread should run first (or null if none).
     *            Workers are created with an initial first task (in method
     *            execute()) to bypass queuing when there are fewer than
     *            corePoolSize threads (in which case we always start one), or
     *            when the queue is full (in which case we must bypass queue).
     *            Initially idle threads are usually created via
     *            prestartCoreThread or to replace other dying workers.
     * 
     * @param core
     *            if true use corePoolSize as bound, else maximumPoolSize. (A
     *            boolean indicator is used here rather than a value to ensure
     *            reads of fresh values after checking other pool state).
     * @return true if successful
     */
    private boolean addWorker(Runnable firstTask, boolean core)
    {
        retry: for (;;)
        {
            int c = ctl.get();
            int rs = runStateOf(c);

            // Check if queue empty only if necessary.
            if (rs >= SHUTDOWN
                    && !(rs == SHUTDOWN && firstTask == null && !workQueue
                            .isEmpty()))
                return false;

            for (;;)
            {
                int wc = workerCountOf(c);
                if (wc >= CAPACITY
                        || wc >= (core ? corePoolSize : maximumPoolSize))
                    return false;
                if (compareAndIncrementWorkerCount(c))
                    break retry;
                c = ctl.get(); // Re-read ctl
                if (runStateOf(c) != rs)
                    continue retry;
                // else CAS failed due to workerCount change; retry inner loop
            }
        }

        Worker w = new Worker(firstTask);
        Thread t = w.thread;

        final ReentrantLock mainLock = this.mainLock;
        mainLock.lock();
        try
        {
            // Recheck while holding lock.
            // Back out on ThreadFactory failure or if
            // shut down before lock acquired.
            int c = ctl.get();
            int rs = runStateOf(c);

            if (t == null
                    || (rs >= SHUTDOWN && !(rs == SHUTDOWN && firstTask == null)))
            {
                decrementWorkerCount();
                tryTerminate();
                return false;
            }

            workers.add(w);

            int s = workers.size();
            if (s > largestPoolSize)
                largestPoolSize = s;
        }
        finally
        {
            mainLock.unlock();
        }

        t.start();
        // It is possible (but unlikely) for a thread to have been
        // added to workers, but not yet started, during transition to
        // STOP, which could result in a rare missed interrupt,
        // because Thread.interrupt is not guaranteed to have any effect
        // on a non-yet-started Thread (see Thread#interrupt).
        if (runStateOf(ctl.get()) == STOP && !t.isInterrupted())
            t.interrupt();

        return true;
    }

