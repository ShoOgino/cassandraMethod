    /**
     * Call this whenever a compaction might be needed on the given columnfamily.
     * It's okay to over-call (within reason) since the compactions are single-threaded,
     * and if a call is unnecessary, it will just be no-oped in the bucketing phase.
     */
    public Future<Integer> submitMinor(final ColumnFamilyStore cfs)
    {
        Callable<Integer> callable = new Callable<Integer>()
        {
            public Integer call() throws IOException
            {
                int filesCompacted = 0;
                if (minimumCompactionThreshold > 0 && maximumCompactionThreshold > 0)
                {
                    logger.debug("Checking to see if compaction of " + cfs.columnFamily_ + " would be useful");
                    for (List<SSTableReader> sstables : getCompactionBuckets(cfs.getSSTables(), 50L * 1024L * 1024L))
                    {
                        if (sstables.size() < minimumCompactionThreshold)
                        {
                            continue;
                        }
                        // if we have too many to compact all at once, compact older ones first -- this avoids
                        // re-compacting files we just created.
                        Collections.sort(sstables);
                        filesCompacted += doCompaction(cfs, sstables.subList(0, Math.min(sstables.size(), maximumCompactionThreshold)), getDefaultGCBefore());
                    }
                    logger.debug(filesCompacted + " files compacted");
                }
                else
                {
                    logger.debug("Compaction is currently disabled.");
                }
                return filesCompacted;
            }
        };
        return compactor_.submit(callable);
    }

