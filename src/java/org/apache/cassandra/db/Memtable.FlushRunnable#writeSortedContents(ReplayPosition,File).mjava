        private SSTableReader writeSortedContents(ReplayPosition context, File sstableDirectory)
        {
            logger.info("Writing {}", Memtable.this.toString());

            SSTableReader ssTable;
            // errors when creating the writer that may leave empty temp files.
            try (SSTableWriter writer = createFlushWriter(cfs.getTempSSTablePath(sstableDirectory), columnsCollector.get(), statsCollector.get()))
            {
                boolean trackContention = logger.isDebugEnabled();
                int heavilyContendedRowCount = 0;
                // (we can't clear out the map as-we-go to free up memory,
                //  since the memtable is being used for queries in the "pending flush" category)
                for (AtomicBTreePartition partition : partitions.values())
                {
                    // Each batchlog partition is a separate entry in the log. And for an entry, we only do 2
                    // operations: 1) we insert the entry and 2) we delete it. Further, BL data is strictly local,
                    // we don't need to preserve tombstones for repair. So if both operation are in this
                    // memtable (which will almost always be the case if there is no ongoing failure), we can
                    // just skip the entry (CASSANDRA-4667).
                    if (isBatchLogTable && !partition.partitionLevelDeletion().isLive() && partition.hasRows())
                        continue;

                    if (trackContention && partition.usePessimisticLocking())
                        heavilyContendedRowCount++;

                    if (!partition.isEmpty())
                    {
                        try (UnfilteredRowIterator iter = partition.unfilteredIterator())
                        {
                            writer.append(iter);
                        }
                    }
                }

                if (writer.getFilePointer() > 0)
                {
                    logger.info(String.format("Completed flushing %s (%s) for commitlog position %s",
                                              writer.getFilename(),
                                              FBUtilities.prettyPrintMemory(writer.getOnDiskFilePointer()),
                                              context));

                    // temp sstables should contain non-repaired data.
                    ssTable = writer.finish(true);
                }
                else
                {
                    logger.info("Completed flushing {}; nothing needed to be retained.  Commitlog position was {}",
                                writer.getFilename(), context);
                    writer.abort();
                    ssTable = null;
                }

                if (heavilyContendedRowCount > 0)
                    logger.debug(String.format("High update contention in %d/%d partitions of %s ", heavilyContendedRowCount, partitions.size(), Memtable.this.toString()));

                return ssTable;
            }
        }

