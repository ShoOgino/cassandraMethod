    private ColumnFamily getColumnFamily(QueryFilter filter, int gcBefore)
    {
        assert columnFamily_.equals(filter.getColumnFamilyName());

        long start = System.nanoTime();
        try
        {
            if (ssTables_.getRowCache().getCapacity() == 0)
            {
                ColumnFamily cf = getTopLevelColumns(filter, gcBefore);
                // TODO this is necessary because when we collate supercolumns together, we don't check
                // their subcolumns for relevance, so we need to do a second prune post facto here.
                return cf.isSuper() ? removeDeleted(cf, gcBefore) : removeDeletedCF(cf, gcBefore);
            }

            ColumnFamily cached = cacheRow(filter.key);
            if (cached == null)
                return null;
            
            // special case slicing the entire row:
            // we can skip the filter step entirely, and we can help out removeDeleted by re-caching the result
            // if any tombstones have aged out since last time.  (This means that the row cache will treat gcBefore as
            // max(gcBefore, all previous gcBefore), which is fine for correctness.)
            if (filter.filter instanceof SliceQueryFilter)
            {
                SliceQueryFilter sliceFilter = (SliceQueryFilter) filter.filter;
                if (sliceFilter.start.length == 0 && sliceFilter.finish.length == 0 && sliceFilter.count > cached.getColumnCount())
                {
                    removeDeletedColumnsOnly(cached, gcBefore);
                    return removeDeletedCF(cached, gcBefore);
                }
            }
            
            IColumnIterator ci = filter.getMemtableColumnIterator(cached, null, getComparator());
            ColumnFamily cf = ci.getColumnFamily().cloneMeShallow();
            filter.collectCollatedColumns(cf, ci, gcBefore);
            // TODO this is necessary because when we collate supercolumns together, we don't check
            // their subcolumns for relevance, so we need to do a second prune post facto here.
            return cf.isSuper() ? removeDeleted(cf, gcBefore) : removeDeletedCF(cf, gcBefore);
        }
        catch (IOException e)
        {
            throw new IOError(e);
        }
        finally
        {
            readStats_.addNano(System.nanoTime() - start);
        }
    }

