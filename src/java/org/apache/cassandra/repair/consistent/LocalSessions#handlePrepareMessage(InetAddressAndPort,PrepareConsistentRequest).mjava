    /**
     * The PrepareConsistentRequest effectively promotes the parent repair session to a consistent
     * incremental session, and begins the 'pending anti compaction' which moves all sstable data
     * that is to be repaired into it's own silo, preventing it from mixing with other data.
     *
     * No response is sent to the repair coordinator until the pending anti compaction has completed
     * successfully. If the pending anti compaction fails, a failure message is sent to the coordinator,
     * cancelling the session.
     */
    public void handlePrepareMessage(InetAddressAndPort from, PrepareConsistentRequest request)
    {
        logger.trace("received {} from {}", request, from);
        UUID sessionID = request.parentSession;
        InetAddressAndPort coordinator = request.coordinator;
        Set<InetAddressAndPort> peers = request.participants;

        ActiveRepairService.ParentRepairSession parentSession;
        try
        {
            parentSession = getParentRepairSession(sessionID);
        }
        catch (Throwable e)
        {
            logger.trace("Error retrieving ParentRepairSession for session {}, responding with failure", sessionID);
            sendMessage(coordinator, new FailSession(sessionID));
            return;
        }

        LocalSession session = createSessionUnsafe(sessionID, parentSession, peers);
        putSessionUnsafe(session);
        logger.info("Beginning local incremental repair session {}", session);

        ExecutorService executor = Executors.newFixedThreadPool(parentSession.getColumnFamilyStores().size());

        ListenableFuture pendingAntiCompaction = submitPendingAntiCompaction(session, executor);
        Futures.addCallback(pendingAntiCompaction, new FutureCallback()
        {
            public void onSuccess(@Nullable Object result)
            {
                logger.debug("Prepare phase for incremental repair session {} completed", sessionID);
                setStateAndSave(session, PREPARED);
                sendMessage(coordinator, new PrepareConsistentResponse(sessionID, getBroadcastAddressAndPort(), true));
                executor.shutdown();
            }

            public void onFailure(Throwable t)
            {
                logger.error("Prepare phase for incremental repair session {} failed", sessionID, t);
                if (t instanceof PendingAntiCompaction.SSTableAcquisitionException)
                {
                    logger.warn("Prepare phase for incremental repair session {} was unable to " +
                                "acquire exclusive access to the neccesary sstables. " +
                                "This is usually caused by running multiple incremental repairs on nodes that share token ranges",
                                sessionID);

                }
                else
                {
                    logger.error("Prepare phase for incremental repair session {} failed", sessionID, t);
                }
                sendMessage(coordinator, new PrepareConsistentResponse(sessionID, getBroadcastAddressAndPort(), false));
                failSession(sessionID, false);
                executor.shutdown();
            }
        });
    }

