    protected SSTableReader(final Descriptor desc,
                            Set<Component> components,
                            CFMetaData metadata,
                            IPartitioner partitioner,
                            long maxDataAge,
                            StatsMetadata sstableMetadata,
                            OpenReason openReason)
    {
        super(desc, components, metadata, partitioner);
        this.sstableMetadata = sstableMetadata;
        this.maxDataAge = maxDataAge;
        this.openReason = openReason;

        this.rowIndexEntrySerializer = descriptor.version.getSSTableFormat().getIndexSerializer(metadata);

        tidy.deletingTask = new SSTableDeletingTask(this);

        // Don't track read rates for tables in the system keyspace.  Also don't track reads for special operations (like early open)
        // this is to avoid overflowing the executor queue (see CASSANDRA-8066)
        if (SystemKeyspace.NAME.equals(desc.ksname) || openReason != OpenReason.NORMAL)
        {
            readMeter = null;
            readMeterSyncFuture = null;
            return;
        }

        readMeter = SystemKeyspace.getSSTableReadMeter(desc.ksname, desc.cfname, desc.generation);
        // sync the average read rate to system.sstable_activity every five minutes, starting one minute from now
        readMeterSyncFuture = syncExecutor.scheduleAtFixedRate(new Runnable()
        {
            public void run()
            {
                if (!isCompacted.get())
                {
                    meterSyncThrottle.acquire();
                    SystemKeyspace.persistSSTableReadMeter(desc.ksname, desc.cfname, desc.generation, readMeter);
                }
            }
        }, 1, 5, TimeUnit.MINUTES);
    }

