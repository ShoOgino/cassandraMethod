    private void mergeTie(ContextState mergedState, ContextState leftState, ContextState rightState)
    {
        if (leftState.isGlobal() || rightState.isGlobal())
        {
            if (leftState.isGlobal() && rightState.isGlobal())
            {
                long leftClock = leftState.getClock();
                long rightClock = rightState.getClock();

                if (leftClock == rightClock)
                {
                    long leftCount = leftState.getCount();
                    long rightCount = rightState.getCount();

                    // Can happen if an sstable gets lost and disk failure policy is set to 'best effort'
                    if (leftCount != rightCount && CompactionManager.isCompactionManager.get())
                    {
                        logger.warn("invalid global counter shard detected; ({}, {}, {}) and ({}, {}, {}) differ only in "
                                    + "count; will pick highest to self-heal on compaction",
                                    leftState.getCounterId(), leftClock, leftCount,
                                    rightState.getCounterId(), rightClock, rightCount);
                    }

                    if (leftCount > rightCount)
                        leftState.copyTo(mergedState);
                    else
                        rightState.copyTo(mergedState);
                }
                else
                {
                    (leftClock > rightClock ? leftState : rightState).copyTo(mergedState);
                }
            }
            else // only one is global - keep that one
            {
                (leftState.isGlobal() ? leftState : rightState).copyTo(mergedState);
            }
        }
        else if (leftState.isLocal() || rightState.isLocal())
        {
            // Local id and at least one is a local shard.
            if (leftState.isLocal() && rightState.isLocal())
            {
                // both local - sum
                long clock = leftState.getClock() + rightState.getClock();
                long count = leftState.getCount() + rightState.getCount();
                mergedState.writeLocal(leftState.getCounterId(), clock, count);
            }
            else // only one is local - keep that one
            {
                (leftState.isLocal() ? leftState : rightState).copyTo(mergedState);
            }
        }
        else // both are remote shards
        {
            long leftClock = leftState.getClock();
            long rightClock = rightState.getClock();

            if (leftClock == rightClock)
            {
                // We should never see non-local shards w/ same id+clock but different counts. However, if we do
                // we should "heal" the problem by being deterministic in our selection of shard - and
                // log the occurrence so that the operator will know something is wrong.
                long leftCount = leftState.getCount();
                long rightCount = rightState.getCount();

                if (leftCount != rightCount && CompactionManager.isCompactionManager.get())
                {
                    logger.warn("invalid remote counter shard detected; ({}, {}, {}) and ({}, {}, {}) differ only in "
                                + "count; will pick highest to self-heal on compaction",
                                leftState.getCounterId(), leftClock, leftCount,
                                rightState.getCounterId(), rightClock, rightCount);
                }

                if (leftCount > rightCount)
                    leftState.copyTo(mergedState);
                else
                    rightState.copyTo(mergedState);
            }
            else
            {
                if ((leftClock >= 0 && rightClock > 0 && leftClock >= rightClock)
                        || (leftClock < 0 && (rightClock > 0 || leftClock < rightClock)))
                    leftState.copyTo(mergedState);
                else
                    rightState.copyTo(mergedState);
            }
        }
    }

