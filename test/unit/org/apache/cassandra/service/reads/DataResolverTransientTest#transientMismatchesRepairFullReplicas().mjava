    /**
     * If the transient replica has new data, the full replicas shoould be repaired, the transient one should not
     */
    @Test
    public void transientMismatchesRepairFullReplicas()
    {
        SinglePartitionReadCommand command = SinglePartitionReadCommand.fullPartitionRead(cfm, nowInSec, dk(5));
        EndpointsForToken targetReplicas = EndpointsForToken.of(key.getToken(), full(EP1), full(EP2), trans(EP3));
        TestableReadRepair<?, ?> repair = new TestableReadRepair(command);
        DataResolver resolver = new DataResolver(command, plan(targetReplicas, QUORUM), repair, 0);

        Assert.assertFalse(resolver.isDataPresent());
        PartitionUpdate transData = update(row(1000, 5, 5)).build();
        resolver.preprocess(response(command, EP1, EmptyIterators.unfilteredPartition(cfm), false));
        resolver.preprocess(response(command, EP2, EmptyIterators.unfilteredPartition(cfm), false));
        resolver.preprocess(response(command, EP3, iter(transData), false));

        Assert.assertFalse(repair.dataWasConsumed());

        assertPartitionsEqual(filter(iter(transData)), resolver.resolve());

        Assert.assertTrue(repair.dataWasConsumed());

        assertPartitionsEqual(filter(iter(transData)), filter(iter(repair.sent.get(EP1).getPartitionUpdate(cfm))));
        assertPartitionsEqual(filter(iter(transData)), filter(iter(repair.sent.get(EP2).getPartitionUpdate(cfm))));
        Assert.assertFalse(repair.sent.containsKey(EP3));

    }

