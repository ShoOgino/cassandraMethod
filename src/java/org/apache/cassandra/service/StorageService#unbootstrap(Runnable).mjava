    private void unbootstrap(final Runnable onFinish)
    {
        Multimap<Range, InetAddress> rangesMM = getChangedRangesForLeaving(FBUtilities.getLocalAddress());
        if (logger_.isDebugEnabled())
            logger_.debug("Ranges needing transfer are [" + StringUtils.join(rangesMM.keySet(), ",") + "]");

        if (rangesMM.isEmpty())
        {
            // nothing needs transfer, so leave immediately.  this can happen when replication factor == number of nodes.
            leaveRing();
            onFinish.run();
            return;
        }

        final Set<Map.Entry<Range, InetAddress>> pending = new HashSet<Map.Entry<Range, InetAddress>>(rangesMM.entries());
        for (final Map.Entry<Range, InetAddress> entry : rangesMM.entries())
        {
            final Range range = entry.getKey();
            final InetAddress newEndpoint = entry.getValue();
            final Runnable callback = new Runnable()
            {
                public synchronized void run()
                {
                    pending.remove(entry);
                    if (pending.isEmpty())
                    {
                        leaveRing();
                        onFinish.run();
                    }
                }
            };
            StageManager.getStage(StageManager.STREAM_STAGE).execute(new Runnable()
            {
                public void run()
                {
                    // TODO each call to transferRanges re-flushes, this is potentially a lot of waste
                    Streaming.transferRanges(newEndpoint, Arrays.asList(range), callback);
                }
            });
        }
    }

