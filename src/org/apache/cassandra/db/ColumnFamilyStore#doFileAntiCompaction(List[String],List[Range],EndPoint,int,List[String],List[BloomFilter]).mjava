    /**
     * This function is used to do the anti compaction process , it spits out the file which has keys that belong to a given range
     * If the target is not specified it spits out the file as a compacted file with the unecessary ranges wiped out.
     * @param files
     * @param ranges
     * @param target
     * @param minBufferSize
     * @param fileList
     * @return
     * @throws IOException
     */
    boolean doFileAntiCompaction(List<String> files, List<Range> ranges, EndPoint target, int minBufferSize, List<String> fileList, List<BloomFilter> compactedBloomFilters) throws IOException
    {
    	boolean result = false;
        long startTime = System.currentTimeMillis();
        long totalBytesRead = 0;
        long totalBytesWritten = 0;
        long totalkeysRead = 0;
        long totalkeysWritten = 0;
        String rangeFileLocation = null;
        String mergedFileName = null;
        try
        {
	        // Calculate the expected compacted filesize
	    	long expectedRangeFileSize = getExpectedCompactedFileSize(files);
	    	/* in the worst case a node will be giving out alf of its data so we take a chance */
	    	expectedRangeFileSize = expectedRangeFileSize / 2;
	        rangeFileLocation = DatabaseDescriptor.getCompactionFileLocation(expectedRangeFileSize);
//	        boolean isLoop = isLoopAround( ranges );
//	        Range maxRange = getMaxRange( ranges );
	        // If the compaction file path is null that means we have no space left for this compaction.
	        if( rangeFileLocation == null )
	        {
	            logger_.warn("Total bytes to be written for range compaction  ..."
	                    + expectedRangeFileSize + "   is greater than the safe limit of the disk space available.");
	            return result;
	        }
	        PriorityQueue<FileStruct> pq = initializePriorityQueue(files, ranges, minBufferSize);
	        if (pq.size() > 0)
	        {
	            mergedFileName = getTempFileName();
	            SSTable ssTableRange = null ;
	            String lastkey = null;
	            List<FileStruct> lfs = new ArrayList<FileStruct>();
	            DataOutputBuffer bufOut = new DataOutputBuffer();
	            int expectedBloomFilterSize = SSTable.getApproximateKeyCount(files);
	            expectedBloomFilterSize = (expectedBloomFilterSize > 0) ? expectedBloomFilterSize : SSTable.indexInterval();
	            logger_.debug("Expected bloom filter size : " + expectedBloomFilterSize);
	            /* Create the bloom filter for the compacted file. */
	            BloomFilter compactedRangeBloomFilter = new BloomFilter(expectedBloomFilterSize, 15);
	            List<ColumnFamily> columnFamilies = new ArrayList<ColumnFamily>();

	            while (pq.size() > 0 || lfs.size() > 0)
	            {
	                FileStruct fs = null;
	                if (pq.size() > 0)
	                {
	                    fs = pq.poll();
	                }
	                if (fs != null
	                        && (lastkey == null || lastkey.compareTo(fs.key_) == 0))
	                {
	                    // The keys are the same so we need to add this to the
	                    // ldfs list
	                    lastkey = fs.key_;
	                    lfs.add(fs);
	                }
	                else
	                {
	                    Collections.sort(lfs, new FileStructComparator());
	                    ColumnFamily columnFamily = null;
	                    bufOut.reset();
	                    if(lfs.size() > 1)
	                    {
		                    for (FileStruct filestruct : lfs)
		                    {
		                    	try
		                    	{
	                                /* read the length although we don't need it */
	                                filestruct.bufIn_.readInt();
	                                // Skip the Index
                                    IndexHelper.skipBloomFilterAndIndex(filestruct.bufIn_);
	                                // We want to add only 2 and resolve them right there in order to save on memory footprint
	                                if(columnFamilies.size() > 1)
	                                {
	    		                        // Now merge the 2 column families
	    			                    columnFamily = resolve(columnFamilies);
	    			                    columnFamilies.clear();
	    			                    if( columnFamily != null)
	    			                    {
		    			                    // add the merged columnfamily back to the list
		    			                    columnFamilies.add(columnFamily);
	    			                    }

	                                }
			                        // deserialize into column families
			                        columnFamilies.add(ColumnFamily.serializer().deserialize(filestruct.bufIn_));
		                    	}
		                    	catch ( Exception ex)
		                    	{
                                    logger_.warn(LogUtil.throwableToString(ex));
		                            continue;
		                    	}
		                    }
		                    // Now after merging all crap append to the sstable
		                    columnFamily = resolve(columnFamilies);
		                    columnFamilies.clear();
		                    if( columnFamily != null )
		                    {
			                	/* serialize the cf with column indexes */
			                    ColumnFamily.serializerWithIndexes().serialize(columnFamily, bufOut);
		                    }
	                    }
	                    else
	                    {
		                    FileStruct filestruct = lfs.get(0);
	                    	try
	                    	{
		                        /* read the length although we don't need it */
		                        int size = filestruct.bufIn_.readInt();
		                        bufOut.write(filestruct.bufIn_, size);
	                    	}
	                    	catch ( Exception ex)
	                    	{
	                    		logger_.warn(LogUtil.throwableToString(ex));
	                            filestruct.reader_.close();
	                            continue;
	                    	}
	                    }
	                    if ( Range.isKeyInRanges(ranges, lastkey) )
	                    {
	                        if(ssTableRange == null )
	                        {
	                        	if( target != null )
	                        		rangeFileLocation = rangeFileLocation + System.getProperty("file.separator") + "bootstrap";
	                	        FileUtils.createDirectory(rangeFileLocation);
	                            ssTableRange = new SSTable(rangeFileLocation, mergedFileName);
	                        }	                        
	                        try
	                        {
		                        ssTableRange.append(lastkey, bufOut);
		                        compactedRangeBloomFilter.fill(lastkey);                                
	                        }
	                        catch(Exception ex)
	                        {
	                            logger_.warn( LogUtil.throwableToString(ex) );
	                        }
	                    }
	                    totalkeysWritten++;
	                    for (FileStruct filestruct : lfs)
	                    {
	                    	try
	                    	{
	                    		filestruct = getNextKey	( filestruct );
	                    		if(filestruct == null)
	                    		{
	                    			continue;
	                    		}
	                    		/* keep on looping until we find a key in the range */
	                            while ( !Range.isKeyInRanges(ranges, filestruct.key_ ) )
	                            {
		                    		filestruct = getNextKey	( filestruct );
		                    		if(filestruct == null)
		                    		{
		                    			break;
		                    		}
	        	                    /* check if we need to continue , if we are done with ranges empty the queue and close all file handles and exit */
	        	                    //if( !isLoop && StorageService.hash(filestruct.key).compareTo(maxRange.right()) > 0 && !filestruct.key.equals(""))
	        	                    //{
	                                    //filestruct.reader.close();
	                                    //filestruct = null;
	                                    //break;
	        	                    //}
	                            }
	                            if ( filestruct != null)
	                            {
	                            	pq.add(filestruct);
	                            }
		                        totalkeysRead++;
	                    	}
	                    	catch ( Exception ex )
	                    	{
	                    		// Ignore the exception as it might be a corrupted file
	                    		// in any case we have read as far as possible from it
	                    		// and it will be deleted after compaction.
                                logger_.warn(LogUtil.throwableToString(ex));
	                            filestruct.reader_.close();
	                            continue;
	                    	}
	                    }
	                    lfs.clear();
	                    lastkey = null;
	                    if (fs != null)
	                    {
	                        // Add back the fs since we processed the rest of
	                        // filestructs
	                        pq.add(fs);
	                    }
	                }
	            }
	            if( ssTableRange != null )
	            {
                    if ( fileList == null )
                        fileList = new ArrayList<String>();
                    ssTableRange.closeRename(compactedRangeBloomFilter, fileList);
                    if(compactedBloomFilters != null)
                    	compactedBloomFilters.add(compactedRangeBloomFilter);
	            }
	        }
        }
        catch ( Exception ex)
        {
            logger_.warn( LogUtil.throwableToString(ex) );
        }
        logger_.debug("Total time taken for range split   ..."
                + (System.currentTimeMillis() - startTime));
        logger_.debug("Total bytes Read for range split  ..." + totalBytesRead);
        logger_.debug("Total bytes written for range split  ..."
                + totalBytesWritten + "   Total keys read ..." + totalkeysRead);
        return result;
    }

