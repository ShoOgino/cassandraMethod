    public static List<Pair<String, ColumnFamily>> getRangeSlice(RangeSliceCommand command, ConsistencyLevel consistency_level)
    throws IOException, UnavailableException, TimeoutException
    {
        long startTime = System.nanoTime();
        TokenMetadata tokenMetadata = StorageService.instance.getTokenMetadata();

        InetAddress endPoint = StorageService.instance.getPrimary(command.range.left);
        InetAddress startEndpoint = endPoint;
        final String table = command.keyspace;
        int responseCount = determineBlockFor(DatabaseDescriptor.getReplicationFactor(table), DatabaseDescriptor.getReplicationFactor(table), consistency_level);

        // starting with the node that is primary for the start key, scan until either we have enough results,
        // or the node scan reports that it was done (i.e., encountered a key outside the desired range).
        Map<String, ColumnFamily> rows = new HashMap<String, ColumnFamily>(command.max_keys);
        outer:
        do
        {
            Range primaryRange = StorageService.instance.getPrimaryRangeForEndPoint(endPoint);
            List<InetAddress> endpoints = StorageService.instance.getLiveNaturalEndpoints(command.keyspace, primaryRange.right);
            if (endpoints.size() < responseCount)
                throw new UnavailableException();

            // to make comparing the results from each node easy, we restrict each scan the primary range for the node in question
            List<AbstractBounds> restricted = command.range.restrictTo(primaryRange);
            for (AbstractBounds range : restricted)
            {
                RangeSliceCommand c2 = new RangeSliceCommand(command.keyspace, command.column_family, command.super_column, command.predicate, range, command.max_keys);
                Message message = c2.getMessage();

                // collect replies and resolve according to consistency level
                RangeSliceResponseResolver resolver = new RangeSliceResponseResolver(command.keyspace, primaryRange, endpoints);
                QuorumResponseHandler<Map<String, ColumnFamily>> handler = new QuorumResponseHandler<Map<String, ColumnFamily>>(responseCount, resolver);
                if (logger.isDebugEnabled())
                    logger.debug("reading " + c2 + " for " + range + " from " + message.getMessageId() + "@" + endPoint);
                for (InetAddress replicaEndpoint : endpoints)
                {
                    MessagingService.instance.sendRR(message, replicaEndpoint, handler);
                }

                // if we're done, great, otherwise, move to the next range
                try
                {
                    rows.putAll(handler.get());
                }
                catch (DigestMismatchException e)
                {
                    throw new AssertionError(e); // no digests in range slices yet
                }
                if (rows.size() >= command.max_keys || resolver.completed())
                    break outer;
            }

            endPoint = tokenMetadata.getSuccessor(endPoint);
        }
        while (!endPoint.equals(startEndpoint));

        List<Pair<String, ColumnFamily>> results = new ArrayList<Pair<String, ColumnFamily>>(rows.size());
        for (Map.Entry<String, ColumnFamily> entry : rows.entrySet())
        {
            ColumnFamily cf = entry.getValue();
            results.add(new Pair<String, ColumnFamily>(entry.getKey(), cf));
        }
        Collections.sort(results, new Comparator<Pair<String, ColumnFamily>>()
        {
            public int compare(Pair<String, ColumnFamily> o1, Pair<String, ColumnFamily> o2)
            {
                return keyComparator.compare(o1.left, o2.left);                
            }
        });
        rangeStats.addNano(System.nanoTime() - startTime);
        return results;
    }

