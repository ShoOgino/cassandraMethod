    // An iterator over all column definitions but that respect the order of a SELECT *.
    public Iterator<ColumnDefinition> allColumnsInSelectOrder()
    {
        return new AbstractIterator<ColumnDefinition>()
        {
            private final Iterator<ColumnDefinition> partitionKeyIter = partitionKeyColumns.iterator();
            private final Iterator<ColumnDefinition> clusteringIter = clusteringColumns.iterator();
            private boolean valueDone;
            private final Iterator<ColumnDefinition> regularIter = regularColumns.iterator();

            protected ColumnDefinition computeNext()
            {
                if (partitionKeyIter.hasNext())
                    return partitionKeyIter.next();

                if (clusteringIter.hasNext())
                    return clusteringIter.next();

                if (compactValueColumn != null && !valueDone)
                {
                    valueDone = true;
                    // If the compactValueColumn is empty, this means we have a dense table but
                    // with only a PK. As far as selects are concerned, we should ignore the value.
                    if (compactValueColumn.name.bytes.hasRemaining())
                        return compactValueColumn;
                }

                if (regularIter.hasNext())
                    return regularIter.next();

                return endOfData();
            }
        };
    }

