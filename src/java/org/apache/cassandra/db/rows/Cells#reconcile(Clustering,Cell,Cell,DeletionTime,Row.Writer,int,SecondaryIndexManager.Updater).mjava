    /**
     * Reconciles/merges two cells, one being an update to an existing cell,
     * yielding index updates if appropriate.
     * <p>
     * Note that this method assumes that the provided cells can meaningfully
     * be reconciled together, that is that those cells are for the same row and same
     * column (and same cell path if the column is complex).
     * <p>
     * Also note that which cell is provided as {@code existing} and which is
     * provided as {@code update} matters for index updates.
     *
     * @param clustering the clustering for the row the cells to merge originate from.
     * This is only used for index updates, so this can be {@code null} if
     * {@code indexUpdater == SecondaryIndexManager.nullUpdater}.
     * @param existing the pre-existing cell, the one that is updated. This can be
     * {@code null} if this reconciliation correspond to an insertion.
     * @param update the newly added cell, the update. This can be {@code null} out
     * of convenience, in which case this function simply copy {@code existing} to
     * {@code writer}.
     * @param deletion the deletion time that applies to the cells being considered.
     * This deletion time may delete both {@code existing} or {@code update}.
     * @param writer the row writer to which the result of the reconciliation is written.
     * @param nowInSec the current time in seconds (which plays a role during reconciliation
     * because deleted cells always have precedence on timestamp equality and deciding if a
     * cell is a live or not depends on the current time due to expiring cells).
     * @param indexUpdater an index updater to which the result of the reconciliation is
     * signaled (if relevant, that is if the update is not simply ignored by the reconciliation).
     * This cannot be {@code null} but {@code SecondaryIndexManager.nullUpdater} can be passed.
     *
     * @return the timestamp delta between existing and update, or {@code Long.MAX_VALUE} if one
     * of them is {@code null} or deleted by {@code deletion}).
     */
    public static long reconcile(Clustering clustering,
                                 Cell existing,
                                 Cell update,
                                 DeletionTime deletion,
                                 Row.Writer writer,
                                 int nowInSec,
                                 SecondaryIndexManager.Updater indexUpdater)
    {
        existing = existing == null || deletion.deletes(existing.livenessInfo()) ? null : existing;
        update = update == null || deletion.deletes(update.livenessInfo()) ? null : update;
        if (existing == null || update == null)
        {
            if (update != null)
            {
                // It's inefficient that we call maybeIndex (which is for primary key indexes) on every cell, but
                // we'll need to fix that damn 2ndary index API to avoid that.
                updatePKIndexes(clustering, update, nowInSec, indexUpdater);
                indexUpdater.insert(clustering, update);
                update.writeTo(writer);
            }
            else if (existing != null)
            {
                existing.writeTo(writer);
            }
            return Long.MAX_VALUE;
        }

        Cell reconciled = reconcile(existing, update, nowInSec);
        reconciled.writeTo(writer);

        // Note that this test rely on reconcile returning either 'existing' or 'update'. That's not true for counters but we don't index them
        if (reconciled == update)
        {
            updatePKIndexes(clustering, update, nowInSec, indexUpdater);
            indexUpdater.update(clustering, existing, reconciled);
        }
        return Math.abs(existing.livenessInfo().timestamp() - update.livenessInfo().timestamp());
    }

