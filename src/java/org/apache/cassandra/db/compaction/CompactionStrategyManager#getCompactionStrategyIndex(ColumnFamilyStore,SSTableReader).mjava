    /**
     * Get the correct compaction strategy for the given sstable. If the first token starts within a disk boundary, we
     * will add it to that compaction strategy.
     *
     * In the case we are upgrading, the first compaction strategy will get most files - we do not care about which disk
     * the sstable is on currently (unless we don't know the local tokens yet). Once we start compacting we will write out
     * sstables in the correct locations and give them to the correct compaction strategy instance.
     *
     * @param cfs
     * @param sstable
     * @return
     */
    public static int getCompactionStrategyIndex(ColumnFamilyStore cfs, SSTableReader sstable)
    {
        if (!cfs.getPartitioner().splitter().isPresent())
            return 0;

        DiskBoundaries boundaries = cfs.getDiskBoundaries();
        List<Directories.DataDirectory> directories = boundaries.directories;

        if (boundaries.positions == null)
        {
            // try to figure out location based on sstable directory:
            for (int i = 0; i < directories.size(); i++)
            {
                Directories.DataDirectory directory = directories.get(i);
                if (sstable.descriptor.directory.getAbsolutePath().startsWith(directory.location.getAbsolutePath()))
                    return i;
            }
            return 0;
        }

        int pos = Collections.binarySearch(boundaries.positions, sstable.first);
        assert pos < 0; // boundaries are .minkeybound and .maxkeybound so they should never be equal
        return -pos - 1;
    }

