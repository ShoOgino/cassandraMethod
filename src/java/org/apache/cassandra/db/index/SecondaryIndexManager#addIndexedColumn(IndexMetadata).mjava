    /**
     * Adds and builds a index for a column
     * @param indexDef the index metadata
     * @return a future which the caller can optionally block on signaling the index is built
     */
    public synchronized Future<?> addIndexedColumn(IndexMetadata indexDef)
    {
        ColumnDefinition cdef = indexDef.indexedColumn(baseCfs.metadata);
        if (indexesByColumn.containsKey(cdef.name.bytes))
            return null;

        SecondaryIndex index = SecondaryIndex.createInstance(baseCfs, indexDef);

        // Keep a single instance of the index per-cf for row level indexes
        // since we want all columns to be under the index
        if (index instanceof PerRowSecondaryIndex)
        {
            SecondaryIndex currentIndex = rowLevelIndexMap.get(index.getClass());

            if (currentIndex == null)
            {
                rowLevelIndexMap.put(index.getClass(), index);
                index.init();
            }
            else
            {
                index = currentIndex;
                index.setIndexMetadata(indexDef);
                logger.info("Creating new index : {}",indexDef.name);
            }
        }
        else
        {
            // TODO: We sould do better than throw a RuntimeException
            if (indexDef.isCustom() && index instanceof AbstractSimplePerColumnSecondaryIndex)
                throw new RuntimeException("Cannot use a subclass of AbstractSimplePerColumnSecondaryIndex as a CUSTOM index, as they assume they are CFS backed");
            index.init();
        }

        // link in indexedColumns. this means that writes will add new data to
        // the index immediately,
        // so we don't have to lock everything while we do the build. it's up to
        // the operator to wait
        // until the index is actually built before using in queries.
        indexesByColumn.put(cdef.name.bytes, index);

        // Add to all indexes set:
        allIndexes.add(index);

        // if we're just linking in the index to indexedColumns on an
        // already-built index post-restart, we're done
        if (index.isIndexBuilt(cdef.name.bytes))
            return null;

        return index.buildIndexAsync();
    }

