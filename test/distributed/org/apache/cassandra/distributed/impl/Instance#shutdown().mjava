    @Override
    public Future<Void> shutdown()
    {
        Future<?> future = async((ExecutorService executor) -> {
            Throwable error = null;
            error = parallelRun(error, executor,
                    Gossiper.instance::stop,
                    CompactionManager.instance::forceShutdown,
                    BatchlogManager.instance::shutdown,
                    HintsService.instance::shutdownBlocking,
                    () -> SecondaryIndexManager.shutdownAndWait(1L, MINUTES),
                    () -> ColumnFamilyStore.shutdownExecutorsAndWait(1L, MINUTES),
                    () -> PendingRangeCalculatorService.instance.shutdownAndWait(1L, MINUTES),
                    () -> BufferPool.shutdownLocalCleaner(1L, MINUTES),
                    () -> Ref.shutdownReferenceReaper(1L, MINUTES),
                    () -> Memtable.MEMORY_POOL.shutdown(1L, MINUTES),
                    () -> ScheduledExecutors.shutdownAndWait(1L, MINUTES),
                    () -> SSTableReader.shutdownBlocking(1L, MINUTES),
                    () -> shutdownAndWait(Collections.singletonList(ActiveRepairService.repairCommandExecutor))
            );
            error = parallelRun(error, executor,
                                CommitLog.instance::shutdownBlocking,
                                () -> MessagingService.instance().shutdown(1L, MINUTES, false, true)
            );
            error = parallelRun(error, executor,
                                () -> StageManager.shutdownAndWait(1L, MINUTES),
                                () -> SharedExecutorPool.SHARED.shutdown(1L, MINUTES)
            );

            LoggerContext loggerContext = (LoggerContext) LoggerFactory.getILoggerFactory();
            loggerContext.stop();
            Throwables.maybeFail(error);
        }).apply(isolatedExecutor);

        return CompletableFuture.runAsync(ThrowingRunnable.toRunnable(future::get), isolatedExecutor)
                                .thenRun(super::shutdown);
    }

