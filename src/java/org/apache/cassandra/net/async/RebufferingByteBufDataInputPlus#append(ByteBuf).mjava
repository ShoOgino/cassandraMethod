    /**
     * Append a {@link ByteBuf} to the end of the einternal queue.
     *
     * Note: it's expected this method is invoked on the netty event loop.
     */
    public void append(ByteBuf buf) throws IllegalStateException
    {
        assert buf != null : "buffer cannot be null";

        if (closed)
        {
            ReferenceCountUtil.release(buf);
            throw new IllegalStateException("stream is already closed, so cannot add another buffer");
        }

        // this slightly undercounts the live count as it doesn't include the currentBuf's size.
        // that's ok as the worst we'll do is allow another buffer in and add it to the queue,
        // and that point we'll disable auto-read. this is a tradeoff versus making some other member field
        // atomic or volatile.
        int queuedCount = queuedByteCount.addAndGet(buf.readableBytes());
        if (channelConfig.isAutoRead() && queuedCount > highWaterMark)
            channelConfig.setAutoRead(false);

        queue.add(buf);
    }

