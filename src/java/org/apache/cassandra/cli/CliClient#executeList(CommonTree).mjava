    private void executeList(CommonTree ast)
    throws TException, InvalidRequestException, NotFoundException, IllegalAccessException, InstantiationException, NoSuchFieldException, UnavailableException, TimedOutException, UnsupportedEncodingException
    {
        if (!CliMain.isConnected())
            return;

        assert (ast.getChildCount() >= 1 || ast.getChildCount() <= 3) : "Incorrect AST Construct!";
        Iterator<CommonTree> iter = ast.getChildren().iterator();

        // extract column family
        String columnFamily = iter.next().getText();

        String startKey = "";
        String endKey = "";
        int limitCount = Integer.MAX_VALUE; // will reset to default later if it's not specified

        // optional arguments: key range and limit
        while (iter.hasNext())
        {
            CommonTree child = iter.next();
            if (child.getType() == CliParser.NODE_KEY_RANGE)
            {
                if (child.getChildCount() > 0)
                {
                    startKey = CliUtils.unescapeSQLString(child.getChild(0).getText());
                    if (child.getChildCount() > 1)
                        endKey = CliUtils.unescapeSQLString(child.getChild(1).getText());
                }
            }
            else
            {
                assert child.getType() == CliParser.NODE_LIMIT;
                if (child.getChildCount() != 1)
                {
                    css_.out.println("Invalid limit clause");
                    return;
                }
                limitCount = Integer.parseInt(child.getChild(0).getText());
                if (limitCount <= 0)
                {
                    css_.out.println("Invalid limit " + limitCount);
                    return;
                }
            }
        }

        if (limitCount == Integer.MAX_VALUE)
        {
            limitCount = 100;
            css_.out.println("Using default limit of 100");
        }

        List<String> cfnames = new ArrayList<String>();
        for (CfDef cfd : keyspacesMap.get(keySpace).cf_defs)
        {
            cfnames.add(cfd.name);
        }

        int idx = cfnames.indexOf(columnFamily);
        if (idx == -1)
        {
            css_.out.println("No such column family: " + columnFamily);
            return;
        }

        // read all columns and superColumns
        SlicePredicate predicate = new SlicePredicate();
        SliceRange sliceRange = new SliceRange();
        sliceRange.setStart(new byte[0]).setFinish(new byte[0]);
        predicate.setSlice_range(sliceRange);

        // set the key range
        KeyRange range = new KeyRange(limitCount);
        range.setStart_key(startKey.getBytes()).setEnd_key(endKey.getBytes());

        ColumnParent columnParent = new ColumnParent(columnFamily);
        List<KeySlice> keySlices = thriftClient_.get_range_slices(columnParent, predicate, range, ConsistencyLevel.ONE);
        int toIndex = keySlices.size();
        List<KeySlice> limitSlices = keySlices.subList(0, toIndex);

        for (KeySlice ks : limitSlices)
        {
            css_.out.printf("-------------------\nRowKey: %s\n", new String(ks.key, "UTF-8"));
            Iterator<ColumnOrSuperColumn> iterator = ks.getColumnsIterator();
            while (iterator.hasNext())
            {
                ColumnOrSuperColumn columnOrSuperColumn = iterator.next();
                if (columnOrSuperColumn.column != null)
                {
                    Column col = columnOrSuperColumn.column;
                    css_.out.printf("=> (column=%s, value=%s, timestamp=%d)\n",
                                    formatColumnName(keySpace, columnFamily, col), new String(col.value, "UTF-8"), col.timestamp);
                }
                else if (columnOrSuperColumn.super_column != null)
                {
                    SuperColumn superCol = columnOrSuperColumn.super_column;
                    css_.out.printf("=> (super_column=%s,", formatSuperColumnName(keySpace, columnFamily, superCol));
                    for (Column col : superCol.columns)
                    {
                        css_.out.printf("\n     (column=%s, value=%s, timestamp=%d)",
                                        formatSubcolumnName(keySpace, columnFamily, col), new String(col.value, "UTF-8"), col.timestamp);
                    }
                    css_.out.println(")");
                }
            }
        }

        css_.out.printf("\n%d row%s returned\n", toIndex, (toIndex == 0 || toIndex > 1 ? "s" : ""));
    }

