    /**
     * Handle node being actively removed from the ring.
     *
     * @param endpoint node
     * @param moveValue (token to notify of removal)<Delimiter>(token to remove)
     */
    private void handleStateRemoving(InetAddress endpoint, String[] pieces)
    {
        assert pieces.length == 4;
        Token removeToken = getPartitioner().getTokenFactory().fromString(pieces[3]);
        InetAddress removeEndpoint = tokenMetadata_.getEndpoint(removeToken);
        
        if (removeEndpoint == null)
            return;
        
        if (removeEndpoint.equals(FBUtilities.getLocalAddress()))
        {
            logger_.info("Received removeToken gossip about myself. Is this node a replacement for a removed one?");
            return;
        }

        if (VersionedValue.REMOVED_TOKEN.equals(pieces[2]))
        {
            Gossiper.instance.removeEndpoint(removeEndpoint);
            tokenMetadata_.removeEndpoint(removeEndpoint);
            HintedHandOffManager.deleteHintsForEndPoint(removeEndpoint);
            tokenMetadata_.removeBootstrapToken(removeToken);
        }
        else if (VersionedValue.REMOVING_TOKEN.equals(pieces[2]))
        {
            if (logger_.isDebugEnabled())
                logger_.debug("Token " + removeToken + " removed manually (endpoint was " + removeEndpoint + ")");

            // Note that the endpoint is being removed
            tokenMetadata_.addLeavingEndpoint(removeEndpoint);
            calculatePendingRanges();

            // grab any data we are now responsible for and notify responsible node
            restoreReplicaCount(removeEndpoint, endpoint);
        }
    }

