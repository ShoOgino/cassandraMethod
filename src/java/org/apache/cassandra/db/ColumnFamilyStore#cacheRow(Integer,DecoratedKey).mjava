    public ColumnFamily cacheRow(Integer cfId, DecoratedKey decoratedKey)
    {
        CFMetaData.Caching caching = metadata.getCaching();
        assert caching == CFMetaData.Caching.ALL || caching == CFMetaData.Caching.ROWS_ONLY
                : String.format("Row cache is not enabled on column family [" + getColumnFamilyName() + "]");

        RowCacheKey key = new RowCacheKey(cfId, decoratedKey);

        ColumnFamily cached;

        if ((cached = CacheService.instance.rowCache.get(key)) == null)
        {
            // We force ThreadSafeSortedColumns because cached row will be accessed concurrently
            cached = getTopLevelColumns(QueryFilter.getIdentityFilter(decoratedKey, new QueryPath(columnFamily)),
                                        Integer.MIN_VALUE,
                                        true);

            if (cached == null)
                return null;

            // avoid keeping a permanent reference to the original key buffer
            CacheService.instance.rowCache.put(key, cached);
        }

        return cached;
    }

