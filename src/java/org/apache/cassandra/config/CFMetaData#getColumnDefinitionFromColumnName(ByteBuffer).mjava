    /**
     * Returns a ColumnDefinition given a full (internal) column name.
     */
    public ColumnDefinition getColumnDefinitionFromColumnName(ByteBuffer columnName)
    {
        if (!isSuper() && (comparator instanceof CompositeType))
        {
            CompositeType composite = (CompositeType)comparator;
            ByteBuffer[] components = composite.split(columnName);
            for (ColumnDefinition def : regularAndStaticColumns())
            {
                ByteBuffer toCompare;
                if (def.componentIndex == null)
                {
                    toCompare = columnName;
                }
                else
                {
                    if (def.componentIndex >= components.length)
                        continue;

                    toCompare = components[def.componentIndex];
                }
                if (def.name.equals(toCompare))
                    return def;
            }
            return null;
        }
        else
        {
            ColumnDefinition def = column_metadata.get(columnName);
            // It's possible that the def is a PRIMARY KEY or COMPACT_VALUE one in case a concrete cell
            // name conflicts with a CQL column name, which can happen in 2 cases:
            // 1) because the user inserted a cell through Thrift that conflicts with a default "alias" used
            //    by CQL for thrift tables (see #6892).
            // 2) for COMPACT STORAGE tables with a single utf8 clustering column, the cell name can be anything,
            //    including a CQL column name (without this being a problem).
            // In any case, this is fine, this just mean that columnDefinition is not the ColumnDefinition we are
            // looking for.
            return def != null && def.isPartOfCellName() ? def : null;
        }
    }

