    /**
     * Calculate pair of ranges to stream/fetch for given two range collections
     * (current ranges for keyspace and ranges after move to new token)
     *
     * With transient replication the added wrinkle is that if a range transitions from full to transient then
     * we need to stream the range despite the fact that we are retaining it as transient. Some replica
     * somewhere needs to transition from transient to full and we wll be the source.
     *
     * If the range is transient and is transitioning to full then always fetch even if the range was already transient
     * since a transiently replicated obviously needs to fetch data to become full.
     *
     * This why there is a continue after checking for instersection because intersection is not sufficient reason
     * to do the subtraction since we might need to stream/fetch data anyways.
     *
     * @param current collection of the ranges by current token
     * @param updated collection of the ranges after token is changed
     * @return pair of ranges to stream/fetch for given current and updated range collections
     */
    public static Pair<RangesAtEndpoint, RangesAtEndpoint> calculateStreamAndFetchRanges(RangesAtEndpoint current, RangesAtEndpoint updated)
    {
        // FIXME: transient replication
        // this should always be the local node, except for tests TODO: assert this
        RangesAtEndpoint.Builder toStream = RangesAtEndpoint.builder(current.endpoint());
        RangesAtEndpoint.Builder toFetch  = RangesAtEndpoint.builder(current.endpoint());

        logger.debug("Calculating toStream");
        for (Replica r1 : current)
        {
            boolean intersect = false;
            RangesAtEndpoint.Mutable remainder = null;
            for (Replica r2 : updated)
            {
                logger.debug("Comparing {} and {}", r1, r2);
                //If we will end up transiently replicating send the entire thing and don't subtract
                if (r1.intersectsOnRange(r2) && !(r1.isFull() && r2.isTransient()))
                {
                    RangesAtEndpoint.Mutable oldRemainder = remainder;
                    remainder = new RangesAtEndpoint.Mutable(current.endpoint());
                    if (oldRemainder != null)
                    {
                        for (Replica replica : oldRemainder)
                        {
                            remainder.addAll(replica.subtractIgnoreTransientStatus(r2.range()));
                        }
                    }
                    else
                    {
                        remainder.addAll(r1.subtractIgnoreTransientStatus(r2.range()));
                    }
                    logger.debug("    Intersects adding {}", remainder);
                    intersect = true;
                }
            }
            if (!intersect)
            {
                logger.debug("    Doesn't intersect adding {}", r1);
                toStream.add(r1); // should stream whole old range
            }
            else
            {
                toStream.addAll(remainder);
            }
        }

        logger.debug("Calculating toFetch");
        for (Replica r2 : updated)
        {
            boolean intersect = false;
            RangesAtEndpoint.Mutable remainder = null;
            for (Replica r1 : current)
            {
                logger.info("Comparing {} and {}", r2, r1);
                //Transitioning from transient to full means fetch everything so intersection doesn't matter.
                if (r2.intersectsOnRange(r1) && !(r1.isTransient() && r2.isFull()))
                {
                    RangesAtEndpoint.Mutable oldRemainder = remainder;
                    remainder = new RangesAtEndpoint.Mutable(current.endpoint());
                    if (oldRemainder != null)
                    {
                        for (Replica replica : oldRemainder)
                        {
                            remainder.addAll(replica.subtractIgnoreTransientStatus(r1.range()));
                        }
                    }
                    else
                    {
                        remainder.addAll(r2.subtractIgnoreTransientStatus(r1.range()));
                    }
                    logger.debug("    Intersects adding {}", remainder);
                    intersect = true;
                }
            }
            if (!intersect)
            {
                logger.debug("    Doesn't intersect adding {}", r2);
                toFetch.add(r2); // should fetch whole old range
            }
            else
            {
                toFetch.addAll(remainder);
            }
        }

        logger.debug("To stream {}", toStream);
        logger.debug("To fetch {}", toFetch);

        return Pair.create(toStream.build(), toFetch.build());
    }

