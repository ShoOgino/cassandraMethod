    public ComplexColumnData filter(ColumnFilter filter, DeletionTime activeDeletion, CFMetaData.DroppedColumn dropped)
    {
        ColumnFilter.Tester cellTester = filter.newTester(column);
        if (cellTester == null && activeDeletion.isLive() && dropped == null)
            return this;

        DeletionTime newComplexDeletion = activeDeletion.supersedes(complexDeletion) ? DeletionTime.LIVE : complexDeletion;

        int newSize = 0;
        for (Cell cell : cells)
        {
            // The cell must be:
            //   - Included by the query
            //   - not shadowed by the active deletion
            //   - not being for a dropped column
            if ((cellTester == null || cellTester.includes(cell.path()))
                 && !activeDeletion.deletes(cell)
                 && (dropped == null || cell.timestamp() > dropped.droppedTime))
                ++newSize;
        }


        if (newSize == 0)
            return newComplexDeletion.isLive() ? null : new ComplexColumnData(column, NO_CELLS, newComplexDeletion);

        if (newSize == cells.length && newComplexDeletion == complexDeletion)
            return this;

        Cell[] newCells = new Cell[newSize];
        int j = 0;
        cellTester = filter.newTester(column); // we need to reste the tester
        for (Cell cell : cells)
        {
            if ((cellTester == null || cellTester.includes(cell.path()))
                && !activeDeletion.deletes(cell)
                && (dropped == null || cell.timestamp() > dropped.droppedTime))
                newCells[j++] = cell;
        }
        assert j == newSize;

        return new ComplexColumnData(column, newCells, newComplexDeletion);
    }

