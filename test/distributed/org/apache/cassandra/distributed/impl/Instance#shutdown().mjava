    public Future<Void> shutdown()
    {
        Future<?> future = async((ExecutorService executor) -> {
            Throwable error = null;
            error = parallelRun(error, executor,
                    Gossiper.instance::stop,
                    CompactionManager.instance::forceShutdown,
                    BatchlogManager.instance::shutdown,
                    HintsService.instance::shutdownBlocking,
                    CommitLog.instance::shutdownBlocking,
                    SecondaryIndexManager::shutdownExecutors,
                    ColumnFamilyStore::shutdownFlushExecutor,
                    ColumnFamilyStore::shutdownPostFlushExecutor,
                    ColumnFamilyStore::shutdownReclaimExecutor,
                    ColumnFamilyStore::shutdownPerDiskFlushExecutors,
                    PendingRangeCalculatorService.instance::shutdownExecutor,
                    BufferPool::shutdownLocalCleaner,
                    Ref::shutdownReferenceReaper,
                    Memtable.MEMORY_POOL::shutdown,
                    ScheduledExecutors::shutdownAndWait,
                    SSTableReader::shutdownBlocking
            );
            error = parallelRun(error, executor,
                                MessagingService.instance()::shutdown
            );
            error = parallelRun(error, executor,
                                StageManager::shutdownAndWait,
                                SharedExecutorPool.SHARED::shutdown
            );

            LoggerContext loggerContext = (LoggerContext) LoggerFactory.getILoggerFactory();
            loggerContext.stop();
            Throwables.maybeFail(error);
        }).apply(isolatedExecutor);

        return CompletableFuture.runAsync(ThrowingRunnable.toRunnable(future::get), isolatedExecutor)
                                .thenRun(super::shutdown);
    }

