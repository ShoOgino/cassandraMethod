    /**
     * Call this whenever a compaction might be needed on the given columnfamily.
     * It's okay to over-call (within reason) since the compactions are single-threaded,
     * and if a call is unnecessary, it will just be no-oped in the bucketing phase.
     */
    public List<Future<?>> submitBackground(final ColumnFamilyStore cfs)
    {
        int count = compactingCF.count(cfs);
        if (count > 0 && executor.getActiveCount() >= executor.getMaximumPoolSize())
        {
            logger.debug("Background compaction is still running for {}.{} ({} remaining). Skipping",
                         new Object[] { cfs.table.getName(), cfs.name, count});
            return Collections.emptyList();
        }

        logger.debug("Scheduling a background task check for {}.{} with {}",
                     new Object[] { cfs.table.getName(),
                                   cfs.name,
                                   cfs.getCompactionStrategy().getClass().getSimpleName()});
        List<Future<?>> futures = new ArrayList<Future<?>>();
        // if we have room for more compactions, then fill up executor
        while (executor.getActiveCount() + futures.size() < executor.getMaximumPoolSize())
        {
            futures.add(executor.submit(new BackgroundCompactionTask(cfs)));
            compactingCF.add(cfs);
        }
        return futures;
    }

