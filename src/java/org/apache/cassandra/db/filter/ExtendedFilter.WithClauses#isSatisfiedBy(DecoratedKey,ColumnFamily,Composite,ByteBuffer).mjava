        public boolean isSatisfiedBy(DecoratedKey rowKey, ColumnFamily data, Composite prefix, ByteBuffer collectionElement)
        {
            for (IndexExpression expression : clause)
            {
                ColumnDefinition def = data.metadata().getColumnDefinition(expression.column);
                ByteBuffer dataValue = null;
                AbstractType<?> validator = null;
                if (def == null)
                {
                    // This can't happen with CQL3 as this should be rejected upfront. For thrift however,
                    // cell name are not predefined. But that means the cell name correspond to an internal one.
                    Cell cell = data.getColumn(data.getComparator().cellFromByteBuffer(expression.column));
                    if (cell != null)
                    {
                        dataValue = cell.value();
                        validator = data.metadata().getDefaultValidator();
                    }
                }
                else
                {
                    if (def.type.isCollection() && def.type.isMultiCell())
                    {
                        if (!collectionSatisfies(def, data, prefix, expression))
                            return false;
                        continue;
                    }

                    dataValue = extractDataValue(def, rowKey.getKey(), data, prefix);
                    validator = def.type;
                }

                if (dataValue == null)
                    return false;

                if (expression.operator == Operator.CONTAINS)
                {
                    assert def != null && def.type.isCollection() && !def.type.isMultiCell();
                    CollectionType type = (CollectionType)def.type;
                    switch (type.kind)
                    {
                        case LIST:
                            ListType<?> listType = (ListType)def.type;
                            if (!listType.getSerializer().deserialize(dataValue).contains(listType.getElementsType().getSerializer().deserialize(expression.value)))
                                return false;
                            break;
                        case SET:
                            SetType<?> setType = (SetType)def.type;
                            if (!setType.getSerializer().deserialize(dataValue).contains(setType.getElementsType().getSerializer().deserialize(expression.value)))
                                return false;
                            break;
                        case MAP:
                            MapType<?,?> mapType = (MapType)def.type;
                            if (!mapType.getSerializer().deserialize(dataValue).containsValue(mapType.getValuesType().getSerializer().deserialize(expression.value)))
                                return false;
                            break;
                    }
                }
                else if (expression.operator == Operator.CONTAINS_KEY)
                {
                    assert def != null && def.type.isCollection() && !def.type.isMultiCell() && def.type instanceof MapType;
                    MapType<?,?> mapType = (MapType)def.type;
                    if (mapType.getSerializer().getSerializedValue(dataValue, expression.value, mapType.getKeysType()) == null)
                        return false;
                }
                else
                {
                    int v = validator.compare(dataValue, expression.value);
                    if (!satisfies(v, expression.operator))
                        return false;
                }
            }
            return true;
        }

