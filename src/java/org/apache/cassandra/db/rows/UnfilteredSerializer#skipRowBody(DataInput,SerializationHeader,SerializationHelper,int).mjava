    public void skipRowBody(DataInput in, SerializationHeader header, SerializationHelper helper, int flags) throws IOException
    {
        boolean isStatic = isStatic(flags);
        boolean hasTimestamp = (flags & HAS_TIMESTAMP) != 0;
        boolean hasTTL = (flags & HAS_TTL) != 0;
        boolean hasDeletion = (flags & HAS_DELETION) != 0;
        boolean hasComplexDeletion = (flags & HAS_COMPLEX_DELETION) != 0;

        // Note that we don't want want to use FileUtils.skipBytesFully for anything that may not have
        // the size we think due to VINT encoding
        if (hasTimestamp)
            in.readLong();
        if (hasTTL)
        {
            // ttl and localDeletionTime
            in.readInt();
            in.readInt();
        }
        if (hasDeletion)
            UnfilteredRowIteratorSerializer.skipDelTime(in, header);

        Columns columns = header.columns(isStatic);
        if (header.useSparseColumnLayout(isStatic))
        {
            int count = columns.columnCount();
            int simpleCount = columns.simpleColumnCount();
            int i;
            while ((i = in.readShort()) >= 0)
            {
                if (i > count)
                    throw new IOException(String.format("Impossible column index %d, the header has only %d columns defined", i, count));

                if (i < simpleCount)
                    skipCell(columns.getSimple(i), in, header);
                else
                    skipComplexColumn(columns.getComplex(i - simpleCount), in, header, helper, hasComplexDeletion);
            }
        }
        else
        {
            for (int i = 0; i < columns.simpleColumnCount(); i++)
                skipCell(columns.getSimple(i), in, header);

            for (int i = 0; i < columns.complexColumnCount(); i++)
                skipComplexColumn(columns.getComplex(i), in, header, helper, hasComplexDeletion);
        }
    }

