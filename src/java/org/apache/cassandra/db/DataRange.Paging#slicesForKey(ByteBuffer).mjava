        private ColumnSlice[] slicesForKey(ByteBuffer key)
        {
            // We don't call that until it's necessary, so assume we have to do some hard work
            Composite newStart = equals(startKey(), key) ? columnStart : null;
            Composite newFinish = equals(stopKey(), key) ? columnFinish : null;

            List<ColumnSlice> newSlices = new ArrayList<ColumnSlice>(sliceFilter.slices.length); // in the common case, we'll have the same number of slices

            for (ColumnSlice slice : sliceFilter.slices)
            {
                if (newStart != null)
                {
                    if (slice.isBefore(comparator, newStart))
                        continue; // we skip that slice

                    if (slice.includes(comparator, newStart))
                        slice = new ColumnSlice(newStart, slice.finish);

                    // Whether we've updated the slice or not, we don't have to bother about newStart anymore
                    newStart = null;
                }

                assert newStart == null;
                if (newFinish != null && !slice.isBefore(comparator, newFinish))
                {
                    if (slice.includes(comparator, newFinish))
                        newSlices.add(new ColumnSlice(slice.start, newFinish));
                    // In any case, we're done
                    break;
                }
                newSlices.add(slice);
            }

            return newSlices.toArray(new ColumnSlice[newSlices.size()]);
        }

