    @Override
    public SortedSet<Slice.Bound> boundsAsClustering(Bound bound, QueryOptions options) throws InvalidRequestException
    {
        MultiCBuilder builder = MultiCBuilder.create(comparator);
        int keyPosition = 0;
        for (Restriction r : restrictions)
        {
            ColumnDefinition def = r.getFirstColumn();

            // The bound of this method is refering to the clustering order. So if said clustering order
            // is reversed for this column, we should reverse the restriction we use.
            Bound b = !def.isReversedType() ? bound : bound.reverse();
            if (keyPosition != def.position() || r.isContains())
                break;

            if (r.isSlice())
            {
                if (!r.hasBound(b))
                {
                    // There wasn't any non EQ relation on that key, we select all records having the preceding component as prefix.
                    // For composites, if there was preceding component and we're computing the end, we must change the last component
                    // End-Of-Component, otherwise we would be selecting only one record.
                    return builder.buildBound(bound.isStart(), true);
                }

                r.appendBoundTo(builder, b, options);
                return builder.buildBound(bound.isStart(), r.isInclusive(b));
            }

            r.appendBoundTo(builder, b, options);

            if (builder.hasMissingElements())
                return FBUtilities.<Slice.Bound>emptySortedSet(comparator);

            keyPosition = r.getLastColumn().position() + 1;
        }

        // Everything was an equal (or there was nothing)
        return builder.buildBound(bound.isStart(), true);
    }

