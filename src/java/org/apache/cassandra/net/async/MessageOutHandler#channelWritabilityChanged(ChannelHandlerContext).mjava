    /**
     * {@inheritDoc}
     *
     * When the channel becomes writable (assuming it was previously unwritable), try to eat through any backlogged messages
     * {@link #backlogSupplier}. As we're on the event loop when this is invoked, no one else can fill up the netty
     * {@link ChannelOutboundBuffer}, so we should be able to make decent progress chewing through the backlog
     * (assuming not large messages). Any messages messages written from {@link OutboundMessagingConnection} threads won't
     * be processed immediately; they'll be queued up as tasks, and once this function return, those messages can begin
     * to be consumed.
     * <p>
     * Note: this is invoked on the netty event loop.
     */
    @Override
    public void channelWritabilityChanged(ChannelHandlerContext ctx)
    {
        if (!ctx.channel().isWritable())
            return;

        // guarantee at least a minimal amount of progress (one messge from the backlog) by using a do-while loop.
        do
        {
            QueuedMessage msg = backlogSupplier.get();
            if (msg == null || !channelWriter.write(msg, false))
                break;
        } while (ctx.channel().isWritable());
    }

