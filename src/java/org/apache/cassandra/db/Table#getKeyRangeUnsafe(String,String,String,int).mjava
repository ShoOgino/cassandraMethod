    private List<String> getKeyRangeUnsafe(final String cfName, final String startWith, final String stopAt, int maxResults) throws IOException, ExecutionException, InterruptedException
    {
        // (OPP key decoration is a no-op so using the "decorated" comparator against raw keys is fine)
        final Comparator<String> comparator = StorageService.getPartitioner().getDecoratedKeyComparator();

        // create a CollatedIterator that will return unique keys from different sources
        // (current memtable, historical memtables, and SSTables) in the correct order.
        List<Iterator<String>> iterators = new ArrayList<Iterator<String>>();
        ColumnFamilyStore cfs = getColumnFamilyStore(cfName);

        // we iterate through memtables with a priority queue to avoid more sorting than necessary.
        // this predicate throws out the keys before the start of our range.
        Predicate p = new Predicate()
        {
            public boolean evaluate(Object key)
            {
                String st = (String)key;
                return comparator.compare(startWith, st) <= 0 && (stopAt.isEmpty() || comparator.compare(st, stopAt) <= 0);
            }
        };

        // current memtable keys.  have to go through the CFS api for locking.
        iterators.add(IteratorUtils.filteredIterator(cfs.memtableKeyIterator(), p));
        // historical memtables
        for (Memtable memtable : ColumnFamilyStore.getUnflushedMemtables(cfName))
        {
            iterators.add(IteratorUtils.filteredIterator(Memtable.getKeyIterator(memtable.getKeys()), p));
        }

        // sstables
        for (SSTableReader sstable : cfs.getSSTables())
        {
            FileStruct fs = sstable.getFileStruct();
            fs.seekTo(startWith);
            iterators.add(fs);
        }

        Iterator<String> collated = IteratorUtils.collatedIterator(comparator, iterators);
        Iterable<String> reduced = new ReducingIterator<String>(collated) {
            String current;

            public void reduce(String current)
            {
                 this.current = current;
            }

            protected String getReduced()
            {
                return current;
            }
        };

        try
        {
            // pull keys out of the CollatedIterator.  checking tombstone status is expensive,
            // so we set an arbitrary limit on how many we'll do at once.
            List<String> keys = new ArrayList<String>();
            for (String current : reduced)
            {
                if (!stopAt.isEmpty() && comparator.compare(stopAt, current) < 0)
                {
                    break;
                }
                // make sure there is actually non-tombstone content associated w/ this key
                // TODO record the key source(s) somehow and only check that source (e.g., memtable or sstable)
                if (ColumnFamilyStore.removeDeleted(cfs.getColumnFamily(new SliceQueryFilter(current, new QueryPath(cfName), "", "", true, 1)), Integer.MAX_VALUE) != null)
                {
                    keys.add(current);
                }
                if (keys.size() >= maxResults)
                {
                    break;
                }
            }
            return keys;
        }
        finally
        {
            for (Iterator iter : iterators)
            {
                if (iter instanceof FileStruct)
                {
                    ((FileStruct)iter).close();
                }
            }
        }
    }

