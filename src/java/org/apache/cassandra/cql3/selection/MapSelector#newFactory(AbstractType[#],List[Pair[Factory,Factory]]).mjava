    public static Factory newFactory(final AbstractType<?> type, final List<Pair<Factory, Factory>> factories)
    {
        return new Factory()
        {
            protected String getColumnName()
            {
                return Maps.mapToString(factories, Factory::getColumnName);
            }

            protected AbstractType<?> getReturnType()
            {
                return type;
            }

            protected final void addColumnMapping(SelectionColumnMapping mapping, ColumnSpecification resultsColumn)
            {
                SelectionColumnMapping tmpMapping = SelectionColumnMapping.newMapping();
                for (Pair<Factory, Factory> entry : factories)
                {
                    entry.left.addColumnMapping(tmpMapping, resultsColumn);
                    entry.right.addColumnMapping(tmpMapping, resultsColumn);
                }

                if (tmpMapping.getMappings().get(resultsColumn).isEmpty())
                    // add a null mapping for cases where the collection is empty
                    mapping.addMapping(resultsColumn, (ColumnDefinition)null);
                else
                    // collate the mapped columns from the child factories & add those
                    mapping.addMapping(resultsColumn, tmpMapping.getMappings().values());
            }

            public Selector newInstance(final QueryOptions options)
            {
                return new MapSelector(type,
                                        factories.stream()
                                                 .map(p -> Pair.create(p.left.newInstance(options),
                                                                       p.right.newInstance(options)))
                                                 .collect(Collectors.toList()));
            }

            @Override
            public boolean isAggregateSelectorFactory()
            {
                for (Pair<Factory, Factory> entry : factories)
                {
                    if (entry.left.isAggregateSelectorFactory() || entry.right.isAggregateSelectorFactory())
                        return true;
                }
                return false;
            }

            @Override
            public void addFunctionsTo(List<Function> functions)
            {
                for (Pair<Factory, Factory> entry : factories)
                {
                    entry.left.addFunctionsTo(functions);
                    entry.right.addFunctionsTo(functions);
                }
            }

            @Override
            public boolean isWritetimeSelectorFactory()
            {
                for (Pair<Factory, Factory> entry : factories)
                {
                    if (entry.left.isWritetimeSelectorFactory() || entry.right.isWritetimeSelectorFactory())
                        return true;
                }
                return false;
            }

            @Override
            public boolean isTTLSelectorFactory()
            {
                for (Pair<Factory, Factory> entry : factories)
                {
                    if (entry.left.isTTLSelectorFactory() || entry.right.isTTLSelectorFactory())
                        return true;
                }
                return false;
            }
        };
    }

