    public ParsedStatement.Prepared prepare(CFDefinition.Name[] boundNames) throws InvalidRequestException
    {
        CFMetaData metadata = ThriftValidation.validateColumnFamily(keyspace(), columnFamily());
        cfDef = metadata.getCfDef();
        UpdateStatement.processKeys(cfDef, whereClause, processedKeys, boundNames);

        for (Selector column : columns)
        {
            CFDefinition.Name name = cfDef.get(column.id());
            if (name == null)
                throw new InvalidRequestException(String.format("Unknown identifier %s", column));

            // For compact, we only have one value except the key, so the only form of DELETE that make sense is without a column
            // list. However, we support having the value name for coherence with the static/sparse case
            if (name.kind != CFDefinition.Name.Kind.COLUMN_METADATA && name.kind != CFDefinition.Name.Kind.VALUE_ALIAS)
                throw new InvalidRequestException(String.format("Invalid identifier %s for deletion (should not be a PRIMARY KEY part)", column));

            if (column.key() != null && !(name.type instanceof ListType || name.type instanceof MapType))
                throw new InvalidRequestException(String.format("Invalid selection %s since %s is neither a list or a map", column, column.id()));

            toRemove.add(Pair.create(name, column.key()));
        }

        return new ParsedStatement.Prepared(this, Arrays.<ColumnSpecification>asList(boundNames));
    }

