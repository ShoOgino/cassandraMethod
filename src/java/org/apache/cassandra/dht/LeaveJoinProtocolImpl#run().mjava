    public void run()
    {  
        try
        {
            if (logger_.isDebugEnabled())
              logger_.debug("Beginning leave/join process for ...");                                                               
            /* copy the token to endpoint map */
            Map<Token, InetAddress> tokenToEndPointMap = tokenMetadata_.cloneTokenEndPointMap();
            /* copy the endpoint to token map */
            Map<InetAddress, Token> endpointToTokenMap = tokenMetadata_.cloneEndPointTokenMap();
            
            Set<Token> oldTokens = new HashSet<Token>( tokenToEndPointMap.keySet() );
            Range[] oldRanges = StorageService.instance().getAllRanges(oldTokens);
            if (logger_.isDebugEnabled())
              logger_.debug("Total number of old ranges " + oldRanges.length);
            /* Calculate the list of nodes that handle the old ranges */
            Map<Range, List<InetAddress>> oldRangeToEndPointMap = StorageService.instance().constructRangeToEndPointMap(oldRanges);
            
            /* Remove the tokens of the nodes leaving the ring */
            Set<Token> tokens = getTokensForLeavingNodes();
            oldTokens.removeAll(tokens);
            Range[] rangesAfterNodesLeave = StorageService.instance().getAllRanges(oldTokens);
            /* Get expanded range to initial range mapping */
            Map<Range, List<Range>> expandedRangeToOldRangeMap = getExpandedRangeToOldRangeMapping(oldRanges, rangesAfterNodesLeave);
            /* add the new token positions to the old tokens set */
            for (Token token : tokens_)
                oldTokens.add(token);
            Range[] rangesAfterNodesJoin = StorageService.instance().getAllRanges(oldTokens);
            /* replace the ranges that were split with the split ranges in the old configuration */
            addSplitRangesToOldConfiguration(oldRangeToEndPointMap, rangesAfterNodesJoin);
            
            /* Re-calculate the new ranges after the new token positions are added */
            Range[] newRanges = StorageService.instance().getAllRanges(oldTokens);
            /* Remove the old locations from tokenToEndPointMap and add the new locations they are moving to */
            for ( int i = 0; i < targets_.length; ++i )
            {
                tokenToEndPointMap.remove( endpointToTokenMap.get(targets_[i]) );
                tokenToEndPointMap.put(tokens_[i], targets_[i]);
            }            
            /* Calculate the list of nodes that handle the new ranges */            
            Map<Range, List<InetAddress>> newRangeToEndPointMap = StorageService.instance().constructRangeToEndPointMap(newRanges, tokenToEndPointMap);
            /* Remove any expanded ranges and replace them with ranges whose aggregate is the expanded range in the new configuration. */
            removeExpandedRangesFromNewConfiguration(newRangeToEndPointMap, expandedRangeToOldRangeMap);
            /* Calculate ranges that need to be sent and from whom to where */
            Map<Range, List<BootstrapSourceTarget>> rangesWithSourceTarget = LeaveJoinProtocolHelper.getRangeSourceTargetInfo(oldRangeToEndPointMap, newRangeToEndPointMap);
            /* For debug purposes only */
            Set<Range> ranges = rangesWithSourceTarget.keySet();
            for ( Range range : ranges )
            {
                System.out.print("RANGE: " + range + ":: ");
                List<BootstrapSourceTarget> infos = rangesWithSourceTarget.get(range);
                for ( BootstrapSourceTarget info : infos )
                {
                    System.out.print(info);
                    System.out.print(" ");
                }
                System.out.println(System.getProperty("line.separator"));
            }
            /* Send messages to respective folks to stream data over to the new nodes being bootstrapped */
            LeaveJoinProtocolHelper.assignWork(rangesWithSourceTarget);
        }
        catch ( Throwable th )
        {
            logger_.warn(LogUtil.throwableToString(th));
        }
    }

