    @Override
    public void applyModels() throws IOException
    {
        if (!clientMode)
            renameKsStorageFiles(oldName, newName);
        
        KSMetaData oldKsm = DatabaseDescriptor.getTableDefinition(oldName);
        for (CFMetaData cfm : oldKsm.cfMetaData().values())
            // remove cf mappings for previous ksname
            CFMetaData.purge(cfm);
        KSMetaData newKsm = oldKsm.withName(newName);
        for (CFMetaData cfm : newKsm.cfMetaData().values())
        {
            try
            {
                CFMetaData.map(cfm);
            }
            catch (ConfigurationException ex)
            {
                // throwing RTE since this this means that the table,cf already maps to a different ID, which it can't
                // since we've already checked for an existing table with the same name.
                throw new RuntimeException(ex);
            }
        }
        // ^^ at this point, the static methods in CFMetaData will start returning references to the new table, so
        // it helps if the node is reasonably quiescent with respect to this ks.
        DatabaseDescriptor.clearTableDefinition(oldKsm, newVersion);
        DatabaseDescriptor.setTableDefinition(newKsm, newVersion);
        
        if (!clientMode)
        {
            Table.clear(oldKsm.name);
            Table.open(newName);
            // this isn't strictly necessary since the set of all cfs was not modified.
            CommitLog.instance().forceNewSegment();
    
            HintedHandOffManager.renameHints(oldName, newName);
        }
    }

