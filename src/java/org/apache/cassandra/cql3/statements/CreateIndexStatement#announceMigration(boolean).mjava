    public boolean announceMigration(boolean isLocalOnly) throws RequestValidationException
    {
        CFMetaData cfm = Schema.instance.getCFMetaData(keyspace(), columnFamily()).copy();
        IndexTarget target = rawTarget.prepare(cfm);

        ColumnDefinition cd = cfm.getColumnDefinition(target.column);
        String acceptedName = indexName;
        if (Strings.isNullOrEmpty(acceptedName))
            acceptedName = Indexes.getAvailableIndexName(keyspace(), columnFamily(), cd.name);

        for (IndexMetadata existing : cfm.getIndexes())
            if (existing.indexedColumn(cfm).equals(cd) || existing.name.equals(acceptedName))
                if (ifNotExists)
                    return false;
                else
                    throw new InvalidRequestException("Index already exists");

        IndexMetadata.IndexType indexType;
        Map<String, String> indexOptions;
        if (properties.isCustom)
        {
            indexType = IndexMetadata.IndexType.CUSTOM;
            indexOptions = properties.getOptions();
        }
        else if (cfm.isCompound())
        {
            Map<String, String> options = Collections.emptyMap();
            // For now, we only allow indexing values for collections, but we could later allow
            // to also index map keys, so we record that this is the values we index to make our
            // lives easier then.
            if (cd.type.isCollection() && cd.type.isMultiCell())
                options = ImmutableMap.of(target.type.indexOption(), "");
            indexType = IndexMetadata.IndexType.COMPOSITES;
            indexOptions = options;
        }
        else
        {
            indexType = IndexMetadata.IndexType.KEYS;
            indexOptions = Collections.emptyMap();
        }



        logger.debug("Updating index definition for {}", indexName);

        IndexMetadata index = IndexMetadata.legacyIndex(cd, acceptedName, indexType, indexOptions);
        cfm.indexes(cfm.getIndexes().with(index));
        MigrationManager.announceColumnFamilyUpdate(cfm, false, isLocalOnly);
        return true;
    }

