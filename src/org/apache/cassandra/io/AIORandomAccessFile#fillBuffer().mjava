    /**
     * Read at most "this.buff.length" bytes into "this.buff", returning the
     * number of bytes read. If the return result is less than
     * "this.buff.length", then EOF was read.
     */
    private int fillBuffer() throws IOException
    {        
        int cnt = 0;        
        ByteBuffer buffer = ByteBuffer.allocate(buffer_.length);                 
        Future<Integer> futurePtr = fileChannel_.read(buffer, this.diskPos_, null, new ReadCompletionHandler());       
                      
        try
        {
            /* 
             * This should block
            */
            cnt = futurePtr.get();
        }
        catch (ExecutionException ex)
        {
            logger_.warn(LogUtil.throwableToString(ex));
        }
        catch (InterruptedException ex)
        {
            logger_.warn(LogUtil.throwableToString(ex));
        }
        
        if ( (cnt < 0) && ( this.hitEOF_ = (cnt < this.buffer_.length) ) ) 
        {
            // make sure buffer that wasn't read is initialized with -1
            if ( cnt < 0 )
                cnt = 0;            
            Arrays.fill(buffer_, cnt, this.buffer_.length, (byte) 0xff);
        }
        else
        {            
            buffer_ = buffer.array();
        }
        this.diskPos_ += cnt;
        return cnt;
    } 

