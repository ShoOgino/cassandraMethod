    // returnCF should already have row-level tombstones applied
    public static void merge(final ColumnFamily returnCF, List<CloseableIterator<Column>> data, final SecondaryIndexManager.Updater indexer)
    {
        IDiskAtomFilter filter = new IdentityQueryFilter();
        Comparator<Column> fcomp = filter.getColumnComparator(returnCF.getComparator());

        MergeIterator.Reducer<Column, Column> reducer = new MergeIterator.Reducer<Column, Column>()
        {
            ColumnFamily container = returnCF.cloneMeShallow();

            public void reduce(Column column)
            {
                container.addColumn(column);

                // skip the index-update checks if there is no indexing needed since they are a bit expensive
                if (indexer == SecondaryIndexManager.nullUpdater)
                    return;

                // notify the index that the column has been overwritten if the value being reduced has been
                // superceded by another directly, or indirectly by a range tombstone
                if ((!column.isMarkedForDelete(System.currentTimeMillis()) && !container.getColumn(column.name()).equals(column))
                    || returnCF.deletionInfo().isDeleted(column.name(), CompactionManager.NO_GC))
                {
                    indexer.remove(column);
                }
            }

            protected Column getReduced()
            {
                Column c = container.iterator().next();
                container.clear();
                return c;
            }
        };

        Iterator<Column> reduced = MergeIterator.get(data, fcomp, reducer);
        filter.collectReducedColumns(returnCF, reduced, CompactionManager.NO_GC, System.currentTimeMillis());
    }

