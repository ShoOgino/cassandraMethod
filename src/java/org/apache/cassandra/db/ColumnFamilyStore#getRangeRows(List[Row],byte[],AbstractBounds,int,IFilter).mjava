    /**
      * Fetch a range of rows and columns from memtables/sstables.
      * 
      * @param rows The resulting rows fetched during this operation 
      * @param superColumn Super column to filter by
      * @param range Either a Bounds, which includes start key, or a Range, which does not.
      * @param maxResults Maximum rows to return
      * @param columnFilter description of the columns we're interested in for each row
      * @return true if we found all keys we were looking for, otherwise false
     */
    private void getRangeRows(List<Row> rows, byte[] superColumn, final AbstractBounds range, int maxResults, IFilter columnFilter)
    throws ExecutionException, InterruptedException
    {
        final DecoratedKey startWith = new DecoratedKey(range.left, (byte[])null);
        final DecoratedKey stopAt = new DecoratedKey(range.right, (byte[])null);
        
        final int gcBefore = CompactionManager.getDefaultGCBefore();

        final QueryPath queryPath =  new QueryPath(columnFamily_, superColumn, null);

        final QueryFilter filter = new QueryFilter(null, queryPath, columnFilter);
        Collection<Memtable> memtables = new ArrayList<Memtable>();
        memtables.add(getMemtableThreadSafe());
        memtables.addAll(memtablesPendingFlush);

        Collection<SSTableReader> sstables = new ArrayList<SSTableReader>();
        Iterables.addAll(sstables, ssTables_);

        RowIterator iterator = RowIteratorFactory.getIterator(memtables, sstables, startWith, stopAt, filter, getComparator(), this, gcBefore);

        try
        {
            // pull rows out of the iterator
            boolean first = true; 
            while(iterator.hasNext())
            {
                Row current = iterator.next();
                DecoratedKey key = current.key;

                if (!stopAt.isEmpty() && stopAt.compareTo(key) < 0)
                    return;

                // skip first one
                if(range instanceof Bounds || !first || !key.equals(startWith))
                {
                    rows.add(current);
                    if (logger_.isDebugEnabled())
                        logger_.debug("scanned " + key);
                }
                first = false;

                if (rows.size() >= maxResults)
                    return;
            }
        }
        finally
        {
            try
            {
                iterator.close();
            }
            catch (IOException e)
            {
                throw new IOError(e);
            }
        }
    }

