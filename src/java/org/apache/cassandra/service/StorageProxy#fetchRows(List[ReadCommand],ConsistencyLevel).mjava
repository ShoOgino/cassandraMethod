    /**
     * This function executes local and remote reads, and blocks for the results:
     *
     * 1. Get the replica locations, sorted by response time according to the snitch
     * 2. Send a data request to the closest replica, and digest requests to either
     *    a) all the replicas, if read repair is enabled
     *    b) the closest R-1 replicas, where R is the number required to satisfy the ConsistencyLevel
     * 3. Wait for a response from R replicas
     * 4. If the digests (if any) match the data return the data
     * 5. else carry out read repair by getting data from all the nodes.
     */
    private static List<Row> fetchRows(List<ReadCommand> commands, ConsistencyLevel consistency_level) throws IOException, UnavailableException, TimeoutException
    {
        List<ReadCallback<Row>> readCallbacks = new ArrayList<ReadCallback<Row>>();
        List<Row> rows = new ArrayList<Row>();
        List<ReadCommand> commandsToRetry = Collections.emptyList();
        List<ReadCommand> repairCommands = Collections.emptyList();

        do
        {
            readCallbacks.clear();
            List<ReadCommand> commandsToSend = commandsToRetry.isEmpty() ? commands : commandsToRetry;

            if (!commandsToRetry.isEmpty())
                logger.debug("Retrying {} commands", commandsToRetry.size());

            // send out read requests
            for (ReadCommand command : commandsToSend)
            {
                assert !command.isDigestQuery();
                logger.debug("Command/ConsistencyLevel is {}/{}", command, consistency_level);

                List<InetAddress> endpoints = StorageService.instance.getLiveNaturalEndpoints(command.table,
                                                                                              command.key);
                DatabaseDescriptor.getEndpointSnitch().sortByProximity(FBUtilities.getBroadcastAddress(), endpoints);

                RowDigestResolver resolver = new RowDigestResolver(command.table, command.key);
                ReadCallback<Row> handler = getReadCallback(resolver, command, consistency_level, endpoints);
                handler.assureSufficientLiveNodes();
                assert !handler.endpoints.isEmpty();
                readCallbacks.add(handler);

                // The data-request message is sent to dataPoint, the node that will actually get the data for us
                InetAddress dataPoint = handler.endpoints.get(0);
                if (dataPoint.equals(FBUtilities.getBroadcastAddress()))
                {
                    logger.debug("reading data locally");
                    StageManager.getStage(Stage.READ).execute(new LocalReadRunnable(command, handler));
                }
                else
                {
                    logger.debug("reading data from {}", dataPoint);
                    MessagingService.instance().sendRR(command, dataPoint, handler);
                }

                if (handler.endpoints.size() == 1)
                    continue;

                // send the other endpoints a digest request
                ReadCommand digestCommand = command.copy();
                digestCommand.setDigestQuery(true);
                MessageProducer producer = null;
                for (InetAddress digestPoint : handler.endpoints.subList(1, handler.endpoints.size()))
                {
                    if (digestPoint.equals(FBUtilities.getBroadcastAddress()))
                    {
                        logger.debug("reading digest locally");
                        StageManager.getStage(Stage.READ).execute(new LocalReadRunnable(digestCommand, handler));
                    }
                    else
                    {
                        logger.debug("reading digest from {}", digestPoint);
                        // (We lazy-construct the digest Message object since it may not be necessary if we
                        // are doing a local digest read, or no digest reads at all.)
                        if (producer == null)
                            producer = new CachingMessageProducer(digestCommand);
                        MessagingService.instance().sendRR(producer, digestPoint, handler);
                    }
                }
            }

            if (repairCommands != Collections.EMPTY_LIST)
                repairCommands.clear();

            // read results and make a second pass for any digest mismatches
            List<RepairCallback> repairResponseHandlers = null;
            for (int i = 0; i < commandsToSend.size(); i++)
            {
                ReadCallback<Row> handler = readCallbacks.get(i);
                ReadCommand command = commandsToSend.get(i);
                try
                {
                    long startTime2 = System.currentTimeMillis();
                    Row row = handler.get();
                    if (row != null)
                        rows.add(row);

                    if (logger.isDebugEnabled())
                        logger.debug("Read: " + (System.currentTimeMillis() - startTime2) + " ms.");
                }
                catch (TimeoutException ex)
                {
                    if (logger.isDebugEnabled())
                        logger.debug("Read timeout: {}", ex.toString());
                    throw ex;
                }
                catch (DigestMismatchException ex)
                {
                    if (logger.isDebugEnabled())
                        logger.debug("Digest mismatch: {}", ex.toString());
                    RowRepairResolver resolver = new RowRepairResolver(command.table, command.key);
                    RepairCallback repairHandler = new RepairCallback(resolver, handler.endpoints);

                    if (repairCommands == Collections.EMPTY_LIST)
                        repairCommands = new ArrayList<ReadCommand>();
                    repairCommands.add(command);

                    MessageProducer producer = new CachingMessageProducer(command);
                    for (InetAddress endpoint : handler.endpoints)
                        MessagingService.instance().sendRR(producer, endpoint, repairHandler);

                    if (repairResponseHandlers == null)
                        repairResponseHandlers = new ArrayList<RepairCallback>();
                    repairResponseHandlers.add(repairHandler);
                }
            }

            if (commandsToRetry != Collections.EMPTY_LIST)
                commandsToRetry.clear();

            // read the results for the digest mismatch retries
            if (repairResponseHandlers != null)
            {
                for (int i = 0; i < repairCommands.size(); i++)
                {
                    ReadCommand command = repairCommands.get(i);
                    RepairCallback handler = repairResponseHandlers.get(i);
                    FBUtilities.waitOnFutures(handler.resolver.repairResults, DatabaseDescriptor.getRpcTimeout());

                    Row row;
                    try
                    {
                        row = handler.get();
                    }
                    catch (DigestMismatchException e)
                    {
                        throw new AssertionError(e); // full data requested from each node here, no digests should be sent
                    }

                    // retry short reads, otherwise add the row to our resultset
                    if (command instanceof SliceFromReadCommand)
                    {
                        // short reads are only possible on SliceFromReadCommand
                        SliceFromReadCommand sliceCommand = (SliceFromReadCommand) command;
                        int maxLiveColumns = handler.getMaxLiveColumns();
                        int liveColumnsInRow = row != null ? row.cf.getLiveColumnCount() : 0;

                        assert maxLiveColumns <= sliceCommand.count;
                        if ((maxLiveColumns == sliceCommand.count) && (liveColumnsInRow < sliceCommand.count))
                        {
                            logger.debug("detected short read: expected {} columns, but only resolved {} columns",
                                         sliceCommand.count, liveColumnsInRow);

                            int retryCount = sliceCommand.count + sliceCommand.count - liveColumnsInRow;
                            SliceFromReadCommand retryCommand = new SliceFromReadCommand(command.table,
                                                                                         command.key,
                                                                                         command.queryPath,
                                                                                         sliceCommand.start,
                                                                                         sliceCommand.finish,
                                                                                         sliceCommand.reversed,
                                                                                         retryCount);
                            if (commandsToRetry == Collections.EMPTY_LIST)
                                commandsToRetry = new ArrayList<ReadCommand>();
                            commandsToRetry.add(retryCommand);
                            continue;
                        }
                    }
                    rows.add(row);
                }
            }
        } while (!commandsToRetry.isEmpty());

        return rows;
    }

