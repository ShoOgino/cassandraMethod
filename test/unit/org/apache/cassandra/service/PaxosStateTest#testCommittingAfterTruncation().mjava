    @Test
    public void testCommittingAfterTruncation() throws Exception
    {
        ColumnFamilyStore cfs = Keyspace.open("Keyspace1").getColumnFamilyStore("Standard1");
        DecoratedKey key = Util.dk("key" + System.nanoTime());
        ByteBuffer name = ByteBufferUtil.bytes("col");
        ByteBuffer value = ByteBufferUtil.bytes(0);
        ColumnFamily update = ArrayBackedSortedColumns.factory.create(cfs.metadata);
        update.addColumn(name, value, FBUtilities.timestampMicros());

        // CFS should be empty initially
        assertNoDataPresent(cfs, key);

        // Commit the proposal & verify the data is present
        Commit beforeTruncate = newProposal(0, key.key, update);
        PaxosState.commit(beforeTruncate);
        assertDataPresent(cfs, key, name, value);

        // Truncate then attempt to commit again, mutation should
        // be ignored as the proposal predates the truncation
        cfs.truncateBlocking();
        PaxosState.commit(beforeTruncate);
        assertNoDataPresent(cfs, key);

        // Now try again with a ballot created after the truncation
        long timestamp = SystemKeyspace.getTruncatedAt(update.metadata().cfId) + 1;
        Commit afterTruncate = newProposal(timestamp, key.key, update);
        PaxosState.commit(afterTruncate);
        assertDataPresent(cfs, key, name, value);
    }

