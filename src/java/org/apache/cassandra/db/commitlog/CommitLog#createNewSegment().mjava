    private void createNewSegment() throws IOException
    {
        assert !segments.isEmpty();
        sync();
        segments.getLast().close();
        segments.add(new CommitLogSegment());

        // Maintain desired CL size cap
        if (getSize() >= DatabaseDescriptor.getTotalCommitlogSpaceInMB() * 1024 * 1024)
        {
            // Force a flush on all CFs keeping the oldest segment from being removed
            CommitLogSegment oldestSegment = segments.peek();
            assert oldestSegment != null; // has to be at least the one we just added
            for (Integer dirtyCFId : oldestSegment.cfLastWrite.keySet())
            {
                String keypace = Schema.instance.getCF(dirtyCFId).left;
                final ColumnFamilyStore cfs = Table.open(keypace).getColumnFamilyStore(dirtyCFId);
                // flush shouldn't run on the commitlog executor, since it acquires Table.switchLock,
                // which may already be held by a thread waiting for the CL executor (via getContext),
                // causing deadlock
                Runnable runnable = new Runnable()
                {
                    public void run()
                    {
                        cfs.forceFlush();
                    }
                };
                StorageService.optionalTasks.execute(runnable);
            }
        }
    }

