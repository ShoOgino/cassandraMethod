    public void validate(ClientState state) throws RequestValidationException
    {
        CFMetaData cfm = ThriftValidation.validateColumnFamily(keyspace(), columnFamily());
        if (cfm.isCounter())
            throw new InvalidRequestException("Secondary indexes are not supported on counter tables");

        ColumnDefinition cd = cfm.getColumnDefinition(target.column);

        if (cd == null)
            throw new InvalidRequestException("No column definition found for column " + target.column);

        boolean isMap = cd.type instanceof MapType;
        if (target.isCollectionKeys && !isMap)
            throw new InvalidRequestException("Cannot create index on keys of column " + target + " with non map type");

        if (cd.getIndexType() != null)
        {
            boolean previousIsKeys = cd.getIndexOptions().containsKey("index_keys");
            if (isMap && target.isCollectionKeys != previousIsKeys)
            {
                String msg = "Cannot create index on %s %s, an index on %s %s already exists and indexing "
                           + "a map on both keys and values at the same time is not currently supported";
                throw new InvalidRequestException(String.format(msg,
                                                                target.column, target.isCollectionKeys ? "keys" : "values",
                                                                target.column, previousIsKeys ? "keys" : "values"));
            }

            if (ifNotExists)
                return;
            else
                throw new InvalidRequestException("Index already exists");
        }

        properties.validate();

        // TODO: we could lift that limitation
        if (cfm.comparator.isDense() && cd.kind != ColumnDefinition.Kind.REGULAR)
            throw new InvalidRequestException(String.format("Secondary index on %s column %s is not yet supported for compact table", cd.kind, target.column));

        // It would be possible to support 2ndary index on static columns (but not without modifications of at least ExtendedFilter and
        // CompositesIndex) and maybe we should, but that means a query like:
        //     SELECT * FROM foo WHERE static_column = 'bar'
        // would pull the full partition every time the static column of partition is 'bar', which sounds like offering a
        // fair potential for foot-shooting, so I prefer leaving that to a follow up ticket once we have identified cases where
        // such indexing is actually useful.
        if (cd.isStatic())
            throw new InvalidRequestException("Secondary indexes are not allowed on static columns");

        if (cd.kind == ColumnDefinition.Kind.PARTITION_KEY && cd.isOnAllComponents())
            throw new InvalidRequestException(String.format("Cannot add secondary index to already primarily indexed column %s", target.column));
    }

