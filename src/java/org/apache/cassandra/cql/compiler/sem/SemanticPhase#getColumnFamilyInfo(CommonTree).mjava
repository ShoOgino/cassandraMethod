    /** 
     * Given a CommonTree AST node of type, A_COLUMN_ACCESS related functions, do semantic
     * checking to ensure table name, column family name, and number of key dimensions
     * specified are all valid. 
     */
    private static CFMetaData getColumnFamilyInfo(CommonTree ast) throws SemanticException
    {
        assert(ast.getType() == CqlParser.A_COLUMN_ACCESS);

        CommonTree columnFamilyNode = (CommonTree)(ast.getChild(1)); 
        CommonTree tableNode = (CommonTree)(ast.getChild(0));

        String columnFamily = columnFamilyNode.getText();
        String table = tableNode.getText();

        Map<String, CFMetaData> columnFamilies = DatabaseDescriptor.getTableMetaData(table);
        if (columnFamilies == null)
        {
            throw new SemanticException(CompilerErrorMsg.INVALID_TABLE.getMsg(ast, table));
        }

        CFMetaData cfMetaData = columnFamilies.get(columnFamily);
        if (cfMetaData == null)
        {
            throw new SemanticException(CompilerErrorMsg.INVALID_COLUMN_FAMILY.getMsg(ast, columnFamily, table));
        }

        // Once you have drilled down to a row using a rowKey, a super column
        // map can be indexed only 2 further levels deep; and a column map may
        // be indexed up to 1 level deep.
        int dimensions = numColumnDimensions(ast);
        if (("Super".equals(cfMetaData.columnType) && (dimensions > 2)) ||
            ("Standard".equals(cfMetaData.columnType) && dimensions > 1))
        {
            throw new SemanticException(CompilerErrorMsg.TOO_MANY_DIMENSIONS.getMsg(ast, cfMetaData.columnType));
        }

        return cfMetaData; 
    }

