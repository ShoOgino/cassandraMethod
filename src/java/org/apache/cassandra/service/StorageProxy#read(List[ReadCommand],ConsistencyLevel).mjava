    /**
     * Performs the actual reading of a row out of the StorageService, fetching
     * a specific set of column names from a given column family.
     */
    public static List<Row> read(List<ReadCommand> commands, ConsistencyLevel consistency_level)
    throws UnavailableException, IsBootstrappingException, ReadTimeoutException, InvalidRequestException, WriteTimeoutException
    {
        if (StorageService.instance.isBootstrapMode() && !systemTableQuery(commands))
        {
            readMetrics.unavailables.mark();
            ClientRequestMetrics.readUnavailables.inc();
            throw new IsBootstrappingException();
        }

        long startTime = System.nanoTime();
        List<Row> rows = null;
        try
        {
            if (consistency_level == ConsistencyLevel.SERIAL)
            {
                // make sure any in-progress paxos writes are done (i.e., committed to a majority of replicas), before performing a quorum read
                if (commands.size() > 1)
                    throw new InvalidRequestException("SERIAL consistency may only be requested for one row at a time");

                ReadCommand command = commands.get(0);
                CFMetaData metadata = Schema.instance.getCFMetaData(command.table, command.cfName);

                long timedOut = System.currentTimeMillis() + DatabaseDescriptor.getCasContentionTimeout();
                while (true)
                {
                    Pair<List<InetAddress>, Integer> p = getPaxosParticipants(command.table, command.key);
                    List<InetAddress> liveEndpoints = p.left;
                    int requiredParticipants = p.right;

                    if (beginAndRepairPaxos(command.key, metadata, liveEndpoints, requiredParticipants) != null)
                        break;

                    if (System.currentTimeMillis() >= timedOut)
                        throw new WriteTimeoutException(WriteType.CAS, ConsistencyLevel.SERIAL, -1, -1);
                }

                rows = fetchRows(commands, ConsistencyLevel.QUORUM);
            }
            else
            {
                rows = fetchRows(commands, consistency_level);
            }
        }
        catch (UnavailableException e)
        {
            readMetrics.unavailables.mark();
            ClientRequestMetrics.readUnavailables.inc();
            throw e;
        }
        catch (ReadTimeoutException e)
        {
            readMetrics.timeouts.mark();
            ClientRequestMetrics.readTimeouts.inc();
            throw e;
        }
        finally
        {
            readMetrics.addNano(System.nanoTime() - startTime);
        }
        return rows;
    }

