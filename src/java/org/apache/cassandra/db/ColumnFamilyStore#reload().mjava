    public void reload()
    {
        assert Table.flusherLock.writeLock().isHeldByCurrentThread();
        
        // metadata object has been mutated directly. make all the members jibe with new settings.
        
        // only update these runtime-modifiable settings if they have not been modified.
        if (!minCompactionThreshold.isModified())
            minCompactionThreshold = new DefaultInteger(metadata.getMinCompactionThreshold());
        if (!maxCompactionThreshold.isModified())
            maxCompactionThreshold = new DefaultInteger(metadata.getMaxCompactionThreshold());
        if (!memtime.isModified())
            memtime = new DefaultInteger(metadata.getMemtableFlushAfterMins());
        if (!memsize.isModified())
            memsize = new DefaultInteger(metadata.getMemtableThroughputInMb());
        if (!memops.isModified())
            memops = new DefaultDouble(metadata.getMemtableOperationsInMillions());
        
        // reset the memtable with new settings.
        try
        {
            forceBlockingFlush();
        }
        catch (InterruptedException ex)
        {
            throw new RuntimeException(ex);
        }
        catch (ExecutionException ex)
        {
            throw new IOError(ex.getCause());
        }
        
        // todo: update cache sizes, etc. see SSTableTracker
        
        // drop indexes no longer needed
        Set<ByteBuffer> indexesToDrop = new HashSet<ByteBuffer>();
        for (ByteBuffer indexName : indexedColumns.keySet())
               if (!metadata.getColumn_metadata().containsKey(indexName))
                   indexesToDrop.add(indexName);
        for (ByteBuffer indexName : indexesToDrop)
        {
            ColumnFamilyStore indexCfs = indexedColumns.remove(indexName);
            assert indexCfs != null;
            SystemTable.setIndexRemoved(metadata.tableName, metadata.cfName);
            indexCfs.removeAllSSTables();
        }
        
        // there isn't a valid way to update existing indexes at this point (nothing you can change),
        // so don't bother with them.
        
        // add indexes that are new
        for (Map.Entry<ByteBuffer, ColumnDefinition> entry : metadata.getColumn_metadata().entrySet())
            if (!indexedColumns.containsKey(entry.getKey()) && entry.getValue().index_type != null)
                addIndex(entry.getValue());
    }

