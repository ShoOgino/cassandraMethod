        public OnDiskAtom next()
        {
            try
            {
                if (subColumnsIterator != null && subColumnsIterator.hasNext())
                {
                    Cell c = subColumnsIterator.next();
                    return c.withUpdatedName(type.makeCellName(scName, c.name().toByteBuffer()));
                }

                // Read one more super column
                ++read;

                scName = ByteBufferUtil.readWithShortLength(in);
                DeletionInfo delInfo = new DeletionInfo(DeletionTime.serializer.deserialize(in));

                /* read the number of columns */
                int size = in.readInt();
                List<Cell> subCells = new ArrayList<>(size);

                ColumnSerializer colSer = subType(type).columnSerializer();
                for (int i = 0; i < size; ++i)
                    subCells.add(colSer.deserialize(in, flag, expireBefore));

                subColumnsIterator = subCells.iterator();

                // If the SC was deleted, return that first, otherwise return the first subcolumn
                DeletionTime dtime = delInfo.getTopLevelDeletion();
                if (!dtime.equals(DeletionTime.LIVE))
                    return new RangeTombstone(startOf(scName), endOf(scName), dtime);

                return next();
            }
            catch (IOException e)
            {
                throw new IOError(e);
            }
        }

