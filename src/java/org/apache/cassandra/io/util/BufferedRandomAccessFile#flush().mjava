    /**
     * If we are dirty, flush dirty contents to the operating system. Does not imply fsync().
     *
     * Currently, for implementation reasons, this also invalidates the buffer.
     */
    public void flush() throws IOException
    {
        if (isDirty)
        {
            if (channel.position() != bufferOffset)
                channel.position(bufferOffset);

            super.write(buffer, 0, validBufferBytes);

            if (skipCache)
            {

                // we don't know when the data reaches disk since we aren't
                // calling flush
                // so we continue to clear pages we don't need from the first
                // offset we see
                // periodically we update this starting offset
                bytesSinceCacheFlush += validBufferBytes;

                if (bufferOffset < minBufferOffset)
                    minBufferOffset = bufferOffset;

                if (bytesSinceCacheFlush >= MAX_BYTES_IN_PAGE_CACHE)
                {
                    CLibrary.trySkipCache(this.fd, (int) minBufferOffset, 0);
                    minBufferOffset = bufferOffset;
                    bytesSinceCacheFlush = 0;
                }

            }

            // Remember that we wrote, so we don't write it again on next flush().
            resetBuffer();

            isDirty = false;
        }
    }

