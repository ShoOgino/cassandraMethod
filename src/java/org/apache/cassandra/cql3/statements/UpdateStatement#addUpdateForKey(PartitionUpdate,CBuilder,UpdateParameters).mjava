    public void addUpdateForKey(PartitionUpdate update, CBuilder cbuilder, UpdateParameters params)
    throws InvalidRequestException
    {
        params.newPartition(update.partitionKey());

        if (updatesRegularRows())
        {
            Clustering clustering = cbuilder.build();
            Row.Writer writer = update.writer();
            params.writeClustering(clustering, writer);


            // We update the row timestamp (ex-row marker) only on INSERT (#6782)
            // Further, COMPACT tables semantic differs from "CQL3" ones in that a row exists only if it has
            // a non-null column, so we don't want to set the row timestamp for them.
            if (type == StatementType.INSERT && cfm.isCQLTable())
                params.writePartitionKeyLivenessInfo(writer);

            List<Operation> updates = getRegularOperations();

            // For compact tablw, when we translate it to thrift, we don't have a row marker. So we don't accept an insert/update
            // that only sets the PK unless the is no declared non-PK columns (in the latter we just set the value empty).

            // For a dense layout, when we translate it to thrift, we don't have a row marker. So we don't accept an insert/update
            // that only sets the PK unless the is no declared non-PK columns (which we recognize because in that case the compact
            // value is of type "EmptyType").
            if (cfm.isCompactTable() && updates.isEmpty())
            {
                if (CompactTables.hasEmptyCompactValue(cfm))
                    updates = Collections.<Operation>singletonList(new Constants.Setter(cfm.compactValueColumn(), EMPTY));
                else
                    throw new InvalidRequestException(String.format("Column %s is mandatory for this COMPACT STORAGE table", cfm.compactValueColumn().name));
            }

            for (Operation op : updates)
                op.execute(update.partitionKey(), clustering, writer, params);

            writer.endOfRow();
        }

        if (updatesStaticRow())
        {
            Row.Writer writer = update.staticWriter();
            for (Operation op : getStaticOperations())
                op.execute(update.partitionKey(), Clustering.STATIC_CLUSTERING, writer, params);
            writer.endOfRow();
        }
    }

