    /**
     * This is only called by Memtable.resolve, so only AtomicBTreeColumns needs to implement it.
     *
     * @return the difference in size seen after merging the given columns
     */
    public Delta addAllWithSizeDelta(final ColumnFamily cm, AbstractAllocator allocator, Function<Cell, Cell> transformation, Updater indexer, Delta delta)
    {
        boolean transformed = false;
        Collection<Cell> insert;
        if (cm instanceof UnsortedColumns)
        {
            insert = transform(metadata.comparator.columnComparator(), cm, transformation, true);
            transformed = true;
        }
        else
            insert = cm.getSortedColumns();

        while (true)
        {
            Holder current = ref;

            delta.reset();
            DeletionInfo deletionInfo = cm.deletionInfo();
            if (deletionInfo.mayModify(current.deletionInfo))
            {
                if (deletionInfo.hasRanges())
                {
                    for (Iterator<Cell> iter : new Iterator[] { insert.iterator(), BTree.<Cell>slice(current.tree, true) })
                    {
                        while (iter.hasNext())
                        {
                            Cell col = iter.next();
                            if (deletionInfo.isDeleted(col))
                                indexer.remove(col);
                        }
                    }
                }

                deletionInfo = current.deletionInfo.copy().add(deletionInfo);
                delta.addHeapSize(deletionInfo.unsharedHeapSize() - current.deletionInfo.unsharedHeapSize());
            }

            ColumnUpdater updater = new ColumnUpdater(this, current, allocator, transformation, indexer, delta);
            Object[] tree = BTree.update(current.tree, metadata.comparator.columnComparator(), insert, true, updater);

            if (tree != null && refUpdater.compareAndSet(this, current, new Holder(tree, deletionInfo)))
            {
                indexer.updateRowLevelIndexes();
                return updater.delta;
            }

            if (!transformed)
            {
                // After failing once, transform Columns into a new collection to avoid repeatedly allocating Slab space
                insert = transform(metadata.comparator.columnComparator(), cm, transformation, false);
                transformed = true;
            }
        }

    }

