    @Test
    public void testMergeAndAdd()
    {
        ColumnFamily cf_new = ColumnFamily.create("Keyspace1", "Standard1");
        ColumnFamily cf_old = ColumnFamily.create("Keyspace1", "Standard1");
        ColumnFamily cf_result = ColumnFamily.create("Keyspace1", "Standard1");
        byte val[] = "sample value".getBytes();
        byte val2[] = "x value ".getBytes();

        // exercise addColumn(QueryPath, ...)
        cf_new.addColumn(QueryPath.column("col1".getBytes()), val, new TimestampClock(3));
        cf_new.addColumn(QueryPath.column("col2".getBytes()), val, new TimestampClock(4));

        cf_old.addColumn(QueryPath.column("col2".getBytes()), val2, new TimestampClock(1));
        cf_old.addColumn(QueryPath.column("col3".getBytes()), val2, new TimestampClock(2));

        cf_result.addAll(cf_new);
        cf_result.addAll(cf_old);

        assert 3 == cf_result.getColumnCount() : "Count is " + cf_new.getColumnCount();
        //addcolumns will only add if timestamp >= old timestamp
        assert Arrays.equals(val, cf_result.getColumn("col2".getBytes()).value());

        // check that tombstone wins timestamp ties
        cf_result.deleteColumn("col1".getBytes(), 0, new TimestampClock(3));
        assert cf_result.getColumn("col1".getBytes()).isMarkedForDelete();
        cf_result.addColumn(QueryPath.column("col1".getBytes()), val2, new TimestampClock(3));
        assert cf_result.getColumn("col1".getBytes()).isMarkedForDelete();

        // check that column value wins timestamp ties in absence of tombstone
        cf_result.addColumn(QueryPath.column("col3".getBytes()), val, new TimestampClock(2));
        assert Arrays.equals(cf_result.getColumn("col3".getBytes()).value(), val2);
        cf_result.addColumn(QueryPath.column("col3".getBytes()), "z".getBytes(), new TimestampClock(2));
        assert Arrays.equals(cf_result.getColumn("col3".getBytes()).value(), "z".getBytes());
    }

