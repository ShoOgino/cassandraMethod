    private static Comparator<CellPath> makeCellPathComparator(Kind kind, AbstractType<?> validator)
    {
        if (kind.isPrimaryKeyKind() || !validator.isCollection() || !validator.isMultiCell())
            return null;

        final CollectionType type = (CollectionType)validator;
        return new Comparator<CellPath>()
        {
            public int compare(CellPath path1, CellPath path2)
            {
                if (path1.size() == 0 || path2.size() == 0)
                {
                    if (path1 == CellPath.BOTTOM)
                        return path2 == CellPath.BOTTOM ? 0 : -1;
                    if (path1 == CellPath.TOP)
                        return path2 == CellPath.TOP ? 0 : 1;
                    return path2 == CellPath.BOTTOM ? 1 : -1;
                }

                // This will get more complicated once we have non-frozen UDT and nested collections
                assert path1.size() == 1 && path2.size() == 1;
                return type.nameComparator().compare(path1.get(0), path2.get(0));
            }
        };
    }

