    private synchronized void build()
    {
        if (isBuilt)
            return;

        if (rows.size() <= 1)
        {
            finishBuild();
            return;
        }

        Comparator<Row> comparator = metadata.comparator.rowComparator();
        // Sort the rows. Because the same row can have been added multiple times, we can still have duplicates after that
        Collections.sort(rows, comparator);

        // Now find the duplicates and merge them together
        int previous = 0; // The last element that was set
        for (int current = 1; current < rows.size(); current++)
        {
            // There is really only 2 possible comparison: < 0 or == 0 since we've sorted already
            Row previousRow = rows.get(previous);
            Row currentRow = rows.get(current);
            int cmp = comparator.compare(previousRow, currentRow);
            if (cmp == 0)
            {
                // current and previous are the same row. Merge current into previous
                // (and so previous + 1 will be "free").
                rows.set(previous, Rows.merge(previousRow, currentRow, createdAtInSec));
            }
            else
            {
                // current != previous, so move current just after previous if needs be
                ++previous;
                if (previous != current)
                    rows.set(previous, currentRow);
            }
        }

        // previous is on the last value to keep
        for (int j = rows.size() - 1; j > previous; j--)
            rows.remove(j);

        finishBuild();
    }

