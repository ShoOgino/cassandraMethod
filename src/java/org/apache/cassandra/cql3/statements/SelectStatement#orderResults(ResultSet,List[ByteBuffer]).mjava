    /**
     * Orders results when multiple keys are selected (using IN)
     */
    private void orderResults(ResultSet cqlRows, List<ByteBuffer> variables) throws InvalidRequestException
    {
        if (cqlRows.size() == 0)
            return;

        /*
         * We need to do post-query ordering in 2 cases:
         *   1) if the last clustering column is restricted by a IN and has no explicit ORDER BY on it.
         *   2) if the partition key is restricted by a IN and there is some ORDER BY values
         */
        boolean needOrderOnPartitionKey = keyIsInRelation && !parameters.orderings.isEmpty();
        if (!needOrderOnLastClustering && !needOrderOnPartitionKey)
            return;

        assert orderingIndexes != null;

        List<Integer> idToSort = new ArrayList<Integer>();
        List<Comparator<ByteBuffer>> sorters = new ArrayList<Comparator<ByteBuffer>>();

        // Note that we add the ORDER BY sorters first as they should prevail over ordering
        // on the last clustering restriction.
        for (ColumnIdentifier identifier : parameters.orderings.keySet())
        {
            ColumnDefinition orderingColumn = cfm.getColumnDefinition(identifier);
            idToSort.add(orderingIndexes.get(orderingColumn.name));
            sorters.add(orderingColumn.type);
        }

        if (needOrderOnLastClustering)
        {
            List<ColumnDefinition> cc = cfm.clusteringColumns();
            idToSort.add(orderingIndexes.get(cc.get(cc.size() - 1).name));
            Restriction last = columnRestrictions[columnRestrictions.length - 1];
            sorters.add(makeComparatorFor(last.values(variables), isReversed));
        }

        Comparator<List<ByteBuffer>> comparator = idToSort.size() == 1
                                                ? new SingleColumnComparator(idToSort.get(0), sorters.get(0))
                                                : new CompositeComparator(sorters, idToSort);
        Collections.sort(cqlRows.rows, comparator);
    }

