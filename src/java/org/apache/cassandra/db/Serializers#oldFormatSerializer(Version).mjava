    private ISerializer<ClusteringPrefix> oldFormatSerializer(Version version)
    {
        return new ISerializer<ClusteringPrefix>()
        {
            List<AbstractType<?>> clusteringTypes = SerializationHeader.makeWithoutStats(metadata).clusteringTypes();

            public void serialize(ClusteringPrefix clustering, DataOutputPlus out) throws IOException
            {
                //we deserialize in the old format and serialize in the new format
                ClusteringPrefix.serializer.serialize(clustering, out,
                                                      version.correspondingMessagingVersion(),
                                                      clusteringTypes);
            }

            @Override
            public void skip(DataInputPlus in) throws IOException
            {
                ByteBufferUtil.skipShortLength(in);
            }

            public ClusteringPrefix deserialize(DataInputPlus in) throws IOException
            {
                // We're reading the old cellname/composite
                ByteBuffer bb = ByteBufferUtil.readWithShortLength(in);
                assert bb.hasRemaining(); // empty cellnames were invalid

                int clusteringSize = metadata.clusteringColumns().size();
                // If the table has no clustering column, then the cellname will just be the "column" name, which we ignore here.
                if (clusteringSize == 0)
                    return Clustering.EMPTY;

                if (!metadata.isCompound())
                    return Clustering.make(bb);

                List<ByteBuffer> components = CompositeType.splitName(bb);
                byte eoc = CompositeType.lastEOC(bb);

                if (eoc == 0 || components.size() >= clusteringSize)
                {
                    // That's a clustering.
                    if (components.size() > clusteringSize)
                        components = components.subList(0, clusteringSize);

                    return Clustering.make(components.toArray(new ByteBuffer[clusteringSize]));
                }
                else
                {
                    // It's a range tombstone bound. It is a start since that's the only part we've ever included
                    // in the index entries.
                    Slice.Bound.Kind boundKind = eoc > 0
                                                 ? Slice.Bound.Kind.EXCL_START_BOUND
                                                 : Slice.Bound.Kind.INCL_START_BOUND;

                    return Slice.Bound.create(boundKind, components.toArray(new ByteBuffer[components.size()]));
                }
            }

            public long serializedSize(ClusteringPrefix clustering)
            {
                return ClusteringPrefix.serializer.serializedSize(clustering, version.correspondingMessagingVersion(),
                                                                  clusteringTypes);
            }
        };
    }

