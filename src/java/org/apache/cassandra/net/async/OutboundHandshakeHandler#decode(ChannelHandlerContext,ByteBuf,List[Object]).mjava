    /**
     * {@inheritDoc}
     *
     * Invoked when we get the response back from the peer, which should contain the second message of the internode messaging handshake.
     * <p>
     * If the peer's protocol version does not equal what we were expecting, immediately close the channel (and socket);
     * do *not* send out the third message of the internode messaging handshake.
     * We will reconnect on the appropriate protocol version.
     */
    @Override
    protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception
    {
        SecondHandshakeMessage msg = SecondHandshakeMessage.maybeDecode(in);
        if (msg == null)
            return;

        logger.trace("received second handshake message from peer {}, msg = {}", connectionId.connectionAddress(), msg);
        final int peerMessagingVersion = msg.messagingVersion;

        // we expected a higher protocol version, but it was actually lower
        if (messagingVersion > peerMessagingVersion)
        {
            logger.trace("peer's max version is {}; will reconnect with that version", peerMessagingVersion);
            try
            {
                if (DatabaseDescriptor.getSeeds().contains(connectionId.remote()))
                    logger.warn("Seed gossip version is {}; will not connect with that version", peerMessagingVersion);
            }
            catch (Throwable e)
            {
                // If invalid yaml has been added to the config since startup, getSeeds() will throw an AssertionError
                // Additionally, third party seed providers may throw exceptions if network is flakey.
                // Regardless of what's thrown, we must catch it, disconnect, and try again
                logger.warn("failed to reread yaml (on trying to connect to a seed): {}", e.getLocalizedMessage());
            }
            ctx.close();
            callback.accept(HandshakeResult.disconnect(peerMessagingVersion));
            return;
        }
        // we anticipate a version that is lower than what peer is actually running
        else if (messagingVersion < peerMessagingVersion && messagingVersion < MessagingService.current_version)
        {
            logger.trace("peer has a higher max version than expected {} (previous value {})", peerMessagingVersion, messagingVersion);
            ctx.close();
            callback.accept(HandshakeResult.disconnect(peerMessagingVersion));
            return;
        }

        try
        {
            ctx.writeAndFlush(new ThirdHandshakeMessage(MessagingService.current_version, connectionId.local()).encode(ctx.alloc()));
            ChannelWriter channelWriter = setupPipeline(ctx.channel(), peerMessagingVersion);
            callback.accept(HandshakeResult.success(channelWriter, peerMessagingVersion));
        }
        catch (Exception e)
        {
            logger.info("failed to finalize internode messaging handshake", e);
            ctx.close();
            callback.accept(HandshakeResult.failed());
        }
    }

