    // TODO: Once we drop support for old (pre-3.0) sstables, we can drop this method and inline the calls to
    // ClusteringPrefix.serializer in IndexHelper directly. At which point this whole class probably becomes
    // unecessary (since IndexInfo.Serializer won't depend on the metadata either).
    public ISerializer<ClusteringPrefix> indexEntryClusteringPrefixSerializer(final Version version, final SerializationHeader header)
    {
        if (!version.storeRows())
        {
            return new ISerializer<ClusteringPrefix>()
            {
                public void serialize(ClusteringPrefix clustering, DataOutputPlus out) throws IOException
                {
                    // We should only use this for reading old sstable, never write new ones.
                    throw new UnsupportedOperationException();
                }

                public ClusteringPrefix deserialize(DataInputPlus in) throws IOException
                {
                    // We're reading the old cellname/composite
                    ByteBuffer bb = ByteBufferUtil.readWithShortLength(in);
                    assert bb.hasRemaining(); // empty cellnames were invalid

                    int clusteringSize = metadata.clusteringColumns().size();
                    // If the table has no clustering column, then the cellname will just be the "column" name, which we ignore here.
                    if (clusteringSize == 0)
                        return Clustering.EMPTY;

                    if (!metadata.isCompound())
                        return new Clustering(bb);

                    List<ByteBuffer> components = CompositeType.splitName(bb);
                    byte eoc = CompositeType.lastEOC(bb);

                    if (eoc == 0 || components.size() >= clusteringSize)
                    {
                        // That's a clustering.
                        if (components.size() > clusteringSize)
                            components = components.subList(0, clusteringSize);

                        return new Clustering(components.toArray(new ByteBuffer[clusteringSize]));
                    }
                    else
                    {
                        // It's a range tombstone bound. It is a start since that's the only part we've ever included
                        // in the index entries.
                        Slice.Bound.Kind boundKind = eoc > 0
                                                   ? Slice.Bound.Kind.EXCL_START_BOUND
                                                   : Slice.Bound.Kind.INCL_START_BOUND;

                        return Slice.Bound.create(boundKind, components.toArray(new ByteBuffer[components.size()]));
                    }
                }

                public long serializedSize(ClusteringPrefix clustering)
                {
                    // We should only use this for reading old sstable, never write new ones.
                    throw new UnsupportedOperationException();
                }
            };
        }

        return new ISerializer<ClusteringPrefix>()
        {
            public void serialize(ClusteringPrefix clustering, DataOutputPlus out) throws IOException
            {
                ClusteringPrefix.serializer.serialize(clustering, out, version.correspondingMessagingVersion(), header.clusteringTypes());
            }

            public ClusteringPrefix deserialize(DataInputPlus in) throws IOException
            {
                return ClusteringPrefix.serializer.deserialize(in, version.correspondingMessagingVersion(), header.clusteringTypes());
            }

            public long serializedSize(ClusteringPrefix clustering)
            {
                return ClusteringPrefix.serializer.serializedSize(clustering, version.correspondingMessagingVersion(), header.clusteringTypes());
            }
        };
    }

