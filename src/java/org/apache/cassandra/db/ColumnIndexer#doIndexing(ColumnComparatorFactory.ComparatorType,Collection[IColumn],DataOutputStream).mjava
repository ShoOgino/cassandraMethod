    /**
     * Given the collection of columns in the Column Family,
     * the name index is generated and written into the provided
     * stream
     * @param columns for whom the name index needs to be generated
     * @param dos stream into which the serialized name index needs
     *            to be written.
     * @throws IOException
     */
    private static void doIndexing(ColumnComparatorFactory.ComparatorType typeInfo, Collection<IColumn> columns, DataOutputStream dos) throws IOException
    {
        /* we are going to write column indexes */
        int numColumns = 0;
        int position = 0;
        int indexSizeInBytes = 0;
        int sizeSummarized = 0;
        
        /*
         * Maintains a list of KeyPositionInfo objects for the columns in this
         * column family. The key is the column name and the position is the
         * relative offset of that column name from the start of the list.
         * We do this so that we don't read all the columns into memory.
        */
        
        List<IndexHelper.ColumnIndexInfo> columnIndexList = new ArrayList<IndexHelper.ColumnIndexInfo>();        
        
        /* column offsets at the right thresholds into the index map. */
        for ( IColumn column : columns )
        {
            /* if we hit the column index size that we have to index after, go ahead and index it */
            if(position - sizeSummarized >= DatabaseDescriptor.getColumnIndexSize())
            {      
                /*
                 * ColumnSort applies only to columns. So in case of 
                 * SuperColumn always use the name indexing scheme for
                 * the SuperColumns. We will fix this later.
                 */
                IndexHelper.ColumnIndexInfo cIndexInfo = getColumnIndexInfo(typeInfo, column);                
                cIndexInfo.position(position);
                cIndexInfo.count(numColumns);                
                columnIndexList.add(cIndexInfo);
                /*
                 * we will be writing this object as a UTF8 string and two ints,
                 * so calculate the size accordingly. Note that we store the string
                 * as UTF-8 encoded, so when we calculate the length, it should be
                 * converted to UTF-8.
                 */
                indexSizeInBytes += cIndexInfo.size();
                sizeSummarized = position;
                numColumns = 0;
            }
            position += column.serializedSize();
            ++numColumns;
        }
        /* write the column index list */
        IndexHelper.serialize(indexSizeInBytes, columnIndexList, dos);
    }

