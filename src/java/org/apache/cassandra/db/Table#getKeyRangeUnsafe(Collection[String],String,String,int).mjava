    private List<String> getKeyRangeUnsafe(final Collection<String> columnFamilyNames, final String startWith, final String stopAt, int maxResults) throws IOException, ExecutionException, InterruptedException
    {
        assert !columnFamilyNames.isEmpty(); // checked by the 'safe' method

        // (OPP key decoration is a no-op so using the "decorated" comparator against raw keys is fine)
        final Comparator<String> comparator = StorageService.getPartitioner().getDecoratedKeyComparator();

        // create a CollatedIterator that will return unique keys from different sources
        // (current memtable, historical memtables, and SSTables) in the correct order.
        List<Iterator<String>> iterators = new ArrayList<Iterator<String>>();
        for (String cfName : columnFamilyNames)
        {
            ColumnFamilyStore cfs = getColumnFamilyStore(cfName);

            // we iterate through memtables with a priorityqueue to avoid more sorting than necessary.
            // this predicate throws out the keys before the start of our range.
            Predicate p = new Predicate()
            {
                public boolean evaluate(Object key)
                {
                    String st = (String)key;
                    return comparator.compare(startWith, st) <= 0 && (stopAt.isEmpty() || comparator.compare(st, stopAt) <= 0);
                }
            };

            // current memtable keys.  have to go through the CFS api for locking.
            iterators.add(IteratorUtils.filteredIterator(cfs.memtableKeyIterator(), p));
            // historical memtables
            for (Memtable memtable : ColumnFamilyStore.getUnflushedMemtables(cfName))
            {
                iterators.add(IteratorUtils.filteredIterator(Memtable.getKeyIterator(memtable.getKeys()), p));
            }

            // sstables
            for (SSTable sstable : cfs.getSSTables())
            {
                FileStruct fs = sstable.getFileStruct();
                fs.seekTo(startWith);
                iterators.add(fs);
            }
        }
        Iterator<String> collated = IteratorUtils.collatedIterator(comparator, iterators);
        Iterable<String> reduced = new ReducingIterator<String>(collated) {
            String current;

            public void reduce(String current)
            {
                 this.current = current;
            }

            protected String getReduced()
            {
                return current;
            }
        };

        try
        {
            // pull keys out of the CollatedIterator.  checking tombstone status is expensive,
            // so we set an arbitrary limit on how many we'll do at once.
            List<String> keys = new ArrayList<String>();
            for (String current : reduced)
            {
                if (!stopAt.isEmpty() && comparator.compare(stopAt, current) < 0)
                {
                    break;
                }
                // make sure there is actually non-tombstone content associated w/ this key
                // TODO record the key source(s) somehow and only check that source (e.g., memtable or sstable)
                for (String cfName : columnFamilyNames)
                {
                    ColumnFamilyStore cfs = getColumnFamilyStore(cfName);
                    ColumnFamily cf = cfs.getColumnFamily(current, cfName, new IdentityFilter(), Integer.MAX_VALUE);
                    if (cf != null && cf.getColumns().size() > 0)
                    {
                        keys.add(current);
                        break;
                    }
                }
                if (keys.size() >= maxResults)
                {
                    break;
                }
            }
            return keys;
        }
        finally
        {
            for (Iterator iter : iterators)
            {
                if (iter instanceof FileStruct)
                {
                    ((FileStruct)iter).close();
                }
            }
        }
    }

