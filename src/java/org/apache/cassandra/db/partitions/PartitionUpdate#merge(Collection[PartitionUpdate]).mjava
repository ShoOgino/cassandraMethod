    /**
     * Merges the provided updates, yielding a new update that incorporates all those updates.
     *
     * @param updates the collection of updates to merge. This shouldn't be empty.
     *
     * @return a partition update that include (merge) all the updates from {@code updates}.
     */
    public static PartitionUpdate merge(Collection<PartitionUpdate> updates)
    {
        assert !updates.isEmpty();
        final int size = updates.size();

        if (size == 1)
            return Iterables.getOnlyElement(updates);

        // Used when merging row to decide of liveness
        int nowInSec = FBUtilities.nowInSeconds();

        PartitionColumns.Builder builder = PartitionColumns.builder();
        DecoratedKey key = null;
        CFMetaData metadata = null;
        MutableDeletionInfo deletion = MutableDeletionInfo.live();
        Row staticRow = Rows.EMPTY_STATIC_ROW;
        List<Iterator<Row>> updateRowIterators = new ArrayList<>(size);
        EncodingStats stats = EncodingStats.NO_STATS;

        for (PartitionUpdate update : updates)
        {
            builder.addAll(update.columns());
            deletion.add(update.deletionInfo());
            if (!update.staticRow().isEmpty())
                staticRow = staticRow == Rows.EMPTY_STATIC_ROW ? update.staticRow() : Rows.merge(staticRow, update.staticRow(), nowInSec);
            updateRowIterators.add(update.iterator());
            stats = stats.mergeWith(update.stats());

            if (key == null)
                key = update.partitionKey();
            else
                assert key.equals(update.partitionKey());

            if (metadata == null)
                metadata = update.metadata();
            else
                assert metadata.cfId.equals(update.metadata().cfId);
        }

        PartitionColumns columns = builder.build();

        final Row.Merger merger = new Row.Merger(size, nowInSec, columns.regulars);

        Iterator<Row> merged = MergeIterator.get(updateRowIterators, metadata.comparator, new MergeIterator.Reducer<Row, Row>()
        {
            @Override
            public boolean trivialReduceIsTrivial()
            {
                return true;
            }

            public void reduce(int idx, Row current)
            {
                merger.add(idx, current);
            }

            protected Row getReduced()
            {
                // Note that while merger.getRow() can theoretically return null, it won't in this case because
                // we don't pass an "activeDeletion".
                return merger.merge(DeletionTime.LIVE);
            }

            @Override
            protected void onKeyChange()
            {
                merger.clear();
            }
        });

        List<Row> rows = new ArrayList<>();
        Iterators.addAll(rows, merged);

        return new PartitionUpdate(metadata, key, columns, staticRow, rows, deletion, stats, true, true);
    }

