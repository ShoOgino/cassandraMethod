    /**
     * This slice reader assumes that slices are sorted correctly, e.g. that for forward lookup slices are in
     * lexicographic order of start elements and that for reverse lookup they are in reverse lexicographic order of
     * finish (reverse start) elements. i.e. forward: [a,b],[d,e],[g,h] reverse: [h,g],[e,d],[b,a]. This reader also
     * assumes that validation has been performed in terms of intervals (no overlapping intervals).
     */
    public IndexedSliceReader(SSTableReader sstable, RowIndexEntry rowEntry, FileDataInput input, ColumnSlice[] slices, boolean reversed)
    {
        this.sstable = sstable;
        this.originalInput = input;
        this.reversed = reversed;
        this.slices = slices;
        this.comparator = sstable.metadata.comparator;

        try
        {
            Descriptor.Version version = sstable.descriptor.version;
            emptyColumnFamily = ColumnFamily.create(sstable.metadata);

            if (version.hasPromotedRowTombstones && !rowEntry.columnsIndex().isEmpty())
            {
                // skip the row header entirely
                indexes = rowEntry.columnsIndex();
                emptyColumnFamily.delete(rowEntry.deletionInfo());
                fetcher = new IndexedBlockFetcher(rowEntry.position);
                return;
            }

            // skip up to bloom filter where things get a bit more interesting
            if (input == null)
            {
                file = sstable.getFileDataInput(rowEntry.position);
            }
            else
            {
                file = input;
                file.seek(rowEntry.position);
            }
            this.sstable.decodeKey(ByteBufferUtil.readWithShortLength(file));
            SSTableReader.readRowSize(file, this.sstable.descriptor);

            // read the row header up to and including the row-level tombstones
            if (version.hasPromotedIndexes)
            {
                indexes = rowEntry.columnsIndex();
                emptyColumnFamily.delete(rowEntry.deletionInfo());
            }
            else
            {
                IndexHelper.skipSSTableBloomFilter(input, version);
                indexes = IndexHelper.deserializeIndex(file);
            }
            emptyColumnFamily.delete(DeletionInfo.serializer().deserializeFromSSTable(file, version));

            if (indexes.isEmpty())
            {
                fetcher = new SimpleBlockFetcher();
            }
            else
            {
                // index offsets changed to be based against the row key start in 1.2
                fetcher = version.hasPromotedIndexes
                        ? new IndexedBlockFetcher(rowEntry.position)
                        : new IndexedBlockFetcher(file.getFilePointer() + 4); // +4 to skip the int column count
            }
        }
        catch (IOException e)
        {
            sstable.markSuspect();
            throw new CorruptSSTableException(e, file.getPath());
        }
    }

