    @Override
    public int compare(AbstractType<?> type, AbstractType<?> otherType)
    {
        if (!type.getClass().equals(otherType.getClass()))
            throw new IllegalArgumentException(String.format("Trying to compare 2 different types: %s and %s",
                                                             type,
                                                             otherType));

        if (type.equals(otherType))
            return 0;

        // The only case where 2 types can differ is if they contains some UDTs and one of them has more
        // fields (due to an ALTER type ADD) than in the other type. In this case we need to pick the type with
        // the bigger amount of fields.
        if (type.isUDT())
            return compareUserType((UserType) type, (UserType) otherType);

        if (type.isTuple())
            return compareTuple((TupleType) type, (TupleType) otherType);

        if (type.isCollection())
            return compareCollectionTypes(type, otherType);

        if (type instanceof CompositeType)
            return compareCompositeTypes((CompositeType) type, (CompositeType) otherType);

        // In theory we should never reach that point but to be on the safe side we allow it.
        return 0;
    }

