    /**
     * Creates an {@code ArrayBackedCachedPartition} holding all the data of the provided iterator.
     *
     * Warning: Note that this method does not close the provided iterator and it is
     * up to the caller to do so.
     *
     * @param iterator the iterator got gather in memory.
     * @param initialRowCapacity sizing hint (in rows) to use for the created partition. It should ideally
     * correspond or be a good estimation of the number or rows in {@code iterator}.
     * @param nowInSec the time of the creation in seconds. This is the time at which {@link #cachedLiveRows} applies.
     * @return the created partition.
     */
    public static ArrayBackedCachedPartition create(UnfilteredRowIterator iterator, int initialRowCapacity, int nowInSec)
    {
        CFMetaData metadata = iterator.metadata();
        boolean reversed = iterator.isReverseOrder();

        List<Row> rows = new ArrayList<>(initialRowCapacity);
        MutableDeletionInfo.Builder deletionBuilder = MutableDeletionInfo.builder(iterator.partitionLevelDeletion(), metadata.comparator, reversed);

        int cachedLiveRows = 0;
        int rowsWithNonExpiringCells = 0;

        int nonTombstoneCellCount = 0;
        int nonExpiringLiveCells = 0;

        while (iterator.hasNext())
        {
            Unfiltered unfiltered = iterator.next();
            if (unfiltered.kind() == Unfiltered.Kind.ROW)
            {
                Row row = (Row)unfiltered;
                rows.add(row);

                // Collect stats
                if (row.hasLiveData(nowInSec))
                    ++cachedLiveRows;

                boolean hasNonExpiringCell = false;
                for (Cell cell : row.cells())
                {
                    if (!cell.isTombstone())
                    {
                        ++nonTombstoneCellCount;
                        if (!cell.isExpiring())
                        {
                            hasNonExpiringCell = true;
                            ++nonExpiringLiveCells;
                        }
                    }
                }

                if (hasNonExpiringCell)
                    ++rowsWithNonExpiringCells;
            }
            else
            {
                deletionBuilder.add((RangeTombstoneMarker)unfiltered);
            }
        }

        if (reversed)
            Collections.reverse(rows);

        return new ArrayBackedCachedPartition(metadata,
                                              iterator.partitionKey(),
                                              iterator.columns(),
                                              iterator.staticRow(),
                                              rows,
                                              deletionBuilder.build(),
                                              iterator.stats(),
                                              nowInSec,
                                              cachedLiveRows,
                                              rowsWithNonExpiringCells,
                                              nonTombstoneCellCount,
                                              nonExpiringLiveCells);
    }

