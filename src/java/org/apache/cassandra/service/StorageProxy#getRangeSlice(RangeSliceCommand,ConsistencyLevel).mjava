    public static List<Row> getRangeSlice(RangeSliceCommand command, ConsistencyLevel consistency_level)
    throws IOException, UnavailableException, TimeoutException
    {
        if (logger.isDebugEnabled())
            logger.debug("Command/ConsistencyLevel is {}/{}", command.toString(), consistency_level);
        long startTime = System.nanoTime();
        List<Row> rows;
        // now scan until we have enough results
        try
        {
            int columnsCount = 0;
            rows = new ArrayList<Row>();
            List<AbstractBounds<RowPosition>> ranges = getRestrictedRanges(command.range);
            
            // get the cardinality of this index based on row count
            // use this info to decide how many scans to do in parallel
            long estimatedKeys = Table.open(command.keyspace).getColumnFamilyStore(command.column_family)
                    .estimateKeys();
            int concurrencyFactor = (int) command.maxResults / ((int) estimatedKeys + 1);

            if (concurrencyFactor <= 0)
                concurrencyFactor = 1;

            if (concurrencyFactor > ranges.size())
                concurrencyFactor = ranges.size();
            
            // parallel scan handlers
            List<ReadCallback<RangeSliceReply, Iterable<Row>>> scanHandlers = new ArrayList<ReadCallback<RangeSliceReply, Iterable<Row>>>(concurrencyFactor);
            
            for (AbstractBounds<RowPosition> range : ranges)
            {
                RangeSliceCommand nodeCmd = new RangeSliceCommand(command.keyspace,
                                                                  command.column_family,
                                                                  command.super_column,
                                                                  command.predicate,
                                                                  range,
                                                                  command.row_filter,
                                                                  command.maxResults,
                                                                  command.maxIsColumns,
                                                                  command.isPaging);

                List<InetAddress> liveEndpoints = StorageService.instance.getLiveNaturalEndpoints(nodeCmd.keyspace, range.right);
                DatabaseDescriptor.getEndpointSnitch().sortByProximity(FBUtilities.getBroadcastAddress(), liveEndpoints);

                if (consistency_level == ConsistencyLevel.ONE && !liveEndpoints.isEmpty() && liveEndpoints.get(0).equals(FBUtilities.getBroadcastAddress()))
                {
                    if (logger.isDebugEnabled())
                        logger.debug("local range slice");

                    try
                    {
                        rows.addAll(RangeSliceVerbHandler.executeLocally(nodeCmd));
                        for (Row row : rows)
                            columnsCount += row.getLiveColumnCount();
                    }
                    catch (ExecutionException e)
                    {
                        throw new RuntimeException(e.getCause());
                    }
                    catch (InterruptedException e)
                    {
                        throw new AssertionError(e);
                    }
                }
                else
                {
                    // collect replies and resolve according to consistency level
                    RangeSliceResponseResolver resolver = new RangeSliceResponseResolver(nodeCmd.keyspace);
                    ReadCallback<RangeSliceReply, Iterable<Row>> handler = getReadCallback(resolver, nodeCmd, consistency_level, liveEndpoints);
                    handler.assureSufficientLiveNodes();
                    resolver.setSources(handler.endpoints);
                    MessageOut<RangeSliceCommand> message = nodeCmd.createMessage();
                    for (InetAddress endpoint : handler.endpoints)
                    {
                        MessagingService.instance().sendRR(message, endpoint, handler);
                        if (logger.isDebugEnabled())
                            logger.debug("reading " + nodeCmd + " from " + endpoint);
                    }

                    scanHandlers.add(handler);
                    if (scanHandlers.size() >= concurrencyFactor)
                    {
                        for (ReadCallback<RangeSliceReply, Iterable<Row>> scanHandler : scanHandlers)
                        {
                            try
                            {
                                for (Row row : scanHandler.get())
                                {
                                    rows.add(row);
                                    columnsCount += row.getLiveColumnCount();
                                    logger.debug("range slices read {}", row.key);
                                }
                                FBUtilities.waitOnFutures(resolver.repairResults, DatabaseDescriptor.getRangeRpcTimeout());
                            }
                            catch (TimeoutException ex)
                            {
                                if (logger.isDebugEnabled())
                                    logger.debug("Range slice timeout: {}", ex.toString());
                                throw ex;
                            }
                            catch (DigestMismatchException e)
                            {
                                throw new AssertionError(e); // no digests in range slices yet
                            }

                            // if we're done, great, otherwise, move to the next range
                            int count = nodeCmd.maxIsColumns ? columnsCount : rows.size();
                            if (count >= nodeCmd.maxResults)
                                break;
                        }
                        scanHandlers.clear(); //go back for more
                    }
                }
            }
        }
        finally
        {
            rangeStats.addNano(System.nanoTime() - startTime);
        }
        return trim(command, rows);
    }

