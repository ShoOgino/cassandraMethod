    public long append(AbstractCompactedRow row) throws IOException
    {
        long currentPosition = beforeAppend(row.key);
        ByteBufferUtil.writeWithShortLength(row.key.key, dataFile.stream);
        long dataStart = dataFile.getFilePointer();
        long dataSize = row.write(dataFile.stream);
        assert dataSize == dataFile.getFilePointer() - (dataStart + 8)
                : "incorrect row data size " + dataSize + " written to " + dataFile.getPath() + "; correct is " + (dataFile.getFilePointer() - (dataStart + 8));
        /*
         * The max timestamp is not always collected here (more precisely, row.maxTimestamp() may return Long.MIN_VALUE),
         * to avoid deserializing an EchoedRow.
         * This is the reason why it is collected first when calling ColumnFamilyStore.createCompactionWriter
         * However, for old sstables without timestamp, we still want to update the timestamp (and we know
         * that in this case we will not use EchoedRow, since CompactionControler.needsDeserialize() will be true).
        */
        sstableMetadataCollector.updateMaxTimestamp(row.maxTimestamp());
        sstableMetadataCollector.addRowSize(dataFile.getFilePointer() - currentPosition);
        sstableMetadataCollector.addColumnCount(row.columnCount());
        afterAppend(row.key, currentPosition);
        return currentPosition;
    }

