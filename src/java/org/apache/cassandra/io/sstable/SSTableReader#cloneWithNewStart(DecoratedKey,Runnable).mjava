    public SSTableReader cloneWithNewStart(DecoratedKey newStart, final Runnable runOnClose)
    {
        synchronized (replaceLock)
        {
            assert replacedBy == null;

            if (newStart.compareTo(this.first) > 0)
            {
                if (newStart.compareTo(this.last) > 0)
                {
                    this.runOnClose = new Runnable()
                    {
                        public void run()
                        {
                            CLibrary.trySkipCache(dfile.path, 0, 0);
                            CLibrary.trySkipCache(ifile.path, 0, 0);
                            runOnClose.run();
                        }
                    };
                }
                else
                {
                    final long dataStart = getPosition(newStart, Operator.GE).position;
                    final long indexStart = getIndexScanPosition(newStart);
                    this.runOnClose = new Runnable()
                    {
                        public void run()
                        {
                            CLibrary.trySkipCache(dfile.path, 0, dataStart);
                            CLibrary.trySkipCache(ifile.path, 0, indexStart);
                            runOnClose.run();
                        }
                    };
                }
            }

            if (readMeterSyncFuture != null)
                readMeterSyncFuture.cancel(false);
            SSTableReader replacement = new SSTableReader(descriptor, components, metadata, partitioner, ifile, dfile, indexSummary.readOnlyClone(), bf, maxDataAge, sstableMetadata, isOpenEarly);
            replacement.readMeter = this.readMeter;
            replacement.first = this.last.compareTo(newStart) > 0 ? newStart : this.last;
            replacement.last = this.last;
            setReplacedBy(replacement);
            return replacement;
        }
    }

