    @VisibleForTesting
    List<Row> discardFirst(List<Row> rows, int toDiscard)
    {
        if (toDiscard == 0 || rows.isEmpty())
            return rows;

        int i = 0;
        DecoratedKey firstKey = null;
        ColumnFamily firstCf = null;
        while (toDiscard > 0 && i < rows.size())
        {
            Row first = rows.get(i++);
            firstKey = first.key;
            firstCf = first.cf.cloneMeShallow(isReversed());
            toDiscard -= isReversed()
                       ? discardLast(first.cf, toDiscard, firstCf)
                       : discardFirst(first.cf, toDiscard, firstCf);
        }

        // If there is less live data than to discard, all is discarded
        if (toDiscard > 0)
            return Collections.<Row>emptyList();

        // i is the index of the first row that we are sure to keep. On top of that,
        // we also keep firstCf is it hasn't been fully emptied by the last iteration above.
        int count = firstCf.getColumnCount();
        int newSize = rows.size() - (count == 0 ? i : i - 1);
        List<Row> newRows = new ArrayList<Row>(newSize);
        if (count != 0)
            newRows.add(new Row(firstKey, firstCf));
        newRows.addAll(rows.subList(i, rows.size()));

        return newRows;
    }

