    private static List<Composite> buildMultiColumnInBound(Bound bound,
                                                           List<ColumnDefinition> defs,
                                                           MultiColumnRestriction.IN restriction,
                                                           boolean isReversed,
                                                           CBuilder builder,
                                                           CType type,
                                                           QueryOptions options) throws InvalidRequestException
    {
        List<List<ByteBuffer>> splitInValues = restriction.splitValues(options);
        Bound eocBound = isReversed ? Bound.reverse(bound) : bound;

        // The IN query might not have listed the values in comparator order, so we need to re-sort
        // the bounds lists to make sure the slices works correctly (also, to avoid duplicates).
        TreeSet<Composite> inValues = new TreeSet<>(isReversed ? type.reverseComparator() : type);
        for (List<ByteBuffer> components : splitInValues)
        {
            for (int i = 0; i < components.size(); i++)
                if (components.get(i) == null)
                    throw new InvalidRequestException("Invalid null value in condition for column " + defs.get(i));

            Composite prefix = builder.buildWith(components);
            inValues.add(eocBound == Bound.END && builder.remainingCount() - components.size() > 0
                         ? prefix.end()
                         : prefix);
        }
        return new ArrayList<>(inValues);
    }

