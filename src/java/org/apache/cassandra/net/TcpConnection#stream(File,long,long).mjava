    public void stream(File file, long startPosition, long endPosition) throws IOException, InterruptedException
    {
        if ( !bStream_ )
            throw new IllegalStateException("Cannot stream since we are not set up to stream data.");
                
        lock_.lock();        
        try
        {            
            /* transfer 64MB in each attempt */
            int limit = 64*1024*1024;  
            long total = endPosition - startPosition;
            /* keeps track of total number of bytes transferred */
            long bytesWritten = 0L;                          
            RandomAccessFile raf = new RandomAccessFile(file, "r");            
            FileChannel fc = raf.getChannel();            
            
            /* 
             * If the connection is not yet established then wait for
             * the timeout period of 2 seconds. Attempt to reconnect 3 times and then 
             * bail with an IOException.
            */
            long waitTime = 2;
            int retry = 0;
            while (!socketChannel_.isConnected())
            {
                if ( retry == 3 )
                    throw new IOException("Unable to connect to " + remoteEp_ + " after " + retry + " attempts.");
                condition_.await(waitTime, TimeUnit.SECONDS);
                ++retry;
            }
            
            while ( bytesWritten < total )
            {                                
                if ( startPosition == 0 )
                {
                    ByteBuffer buffer = MessagingService.constructStreamHeader(false, true);                      
                    socketChannel_.write(buffer);
                    if (buffer.remaining() > 0)
                    {
                        pendingWrites_.add(buffer);
                        turnOnInterestOps(key_, SelectionKey.OP_WRITE);
                        condition_.await();
                    }
                }
                
                long bytesTransferred;
                try
                {
                    /* returns the number of bytes transferred from file to the socket */
                    bytesTransferred = fc.transferTo(startPosition, limit, socketChannel_);
                }
                catch (IOException e)
                {
                    // at least jdk1.6.0 on Linux seems to throw IOException
                    // when the socket is full. (Bug fixed for 1.7: http://bugs.sun.com/view_bug.do?bug_id=5103988)
                    // For now look for a specific string in for the message for the exception.
                    if (!e.getMessage().startsWith("Resource temporarily unavailable"))
                        throw e;
                    Thread.sleep(10);
                    continue;
                }
                if (logger_.isDebugEnabled())
                    logger_.debug("Bytes transferred " + bytesTransferred);                
                bytesWritten += bytesTransferred;
                startPosition += bytesTransferred; 
                /*
                 * If the number of bytes transferred is less than intended 
                 * then we need to wait till socket becomes writeable again. 
                */
                if ( bytesTransferred < limit && bytesWritten != total )
                {                    
                    turnOnInterestOps(key_, SelectionKey.OP_WRITE);
                    condition_.await();
                }
            }
        }
        finally
        {
            lock_.unlock();
        }        
    }

