    public LazilyCompactedRow(CompactionController controller, List<? extends OnDiskAtomIterator> rows)
    {
        super(rows.get(0).getKey());
        this.rows = rows;
        this.controller = controller;
        indexer = controller.cfs.indexManager.updaterFor(key);

        // Combine top-level tombstones, keeping the one with the highest markedForDeleteAt timestamp.  This may be
        // purged (depending on gcBefore), but we need to remember it to properly delete columns during the merge
        deletionInfo = DeletionInfo.live();
        maxTombstoneTimestamp = Long.MIN_VALUE;
        for (OnDiskAtomIterator row : rows)
        {
            DeletionInfo delInfo = row.getColumnFamily().deletionInfo();
            maxTombstoneTimestamp = Math.max(maxTombstoneTimestamp, delInfo.maxTimestamp());
            deletionInfo = deletionInfo.add(delInfo);
        }

        // Don't pass maxTombstoneTimestamp to shouldPurge since we might well have cells with
        // tombstones newer than the row-level tombstones we've seen -- but we won't know that
        // until we iterate over them.  By passing MAX_VALUE we will only purge if there are
        // no other versions of this row present.
        this.shouldPurge = controller.shouldPurge(key, Long.MAX_VALUE);

        emptyColumnFamily = ArrayBackedSortedColumns.factory.create(controller.cfs.metadata);
        emptyColumnFamily.setDeletionInfo(deletionInfo.copy());
        if (shouldPurge)
            emptyColumnFamily.purgeTombstones(controller.gcBefore);
    }

