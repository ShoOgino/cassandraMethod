    /**
     * Return a cached TokenMetadata with only tokenToEndpointMap, i.e., the same as cloneOnlyTokenMap but
     * uses a cached copy that is invalided when the ring changes, so in the common case
     * no extra locking is required.
     *
     * Callers must *NOT* mutate the returned metadata object.
     */
    public TokenMetadata cachedOnlyTokenMap()
    {
        TokenMetadata tm = cachedTokenMap.get();
        if (tm != null)
            return tm;

        // synchronize is to prevent thundering herd (CASSANDRA-6345); lock.readLock is for correctness vs updates to our internals
        synchronized (this)
        {
            if ((tm = cachedTokenMap.get()) != null)
                return tm;

            lock.readLock().lock();
            try
            {
                tm = new TokenMetadata(SortedBiMultiValMap.<Token, InetAddress>create(tokenToEndpointMap, null, inetaddressCmp),
                                       HashBiMap.create(endpointToHostIdMap),
                                       new Topology(topology));
                cachedTokenMap.set(tm);
                return tm;
            }
            finally
            {
                lock.readLock().unlock();
            }
        }
    }

