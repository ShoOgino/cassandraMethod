    static Map<String, Collection<IColumn>> getRangeSlice(RangeSliceCommand rawCommand) throws IOException, UnavailableException, TimedOutException
    {
        long startTime = System.currentTimeMillis();
        TokenMetadata tokenMetadata = StorageService.instance().getTokenMetadata();
        RangeSliceCommand command = rawCommand;

        InetAddress endPoint = StorageService.instance().findSuitableEndPoint(command.start_key);
        InetAddress startEndpoint = endPoint;
        InetAddress wrapEndpoint = tokenMetadata.getFirstEndpoint();

        TreeSet<Row> allRows = new TreeSet<Row>(rowComparator);
        do
        {

            Message message = command.getMessage();
            if (logger.isDebugEnabled())
                logger.debug("reading " + command + " from " + message.getMessageId() + "@" + endPoint);
            IAsyncResult iar = MessagingService.instance().sendRR(message, endPoint);
            byte[] responseBody;
            try
            {
                responseBody = iar.get(DatabaseDescriptor.getRpcTimeout(), TimeUnit.MILLISECONDS);
            }
            catch (TimeoutException ex)
            {
                throw new TimedOutException();
            }
            RangeSliceReply reply = RangeSliceReply.read(responseBody);
            List<Row> rangeRows = new ArrayList<Row>(reply.rows);

            // combine these what what has been seen so far.
            if (rangeRows.size() > 0)
            {
                if (allRows.size() > 0)
                {
                    if (keyComparator.compare(rangeRows.get(rangeRows.size() - 1).key, allRows.first().key) <= 0)
                    {
                        // unlikely, but possible
                        if (rangeRows.get(rangeRows.size() - 1).equals(allRows.first().key))
                        {
                            rangeRows.remove(rangeRows.size() - 1);
                        }
                        // put all from rangeRows into allRows.
                        allRows.addAll(rangeRows);
                    }
                    else if (keyComparator.compare(allRows.last().key, rangeRows.get(0).key) <= 0)
                    {
                        // common case. deal with simple start/end key overlaps
                        if (allRows.last().key.equals(rangeRows.get(0)))
                        {
                            allRows.remove(allRows.last().key);
                        }
                        allRows.addAll(rangeRows); // todo: check logic.
                    }
                    else
                    {
                        // deal with potential large overlap from scanning the first endpoint, which contains
                        // both the smallest and largest keys
                        allRows.addAll(rangeRows); // todo: check logic.
                    }
                }
                else
                    allRows.addAll(rangeRows); // todo: check logic.
            }

            if (allRows.size() >= rawCommand.max_keys || reply.rangeCompletedLocally)
                break;

            do
            {
                endPoint = tokenMetadata.getSuccessor(endPoint); // TODO move this into the Strategies & modify for RackAwareStrategy
            }
            while (!FailureDetector.instance().isAlive(endPoint));
            int maxResults = endPoint == wrapEndpoint ? rawCommand.max_keys : rawCommand.max_keys - allRows.size();
            command = new RangeSliceCommand(command, maxResults);
        }
        while (!endPoint.equals(startEndpoint));

        Map<String, Collection<IColumn>> results = new TreeMap<String, Collection<IColumn>>();
        for (Row row : allRows)
        {
            if (row.cf == null)
                results.put(row.key, Collections.<IColumn>emptyList());
            else
                results.put(row.key, row.cf.getSortedColumns());
        }
        rangeStats.add(System.currentTimeMillis() - startTime);
        return results;
    }

