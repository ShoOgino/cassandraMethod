    public IndexSummary build(IPartitioner partitioner, DecoratedKey exclusiveUpperBound)
    {
        assert keys.size() > 0;
        assert keys.size() == positions.size();

        int length;
        if (exclusiveUpperBound == null)
            length = keys.size();
        else
            length = Collections.binarySearch(keys, exclusiveUpperBound);

        assert length > 0;

        long offheapSize = this.offheapSize;
        if (length < keys.size())
            for (int i = length ; i < keys.size() ; i++)
                offheapSize -= keys.get(i).getKey().remaining() + TypeSizes.NATIVE.sizeof(positions.get(i));

        // first we write out the position in the *summary* for each key in the summary,
        // then we write out (key, actual index position) pairs
        RefCountedMemory memory = new RefCountedMemory(offheapSize + (length * 4));
        int idxPosition = 0;
        int keyPosition = length * 4;
        for (int i = 0; i < length; i++)
        {
            // write the position of the actual entry in the index summary (4 bytes)
            memory.setInt(idxPosition, keyPosition);
            idxPosition += TypeSizes.NATIVE.sizeof(keyPosition);

            // write the key
            ByteBuffer keyBytes = keys.get(i).getKey();
            memory.setBytes(keyPosition, keyBytes);
            keyPosition += keyBytes.remaining();

            // write the position in the actual index file
            long actualIndexPosition = positions.get(i);
            memory.setLong(keyPosition, actualIndexPosition);
            keyPosition += TypeSizes.NATIVE.sizeof(actualIndexPosition);
        }
        assert keyPosition == offheapSize + (length * 4);
        int sizeAtFullSampling = (int) Math.ceil(keysWritten / (double) minIndexInterval);
        return new IndexSummary(partitioner, memory, length, sizeAtFullSampling, minIndexInterval, samplingLevel);
    }

