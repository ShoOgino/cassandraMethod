        protected Transformation<BaseRowIterator<?>> filter(CFMetaData metadata, int nowInSec)
        {
            // Thrift does not filter rows, it filters entire partition if any of the expression is not
            // satisfied, which forces us to materialize the result (in theory we could materialize only
            // what we need which might or might not be everything, but we keep it simple since in practice
            // it's not worth that it has ever been).
            return new Transformation<BaseRowIterator<?>>()
            {
                protected BaseRowIterator<?> applyToPartition(BaseRowIterator<?> partition)
                {
                    return partition instanceof UnfilteredRowIterator ? applyTo((UnfilteredRowIterator) partition)
                                                                      : applyTo((RowIterator) partition);
                }

                private UnfilteredRowIterator applyTo(UnfilteredRowIterator partition)
                {
                    ImmutableBTreePartition result = ImmutableBTreePartition.create(partition);
                    partition.close();
                    return accepts(result) ? result.unfilteredIterator() : null;
                }

                private RowIterator applyTo(RowIterator partition)
                {
                    FilteredPartition result = FilteredPartition.create(partition);
                    return accepts(result) ? result.rowIterator() : null;
                }

                private boolean accepts(ImmutableBTreePartition result)
                {
                    // The partition needs to have a row for every expression, and the expression needs to be valid.
                    for (Expression expr : expressions)
                    {
                        assert expr instanceof ThriftExpression;
                        Row row = result.getRow(makeCompactClustering(metadata, expr.column().name.bytes));
                        if (row == null || !expr.isSatisfiedBy(metadata, result.partitionKey(), row))
                            return false;
                    }
                    // If we get there, it means all expressions where satisfied, so return the original result
                    return true;
                }
            };
        }

