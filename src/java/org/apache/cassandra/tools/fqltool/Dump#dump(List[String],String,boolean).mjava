    public static void dump(List<String> arguments, String rollCycle, boolean follow)
    {
        StringBuilder sb = new StringBuilder();
        ReadMarshallable reader = wireIn -> {
            sb.setLength(0);
            String type = wireIn.read("type").text();
            sb.append("Type: ").append(type).append(System.lineSeparator());
            assert type != null;
            if (type.equals("AuditLog"))
            {
                sb.append("LogMessage: ").append(wireIn.read("message").text()).append(System.lineSeparator());

            }
            else
            {
                int protocolVersion = wireIn.read("protocol-version").int32();
                sb.append("Protocol version: ").append(protocolVersion).append(System.lineSeparator());
                QueryOptions options = QueryOptions.codec.decode(Unpooled.wrappedBuffer(wireIn.read("query-options").bytesStore().toTemporaryDirectByteBuffer()), ProtocolVersion.decode(protocolVersion));
                sb.append("Query time: ").append(wireIn.read("query-time").int64()).append(System.lineSeparator());

                if (type.equals("single"))
                {
                    sb.append("Query: ").append(wireIn.read("query").text()).append(System.lineSeparator());
                    List<ByteBuffer> values = options.getValues() != null ? options.getValues() : Collections.EMPTY_LIST;
                    sb.append("Values: ").append(System.lineSeparator());
                    valuesToStringBuilder(values, sb);
                }
                else
                {
                    sb.append("Batch type: ").append(wireIn.read("batch-type").text()).append(System.lineSeparator());
                    ValueIn in = wireIn.read("queries");
                    int numQueries = in.int32();
                    List<String> queries = new ArrayList<>();
                    for (int ii = 0; ii < numQueries; ii++)
                    {
                        queries.add(in.text());
                    }
                    in = wireIn.read("values");
                    int numValues = in.int32();
                    List<List<ByteBuffer>> values = new ArrayList<>();
                    for (int ii = 0; ii < numValues; ii++)
                    {
                        List<ByteBuffer> subValues = new ArrayList<>();
                        values.add(subValues);
                        int numSubValues = in.int32();
                        for (int zz = 0; zz < numSubValues; zz++)
                        {
                            subValues.add(ByteBuffer.wrap(in.bytes()));
                        }
                        sb.append("Query: ").append(queries.get(ii)).append(System.lineSeparator());
                        sb.append("Values: ").append(System.lineSeparator());
                        valuesToStringBuilder(subValues, sb);
                    }
                }
            }
            sb.append(System.lineSeparator());
            System.out.print(sb.toString());
            System.out.flush();
        };

        //Backoff strategy for spinning on the queue, not aggressive at all as this doesn't need to be low latency
        Pauser pauser = Pauser.millis(100);
        List<ChronicleQueue> queues = arguments.stream().distinct().map(path -> ChronicleQueueBuilder.single(new File(path)).rollCycle(RollCycles.valueOf(rollCycle)).build()).collect(Collectors.toList());
        List<ExcerptTailer> tailers = queues.stream().map(ChronicleQueue::createTailer).collect(Collectors.toList());
        boolean hadWork = true;
        while (hadWork)
        {
            hadWork = false;
            for (ExcerptTailer tailer : tailers)
            {
                while (tailer.readDocument(reader))
                {
                    hadWork = true;
                }
            }

            if (follow)
            {
                if (!hadWork)
                {
                    //Chronicle queue doesn't support blocking so use this backoff strategy
                    pauser.pause();
                }
                //Don't terminate the loop even if there wasn't work
                hadWork = true;
            }
        }
    }

