    /**
     * No locking required since it is called from a method that already
     * has acquired a lock. The gossip digest is built based on randomization
     * rather than just looping through the collection of live endpoints.
     *
     * @param gDigests list of Gossip Digests.
    */
    void makeRandomGossipDigest(List<GossipDigest> gDigests)
    {
        /* Add the local endpoint state */
        EndPointState epState = endPointStateMap_.get(localEndPoint_);
        int generation = epState.getHeartBeatState().getGeneration();
        int maxVersion = getMaxEndPointStateVersion(epState);
        gDigests.add( new GossipDigest(localEndPoint_, generation, maxVersion) );

        List<InetAddress> endpoints = new ArrayList<InetAddress>(endPointStateMap_.keySet());
        Collections.shuffle(endpoints, random_);
        for (InetAddress endPoint : endpoints)
        {
            epState = endPointStateMap_.get(endPoint);
            if (epState != null)
            {
                generation = epState.getHeartBeatState().getGeneration();
                maxVersion = getMaxEndPointStateVersion(epState);
                gDigests.add(new GossipDigest(endPoint, generation, maxVersion));
            }
            else
            {
            	gDigests.add(new GossipDigest(endPoint, 0, 0));
            }
        }

        /* FOR DEBUG ONLY - remove later */
        StringBuilder sb = new StringBuilder();
        for ( GossipDigest gDigest : gDigests )
        {
            sb.append(gDigest);
            sb.append(" ");
        }
        if (logger_.isTraceEnabled())
            logger_.trace("Gossip Digests are : " + sb.toString());
    }

