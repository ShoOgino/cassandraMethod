    /**
     * @return true if we are able to mark the given @param sstables as compacted, before anyone else
     *
     * Note that we could acquire references on the marked sstables and release them in
     * unmarkCompacting, but since we will never call markObsolete on a sstable marked
     * as compacting (unless there is a serious bug), we can skip this.
     */
    public boolean markCompacting(Iterable<SSTableReader> sstables)
    {
        assert sstables != null && !Iterables.isEmpty(sstables);
        while (true)
        {
            View currentView = view.get();
            Set<SSTableReader> set = ImmutableSet.copyOf(sstables);
            Set<SSTableReader> inactive = Sets.difference(set, currentView.compacting);
            if (inactive.size() < set.size())
                return false;

            if (Iterables.any(set, new Predicate<SSTableReader>()
            {
                @Override
                public boolean apply(SSTableReader sstable)
                {
                    return sstable.isMarkedCompacted();
                }
            }))
            {
                return false;
            }

            View newView = currentView.markCompacting(set);
            if (view.compareAndSet(currentView, newView))
                return true;
        }
    }

