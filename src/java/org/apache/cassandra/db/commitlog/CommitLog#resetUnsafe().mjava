    /**
     * FOR TESTING PURPOSES. See CommitLogAllocator.
     *
     * There is a race at the moment, even if this method
     * is synchronized we can still create an allocation
     * on a segment that will be closed in this method,
     * therefore causing {@link Allocation#awaitDiskSync()} to hang
     * forever. This typically happens because of the mutations created
     * by {@link org.apache.cassandra.io.sstable.SSTableReader.GlobalTidy},
     * that's why we wait for all deletions to complete firtst.
     */
    public synchronized void resetUnsafe()
    {
        SSTableDeletingTask.waitForDeletions();
        sync(true);
        allocator.resetUnsafe();
        CommitLogSegment.resetReplayLimit();
    }

