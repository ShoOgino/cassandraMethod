    /**
     * Here we are removing the nodes that need to leave the
     * ring and trying to calculate what the ranges would look
     * like w/o them. e.g. if we remove two nodes A and D from
     * the ring and the order of nodes on the ring is A, B, C
     * and D. When B is removed the range of C is the old range 
     * of C and the old range of B. We want a mapping from old
     * range of B to new range of B. We have 
     * A----B----C----D----E----F----G and we remove b and e
     * then we want a mapping from (a, c] --> (a,b], (b, c] and 
     * (d, f] --> (d, e], (d,f].
     * @param oldRanges ranges with the previous configuration
     * @param newRanges ranges with the target endpoints removed.
     * @return map of expanded range to the list whose aggregate is
     *             the expanded range.
     */
    protected static Map<Range, List<Range>> getExpandedRangeToOldRangeMapping(Range[] oldRanges, Range[] newRanges)
    {
        Map<Range, List<Range>> map = new HashMap<Range, List<Range>>();   
        List<Range> oRanges = new ArrayList<Range>();
        Collections.addAll(oRanges, oldRanges);
        List<Range> nRanges = new ArrayList<Range>();
        Collections.addAll(nRanges, newRanges);
        
        /*
         * Remove the ranges that are the same. 
         * Now we will be left with the expanded 
         * ranges in the nRanges list and the 
         * smaller ranges in the oRanges list. 
        */
        for( Range oRange : oldRanges )
        {            
            boolean bVal = nRanges.remove(oRange);
            if ( bVal )
                oRanges.remove(oRange);
        }
        
        int nSize = nRanges.size();
        int oSize = oRanges.size();
        /*
         * Establish the mapping between expanded ranges
         * to the smaller ranges whose aggregate is the
         * expanded range. 
        */
        for ( int i = 0; i < nSize; ++i )
        {
            Range nRange = nRanges.get(i);
            for ( int j = 0; j < oSize; ++j )
            {
                Range oRange = oRanges.get(j);
                if ( nRange.contains(oRange.right()) )
                {
                    List<Range> smallerRanges = map.get(nRange);
                    if ( smallerRanges == null )
                    {
                        smallerRanges = new ArrayList<Range>();
                        map.put(nRange, smallerRanges);
                    }
                    smallerRanges.add(oRange);
                    continue;
                }
            }
        }
        
        return map;
    }

