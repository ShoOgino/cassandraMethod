    /*
     * This function executes the read protocol.
        // 1. Get the N nodes from storage service where the data needs to be
        // replicated
        // 2. Construct a message for read\write
         * 3. Set one of the messages to get the data and the rest to get the digest
        // 4. SendRR ( to all the nodes above )
        // 5. Wait for a response from at least X nodes where X <= N and the data node
         * 6. If the digest matches return the data.
         * 7. else carry out read repair by getting data from all the nodes.
        // 5. return success
     */
    private static List<Row> strongRead(List<ReadCommand> commands) throws IOException, TimeoutException, InvalidRequestException, UnavailableException
    {
        List<QuorumResponseHandler<Row>> quorumResponseHandlers = new ArrayList<QuorumResponseHandler<Row>>();
        List<EndPoint[]> commandEndPoints = new ArrayList<EndPoint[]>();
        List<Row> rows = new ArrayList<Row>();

        int commandIndex = 0;

        for (ReadCommand command: commands)
        {
            // TODO: throw a thrift exception if we do not have N nodes
            assert !command.isDigestQuery();
            ReadCommand readMessageDigestOnly = command.copy();
            readMessageDigestOnly.setDigestQuery(true);

            Message message = command.makeReadMessage();
            Message messageDigestOnly = readMessageDigestOnly.makeReadMessage();

            IResponseResolver<Row> readResponseResolver = new ReadResponseResolver();
            QuorumResponseHandler<Row> quorumResponseHandler = new QuorumResponseHandler<Row>(
                    DatabaseDescriptor.getQuorum(),
                    readResponseResolver);
            EndPoint dataPoint = StorageService.instance().findSuitableEndPoint(command.key);
            List<EndPoint> endpointList = new ArrayList<EndPoint>(Arrays.asList(StorageService.instance().getReadStorageEndPoints(command.key)));
            /* Remove the local storage endpoint from the list. */
            endpointList.remove(dataPoint);
            EndPoint[] endPoints = new EndPoint[endpointList.size() + 1];
            Message messages[] = new Message[endpointList.size() + 1];

            /*
             * First message is sent to the node that will actually get
             * the data for us. The other two replicas are only sent a
             * digest query.
            */
            endPoints[0] = dataPoint;
            messages[0] = message;
            if (logger.isDebugEnabled())
                logger.debug("strongread reading data for " + command + " from " + message.getMessageId() + "@" + dataPoint);
            for (int i = 1; i < endPoints.length; i++)
            {
                EndPoint digestPoint = endpointList.get(i - 1);
                endPoints[i] = digestPoint;
                messages[i] = messageDigestOnly;
                if (logger.isDebugEnabled())
                    logger.debug("strongread reading digest for " + command + " from " + messageDigestOnly.getMessageId() + "@" + digestPoint);
            }
            MessagingService.getMessagingInstance().sendRR(messages, endPoints, quorumResponseHandler);
            quorumResponseHandlers.add(quorumResponseHandler);
            commandEndPoints.add(endPoints);
        }

        for (QuorumResponseHandler<Row> quorumResponseHandler: quorumResponseHandlers)
        {
            Row row = null;
            ReadCommand command = commands.get(commandIndex);
            try
            {
                long startTime2 = System.currentTimeMillis();
                row = quorumResponseHandler.get();
                if (row != null)
                    rows.add(row);

                if (logger.isDebugEnabled())
                    logger.debug("quorumResponseHandler: " + (System.currentTimeMillis() - startTime2) + " ms.");
            }
            catch (DigestMismatchException ex)
            {
                if ( DatabaseDescriptor.getConsistencyCheck())
                {
                    IResponseResolver<Row> readResponseResolverRepair = new ReadResponseResolver();
                    QuorumResponseHandler<Row> quorumResponseHandlerRepair = new QuorumResponseHandler<Row>(
                            DatabaseDescriptor.getQuorum(),
                            readResponseResolverRepair);
                    logger.info("DigestMismatchException: " + command.key);
                    Message messageRepair = command.makeReadMessage();
                    MessagingService.getMessagingInstance().sendRR(messageRepair, commandEndPoints.get(commandIndex),
                            quorumResponseHandlerRepair);
                    try
                    {
                        row = quorumResponseHandlerRepair.get();
                        if (row != null)
                            rows.add(row);
                    }
                    catch (DigestMismatchException e)
                    {
                        // TODO should this be a thrift exception?
                        throw new RuntimeException("digest mismatch reading key " + command.key, e);
                    }
                }
            }
            commandIndex++;
        }

        return rows;
    }

