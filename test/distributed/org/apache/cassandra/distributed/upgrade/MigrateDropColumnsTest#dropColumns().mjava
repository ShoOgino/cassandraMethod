    @Test
    public void dropColumns() throws Throwable
    {
        new TestCase()
        .upgrade(Versions.Major.v22, Versions.Major.v30)
//        .upgrade(Versions.Major.v22, Versions.Major.v3X)
//        .upgrade(Versions.Major.v30, Versions.Major.v3X)
//        .upgrade(Versions.Major.v22, Versions.Major.v30, Versions.Major.v3X)
        .withConfig(c -> c.with(Feature.NATIVE_PROTOCOL))
        .setup(cluster -> {
            cluster.schemaChange(withKeyspace("CREATE TABLE %s.tbl(pk int, tables map<int, int>, PRIMARY KEY (pk))"));

            ICoordinator coordinator = cluster.coordinator(1);

            // write a RT to pk=0
            ThriftClientUtils.thriftClient(cluster.get(1), thrift -> {
                thrift.set_keyspace(KEYSPACE);

                Mutation mutation = new Mutation();
                Deletion deletion = new Deletion();
                SlicePredicate slice = new SlicePredicate();
                SliceRange range = new SliceRange();
                range.setStart(CompositeType.build(ByteBufferUtil.bytes("tables")));
                range.setFinish(CompositeType.build(ByteBufferUtil.bytes("tables")));
                slice.setSlice_range(range);
                deletion.setPredicate(slice);
                deletion.setTimestamp(System.currentTimeMillis());
                mutation.setDeletion(deletion);

                thrift.batch_mutate(Collections.singletonMap(ByteBufferUtil.bytes(0),
                                                             Collections.singletonMap("tbl", Arrays.asList(mutation))),
                                    org.apache.cassandra.thrift.ConsistencyLevel.ALL);
            });

            // write table to pk=1
            // NOTE: because jvm-dtest doesn't support collections in the execute interface (see CASSANDRA-15969)
            // need to encode to a ByteBuffer first
            coordinator.execute(withKeyspace("INSERT INTO %s.tbl (pk, tables) VALUES (?, ?)"), ConsistencyLevel.ONE, 1, MAP_TYPE.decompose(ImmutableMap.of(1, 1)));

            cluster.forEach(inst -> inst.flush(KEYSPACE));

            cluster.schemaChange(withKeyspace("ALTER TABLE %s.tbl DROP tables"));
        })
        .runAfterClusterUpgrade(cluster -> {
            ICoordinator coordinator = cluster.coordinator(1);
            SimpleQueryResult qr = coordinator.executeWithResult("SELECT column_name " +
                                                                 "FROM system_schema.dropped_columns " +
                                                                 "WHERE keyspace_name=?" +
                                                                 " AND table_name=?;",
                                                                 ConsistencyLevel.ALL, KEYSPACE, "tbl");
            Assert.assertEquals(ImmutableSet.of("tables"), Sets.newHashSet(qr.map(r -> r.getString("column_name"))));

            assertRows(coordinator);

            // upgradesstables, make sure everything is still working
            cluster.forEach(n -> n.nodetoolResult("upgradesstables", KEYSPACE).asserts().success());

            assertRows(coordinator);
        })
        .run();
    }

