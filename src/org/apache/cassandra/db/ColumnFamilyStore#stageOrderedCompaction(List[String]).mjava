    /*
     * Stage the compactions , compact similar size files.
     * This fn figures out the files close enough by size and if they
     * are greater than the threshold then compacts.
     */
    Map<Integer, List<String>> stageOrderedCompaction(List<String> files)
    {
        // Sort the files based on the generation ID 
        Collections.sort(files, new FileNameComparator(FileNameComparator.Ascending));
    	Map<Integer, List<String>>  buckets = new HashMap<Integer, List<String>>();
    	int maxBuckets = 1000;
    	long averages[] = new long[maxBuckets];
    	long min = 50L*1024L*1024L;
    	Integer i = 0;
    	for(String file : files)
    	{
    		File f = new File(file);
    		long size = f.length();
			if ( (size > averages[i]/2 && size < 3*averages[i]/2) || ( size < min && averages[i] < min ))
			{
				averages[i] = (averages[i] + size) / 2 ;
				List<String> fileList = buckets.get(i);
				if(fileList == null)
				{
					fileList = new ArrayList<String>();
					buckets.put(i, fileList);
				}
				fileList.add(file);
			}
			else
    		{
				if( i >= maxBuckets )
					break;
				i++;
				List<String> fileList = new ArrayList<String>();
				buckets.put(i, fileList);
				fileList.add(file);
    			averages[i] = size;
    		}
    	}
    	return buckets;
    }

