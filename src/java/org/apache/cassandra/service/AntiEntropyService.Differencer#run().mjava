        /**
         * Compares our trees, and triggers repairs for any ranges that mismatch.
         */
        public void run()
        {
            StorageService ss = StorageService.instance();
            Token minimum = ss.getPartitioner().getMinimumToken();

            // restore partitioners (in case we were serialized)
            if (ltree.partitioner() == null)
                ltree.partitioner(ss.getPartitioner());
            if (rtree.partitioner() == null)
                rtree.partitioner(ss.getPartitioner());

            // determine the ranges where responsibility overlaps
            Set<Range> interesting = new HashSet(ss.getRangesForEndPoint(local));
            interesting.retainAll(ss.getRangesForEndPoint(remote));

            // compare trees, and filter out uninteresting differences
            for (Range diff : MerkleTree.difference(ltree, rtree))
            {
                for (Range localrange: interesting)
                {
                    if (diff.intersects(localrange))
                    {
                        differences.add(diff);
                        break; // the inner loop
                    }
                }
            }
            
            // TODO: calculating a percentage here would be all kinds of awesome
            logger.info("Found " + differences.size() + " differing ranges between local " +
                local + " and remote " + remote + " endpoints for " + cf + ".");

            // FIXME: trigger repairs!
        }

