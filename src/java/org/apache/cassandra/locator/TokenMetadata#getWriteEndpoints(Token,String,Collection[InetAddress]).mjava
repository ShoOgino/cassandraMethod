    /**
     * write endpoints may be different from read endpoints, because read endpoints only need care about the
     * "natural" nodes for a token, but write endpoints also need to account for nodes that are bootstrapping
     * into the ring, and write data there too so that they stay up to date during the bootstrap process.
     * Thus, this method may return more nodes than the Replication Factor.
     *
     * If possible, will return the same collection it was passed, for efficiency.
     *
     * Only ReplicationStrategy should care about this method (higher level users should only ask for Hinted).
     * 
     * @return a pair with the collection of write endpoints as well as the collection of pending endpoints (a subset
     * of the write endpoints). The later is needed to correctly compute the number of endpoint to block for in face of
     * bootstrap/leaving node
     */
    public Pair<? extends Iterable<InetAddress>, ? extends Iterable<InetAddress>> getWriteEndpoints(Token token, String table, Collection<InetAddress> naturalEndpoints)
    {
        Map<Range, Collection<InetAddress>> ranges = getPendingRanges(table);
        if (ranges.isEmpty())
            return Pair.create(naturalEndpoints, Collections.<InetAddress>emptyList());

        Set<InetAddress> pendings = new HashSet<InetAddress>();
        for (Map.Entry<Range, Collection<InetAddress>> entry : ranges.entrySet())
        {
            if (entry.getKey().contains(token))
                pendings.addAll(entry.getValue());
        }

        return Pair.create(Iterables.concat(naturalEndpoints, pendings), pendings);
    }

