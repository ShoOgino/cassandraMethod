    // lastIntervalKey should come from getLastReadableBoundary().lastKey
    public IndexSummary build(IPartitioner partitioner, DecoratedKey lastIntervalKey)
    {
        assert keys.size() > 0;
        assert keys.size() == positions.size();

        int length;
        if (lastIntervalKey == null)
            length = keys.size();
        else // since it's an inclusive upper bound, this should never match exactly
            length = -1 -Collections.binarySearch(keys, lastIntervalKey);

        assert length > 0;

        long offheapSize = this.offheapSize;
        if (length < keys.size())
            for (int i = length ; i < keys.size() ; i++)
                offheapSize -= keys.get(i).getKey().remaining() + TypeSizes.NATIVE.sizeof(positions.get(i));

        // first we write out the position in the *summary* for each key in the summary,
        // then we write out (key, actual index position) pairs
        Memory memory = Memory.allocate(offheapSize + (length * 4));
        int idxPosition = 0;
        int keyPosition = length * 4;
        for (int i = 0; i < length; i++)
        {
            // write the position of the actual entry in the index summary (4 bytes)
            memory.setInt(idxPosition, keyPosition);
            idxPosition += TypeSizes.NATIVE.sizeof(keyPosition);

            // write the key
            ByteBuffer keyBytes = keys.get(i).getKey();
            memory.setBytes(keyPosition, keyBytes);
            keyPosition += keyBytes.remaining();

            // write the position in the actual index file
            long actualIndexPosition = positions.get(i);
            memory.setLong(keyPosition, actualIndexPosition);
            keyPosition += TypeSizes.NATIVE.sizeof(actualIndexPosition);
        }
        assert keyPosition == offheapSize + (length * 4);
        int sizeAtFullSampling = (int) Math.ceil(keysWritten / (double) minIndexInterval);
        return new IndexSummary(partitioner, memory, length, sizeAtFullSampling, minIndexInterval, samplingLevel);
    }

