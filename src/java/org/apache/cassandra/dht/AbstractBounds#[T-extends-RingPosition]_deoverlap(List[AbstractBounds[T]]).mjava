    /**
     * Given a list of unwrapped bounds sorted by left token, return a list a equivalent
     * list of bounds but with no overlapping bounds.
     */
    private static <T extends RingPosition> List<AbstractBounds<T>> deoverlap(List<AbstractBounds<T>> bounds)
    {
        if (bounds.isEmpty())
            return bounds;

        List<AbstractBounds<T>> output = new ArrayList<AbstractBounds<T>>();

        Iterator<AbstractBounds<T>> iter = bounds.iterator();
        AbstractBounds<T> current = iter.next();
        boolean isRange = current instanceof Range;

        T min = (T) current.partitioner.minValue(current.left.getClass());
        while (iter.hasNext())
        {
            if (current.right.equals(min))
            {
                // If one of the bound is the full range, we return only that
                if (current.left.equals(min))
                    return Collections.<AbstractBounds<T>>singletonList(current);

                output.add(current.createFrom(min));
                return output;
            }

            AbstractBounds<T> next = iter.next();
            assert isRange ? next instanceof Range : next instanceof Bounds;

            // For Ranges, if next left is equal to current right, we do not intersect per se, but replacing (A, B] and (B, C] by (A, C] is
            // legit, and since this actually avoid special casing and will result in more "optimal" ranges, we do this transformation
            if (next.left.compareTo(current.right) <= 0)
            {
                // We do overlap
                // (we've handler current.right.equals(min) already)
                T newRight = next.right.equals(min) || current.right.compareTo(next.right) < 0 ? next.right : current.right;
                current = current.createFrom(newRight);
                if (current == null)
                    // current is the full ring, can only happen for Range
                    return Collections.<AbstractBounds<T>>singletonList(new Range<T>(min, min));
            }
            else
            {
                output.add(current);
                current = next;
            }
        }
        output.add(current);
        return output;
    }

