    public static List<Pair<String, ColumnFamily>> getRangeSlice(RangeSliceCommand command, ConsistencyLevel consistency_level)
    throws IOException, UnavailableException, TimeoutException
    {
        long startTime = System.nanoTime();
        TokenMetadata tokenMetadata = StorageService.instance.getTokenMetadata();
        Iterator<Token> iter = TokenMetadata.ringIterator(tokenMetadata.sortedTokens(), command.range.left);

        final String table = command.keyspace;
        int responseCount = determineBlockFor(DatabaseDescriptor.getReplicationFactor(table), DatabaseDescriptor.getReplicationFactor(table), consistency_level);

        // starting with the range containing the start key, scan until either we have enough results,
        // or the node scan reports that it was done (i.e., encountered a key outside the desired range).
        Map<String, ColumnFamily> rows = new HashMap<String, ColumnFamily>(command.max_keys);
        outer:
        while (iter.hasNext())
        {
            Token currentToken = iter.next();
            Range currentRange = new Range(tokenMetadata.getPredecessor(currentToken), currentToken);
            List<InetAddress> endpoints = StorageService.instance.getLiveNaturalEndpoints(command.keyspace, currentToken);
            if (endpoints.size() < responseCount)
                throw new UnavailableException();
            DatabaseDescriptor.getEndPointSnitch(command.keyspace).sortByProximity(FBUtilities.getLocalAddress(), endpoints);

            // make sure we only get keys from the current range (and not other replicas that might be on the nodes).
            // usually this will be only one range, but sometimes the intersection of a wrapping Range with a non-wrapping
            // is two disjoint, non-wrapping Ranges separated by a gap.
            List<AbstractBounds> restricted = command.range.restrictTo(currentRange);

            for (AbstractBounds range : restricted)
            {
                RangeSliceCommand c2 = new RangeSliceCommand(command.keyspace, command.column_family, command.super_column, command.predicate, range, command.max_keys);
                Message message = c2.getMessage();

                // collect replies and resolve according to consistency level
                List<InetAddress> endpointsforCL = endpoints.subList(0, responseCount);
                RangeSliceResponseResolver resolver = new RangeSliceResponseResolver(command.keyspace, currentRange, endpointsforCL);
                QuorumResponseHandler<Map<String, ColumnFamily>> handler = new QuorumResponseHandler<Map<String, ColumnFamily>>(responseCount, resolver);

                for (InetAddress endpoint : endpointsforCL)
                {
                    MessagingService.instance.sendRR(message, endpoint, handler);
                    if (logger.isDebugEnabled())
                        logger.debug("reading " + c2 + " for " + range + " from " + message.getMessageId() + "@" + endpoint);
                }
                // TODO read repair on remaining replicas?

                // if we're done, great, otherwise, move to the next range
                try
                {
                    rows.putAll(handler.get());
                }
                catch (DigestMismatchException e)
                {
                    throw new AssertionError(e); // no digests in range slices yet
                }
                if (rows.size() >= command.max_keys || resolver.completed())
                    break outer;
            }
        }

        List<Pair<String, ColumnFamily>> results = new ArrayList<Pair<String, ColumnFamily>>(rows.size());
        for (Map.Entry<String, ColumnFamily> entry : rows.entrySet())
        {
            ColumnFamily cf = entry.getValue();
            results.add(new Pair<String, ColumnFamily>(entry.getKey(), cf));
        }
        Collections.sort(results, new Comparator<Pair<String, ColumnFamily>>()
        {
            public int compare(Pair<String, ColumnFamily> o1, Pair<String, ColumnFamily> o2)
            {
                return keyComparator.compare(o1.left, o2.left);                
            }
        });
        rangeStats.addNano(System.nanoTime() - startTime);
        return results;
    }

