    private CellName makeExclusiveSliceBound(Bound bound, CellNameType type, QueryOptions options) throws InvalidRequestException
    {
        if (sliceRestriction.isInclusive(bound))
            return null;

        // We can only reach that point if cfm.comparator.isCompound() = false and the table has some clustering columns.
        // By consequence, we know that the table is a COMPACT table with only one clustering column.
        ByteBuffer value = sliceRestriction.isMultiColumn() ? ((MultiColumnRestriction.Slice) sliceRestriction).componentBounds(bound, options).get(0)
                                                            : sliceRestriction.bound(bound, options);

        // Dense non-compound tables do not accept empty ByteBuffers. By consequence, if the slice value is empty
        // we know that we can treat the slice as inclusive.
        return value.hasRemaining() ? type.makeCellName(value) : null;
    }

