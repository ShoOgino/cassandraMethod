    /**
     * Use this method to have these Mutations applied
     * across all replicas.
     *
     * @param mutations the mutations to be applied across the replicas
     * @param writeCommitLog if commitlog should be written
     * @param baseComplete time from epoch in ms that the local base mutation was(or will be) completed
     */
    public static void mutateMV(ByteBuffer dataKey, Collection<Mutation> mutations, boolean writeCommitLog, AtomicLong baseComplete)
    throws UnavailableException, OverloadedException, WriteTimeoutException
    {
        Tracing.trace("Determining replicas for mutation");
        final String localDataCenter = DatabaseDescriptor.getEndpointSnitch().getDatacenter(FBUtilities.getBroadcastAddress());

        long startTime = System.nanoTime();


        try
        {
            // if we haven't joined the ring, write everything to batchlog because paired replicas may be stale
            final UUID batchUUID = UUIDGen.getTimeUUID();

            if (StorageService.instance.isStarting() || StorageService.instance.isJoining() || StorageService.instance.isMoving())
            {
                BatchlogManager.store(Batch.createLocal(batchUUID, FBUtilities.timestampMicros(),
                                                        mutations), writeCommitLog);
            }
            else
            {
                List<WriteResponseHandlerWrapper> wrappers = new ArrayList<>(mutations.size());
                List<Mutation> nonPairedMutations = new LinkedList<>();
                Token baseToken = StorageService.instance.getTokenMetadata().partitioner.getToken(dataKey);

                ConsistencyLevel consistencyLevel = ConsistencyLevel.ONE;

                //Since the base -> view replication is 1:1 we only need to store the BL locally
                final Collection<InetAddress> batchlogEndpoints = Collections.singleton(FBUtilities.getBroadcastAddress());
                BatchlogResponseHandler.BatchlogCleanup cleanup = new BatchlogResponseHandler.BatchlogCleanup(mutations.size(),
                                                                                                              () -> asyncRemoveFromBatchlog(batchlogEndpoints, batchUUID));
                // add a handler for each mutation - includes checking availability, but doesn't initiate any writes, yet
                for (Mutation mutation : mutations)
                {
                    String keyspaceName = mutation.getKeyspaceName();
                    Token tk = mutation.key().getToken();
                    Optional<InetAddress> pairedEndpoint = ViewUtils.getViewNaturalEndpoint(keyspaceName, baseToken, tk);
                    Collection<InetAddress> pendingEndpoints = StorageService.instance.getTokenMetadata().pendingEndpointsFor(tk, keyspaceName);

                    if (pairedEndpoint.isPresent())
                    {
                        // When local node is the endpoint and there are no pending nodes we can
                        // Just apply the mutation locally.
                        if (pairedEndpoint.get().equals(FBUtilities.getBroadcastAddress())
                            && pendingEndpoints.isEmpty() && StorageService.instance.isJoined())
                            try
                            {
                                mutation.apply(writeCommitLog);
                            }
                            catch (Exception exc)
                            {
                                logger.error("Error applying local view update to keyspace {}: {}", mutation.getKeyspaceName(), mutation);
                                throw exc;
                            }
                        else
                        {
                            wrappers.add(wrapViewBatchResponseHandler(mutation,
                                                                      consistencyLevel,
                                                                      consistencyLevel,
                                                                      Collections.singletonList(pairedEndpoint.get()),
                                                                      baseComplete,
                                                                      WriteType.BATCH,
                                                                      cleanup));
                        }
                    }
                    else
                    {
                        //if there are no paired endpoints there are probably range movements going on,
                        //so we write to the local batchlog to replay later
                        if (pendingEndpoints.isEmpty())
                            logger.warn("Received base materialized view mutation for key {} that does not belong " +
                                        "to this node. There is probably a range movement happening (move or decommission)," +
                                        "but this node hasn't updated its ring metadata yet. Adding mutation to " +
                                        "local batchlog to be replayed later.",
                                        mutation.key());
                        nonPairedMutations.add(mutation);
                    }
                }

                if (!wrappers.isEmpty())
                {
                    // Apply to local batchlog memtable in this thread
                    BatchlogManager.store(Batch.createLocal(batchUUID, FBUtilities.timestampMicros(), Lists.transform(wrappers, w -> w.mutation)),
                                          writeCommitLog);

                    // now actually perform the writes and wait for them to complete
                    asyncWriteBatchedMutations(wrappers, localDataCenter, Stage.VIEW_MUTATION);
                }

                if (!nonPairedMutations.isEmpty())
                {
                    BatchlogManager.store(Batch.createLocal(batchUUID, FBUtilities.timestampMicros(), nonPairedMutations),
                                          writeCommitLog);
                }
            }
        }
        finally
        {
            viewWriteMetrics.addNano(System.nanoTime() - startTime);
        }
    }

