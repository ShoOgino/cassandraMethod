    ColumnFamilyStore(String table, String columnFamilyName, boolean isSuper, int indexValue) throws IOException
    {
        table_ = table;
        columnFamily_ = columnFamilyName;
        isSuper_ = isSuper;
        fileIndexGenerator_.set(indexValue);
        memtable_ = new Memtable(table_, columnFamily_);
        binaryMemtable_ = new AtomicReference<BinaryMemtable>(new BinaryMemtable(table_, columnFamily_));

        if (logger_.isDebugEnabled())
            logger_.debug("Starting CFS " + columnFamily_);
        // scan for data files corresponding to this CF
        List<File> sstableFiles = new ArrayList<File>();
        Pattern auxFilePattern = Pattern.compile("(.*)(-Filter\\.db$|-Index\\.db$)");
        for (File file : files())
        {
            String filename = file.getName();

            /* look for and remove orphans. An orphan is a -Filter.db or -Index.db with no corresponding -Data.db. */
            Matcher matcher = auxFilePattern.matcher(file.getAbsolutePath());
            if (matcher.matches())
            {
                String basePath = matcher.group(1);
                if (!new File(basePath + "-Data.db").exists())
                {
                    logger_.info(String.format("Removing orphan %s", file.getAbsolutePath()));
                    FileUtils.deleteWithConfirm(file);
                    continue;
                }
            }

            if (((file.length() == 0 && !filename.endsWith("-Compacted")) || (filename.contains("-" + SSTable.TEMPFILE_MARKER))))
            {
                FileUtils.deleteWithConfirm(file);
                continue;
            }

            if (filename.contains("-Data.db"))
            {
                sstableFiles.add(file.getAbsoluteFile());
            }
        }
        Collections.sort(sstableFiles, new FileUtils.FileComparator());

        /* Load the index files and the Bloom Filters associated with them. */
        List<SSTableReader> sstables = new ArrayList<SSTableReader>();
        for (File file : sstableFiles)
        {
            String filename = file.getAbsolutePath();
            if (SSTable.deleteIfCompacted(filename))
                continue;

            SSTableReader sstable;
            try
            {
                sstable = SSTableReader.open(filename);
            }
            catch (IOException ex)
            {
                logger_.error("Corrupt file " + filename + "; skipped", ex);
                continue;
            }
            sstables.add(sstable);
        }
        ssTables_ = new SSTableTracker(sstables);

        double v = DatabaseDescriptor.getRowsCachedFraction(table, columnFamilyName);
        if (v > 0)
        {
            int cacheSize;
            if (v < 1)
                cacheSize = Math.max(1, (int)(v * SSTableReader.estimatedKeys(columnFamilyName)));
            else
                cacheSize = (int)v;
            if (logger_.isDebugEnabled())
                logger_.debug("enabling row cache for " + columnFamilyName + " with size " + cacheSize);
            rowCache = new JMXInstrumentedCache<String, ColumnFamily>(table, columnFamilyName + "RowCache", cacheSize);
        }
        
        if (DatabaseDescriptor.getKeysCachedFraction(table, columnFamilyName) > 0)
        {
            // we don't need to keep a reference to the aggregator, just create it so it registers itself w/ JMX
            new JMXAggregatingCache(new Iterable<InstrumentedCache>()
            {
                public Iterator<InstrumentedCache> iterator()
                {
                    final Iterator<SSTableReader> iter = ssTables_.iterator();
                    return new AbstractIterator<InstrumentedCache>()
                    {
                        @Override
                        protected InstrumentedCache computeNext()
                        {
                            return iter.hasNext() ? iter.next().getKeyCache() : endOfData();
                        }
                    };
                }
            }, table, columnFamilyName + "KeyCache");
        }
    }

