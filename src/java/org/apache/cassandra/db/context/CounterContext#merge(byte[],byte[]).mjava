    /**
     * Return a context w/ an aggregated count for each node id.
     *
     * @param left
     *            counter context.
     * @param right
     *            counter context.
     */
    public byte[] merge(byte[] left, byte[] right)
    {
        if (left.length > right.length)
        {
            byte[] tmp = right;
            right = left;
            left = tmp;
        }

        // Compute size of result
        int size = 0;
        int leftOffset  = 0;
        int rightOffset = 0;
        while ((leftOffset < left.length) && (rightOffset < right.length))
        {
            int cmp = FBUtilities.compareByteSubArrays(left, leftOffset, right, rightOffset, idLength);
            if (cmp == 0)
            {
                ++size;
                rightOffset += stepLength;
                leftOffset += stepLength;
            }
            else if (cmp > 0)
            {
                ++size;
                rightOffset += stepLength;
            }
            else // cmp < 0
            {
                ++size;
                leftOffset += stepLength;
            }
        }
        size += (left.length  - leftOffset)  / stepLength;
        size += (right.length - rightOffset) / stepLength;

        byte[] merged = new byte[size * stepLength];

        // Do the actual merge:
        //   a) local id:  sum clocks, counts
        //   b) remote id: keep highest clock, count (reconcile)
        int mergedOffset = 0; leftOffset = 0; rightOffset = 0;
        while ((leftOffset < left.length) && (rightOffset < right.length))
        {
            int cmp = FBUtilities.compareByteSubArrays(left, leftOffset, right, rightOffset, idLength);
            if (cmp == 0)
            {
                // sum for local id, keep highest othewise
                long leftClock = FBUtilities.byteArrayToLong(left, leftOffset + idLength);
                long rightClock = FBUtilities.byteArrayToLong(right, rightOffset + idLength);
                if (FBUtilities.compareByteSubArrays(left, leftOffset, localId, 0, idLength) == 0)
                {
                    long leftCount = FBUtilities.byteArrayToLong(left, leftOffset + idLength + clockLength);
                    long rightCount = FBUtilities.byteArrayToLong(right, rightOffset + idLength + clockLength);
                    writeElementAtStepOffset(merged, mergedOffset / stepLength, localId, leftClock + rightClock, leftCount + rightCount);
                }
                else
                {
                    if (leftClock >= rightClock)
                        System.arraycopy(left, leftOffset, merged, mergedOffset, stepLength);
                    else
                        System.arraycopy(right, rightOffset, merged, mergedOffset, stepLength);
                }
                mergedOffset += stepLength;
                rightOffset += stepLength;
                leftOffset += stepLength;
            }
            else if (cmp > 0)
            {
                System.arraycopy(right, rightOffset, merged, mergedOffset, stepLength);
                mergedOffset += stepLength;
                rightOffset += stepLength;
            }
            else // cmp < 0
            {
                System.arraycopy(left, leftOffset, merged, mergedOffset, stepLength);
                mergedOffset += stepLength;
                leftOffset += stepLength;
            }
        }
        if (leftOffset < left.length)
            System.arraycopy(
                left,
                leftOffset,
                merged,
                mergedOffset,
                left.length - leftOffset);
        if (rightOffset < right.length)
            System.arraycopy(
                right,
                rightOffset,
                merged,
                mergedOffset,
                right.length - rightOffset);

        return merged;
    }

