        @Override
        public void run()
        {
            if (endpoints.isEmpty())
            {
                differencingDone.signalAll();
                logger.info("No neighbors to repair with for " + tablename + " on " + range + ": " + getName() + " completed.");
                return;
            }

            // Checking all nodes are live
            for (InetAddress endpoint : endpoints)
            {
                if (!FailureDetector.instance.isAlive(endpoint))
                {
                    differencingDone.signalAll();
                    logger.info("Could not proceed on repair because a neighbor (" + endpoint + ") is dead: " + getName() + " failed.");
                    return;
                }
            }

            AntiEntropyService.instance.sessions.put(getName(), this);
            try
            {
                // Create and queue a RepairJob for each column family
                for (String cfname : cfnames)
                    jobs.offer(new RepairJob(cfname));

                // We'll repair once by endpoints and column family
                completedLatch = new CountDownLatch(endpoints.size() * cfnames.length);

                jobs.peek().sendTreeRequests();

                // block whatever thread started this session until all requests have been returned:
                // if this thread dies, the session will still complete in the background
                completedLatch.await();
            }
            catch (InterruptedException e)
            {
                throw new RuntimeException("Interrupted while waiting for repair: repair will continue in the background.");
            }
            finally
            {
                AntiEntropyService.instance.sessions.remove(getName());
            }
        }

