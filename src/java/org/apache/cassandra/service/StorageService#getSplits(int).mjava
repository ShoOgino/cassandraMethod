    /**
     * @param splits: number of ranges to break into. Minimum 2.
     * @return list of Tokens (_not_ keys!) breaking up the data this node is responsible for into `splits` pieces.
     * There will be 1 more token than splits requested.  So for splits of 2, tokens T1 T2 T3 will be returned,
     * where (T1, T2] is the first range and (T2, T3] is the second.  The first token will always be the left
     * Token of this node's primary range, and the last will always be the Right token of that range.
     */ 
    public List<String> getSplits(int splits)
    {
        assert splits > 1;
        // we use the actual Range token for the first and last brackets of the splits to ensure correctness
        // (we're only operating on 1/128 of the keys remember)
        Range range = getLocalPrimaryRange();
        List<String> tokens = new ArrayList<String>();
        tokens.add(range.left().toString());

        List<DecoratedKey> keys = new ArrayList<DecoratedKey>();
        for (ColumnFamilyStore cfs : ColumnFamilyStore.all())
        {
            for (SSTable.KeyPosition info: cfs.allIndexPositions())
            {
                if (range.contains(info.key.token))
                    keys.add(info.key);
            }
        }
        Collections.sort(keys);

        if (keys.size() < splits)
        {
            // not enough keys to generate good splits -- generate random ones instead
            // (since this only happens when we don't have many keys, it doesn't really matter that the splits are poor)
            for (int i = 1; i < splits; i++)
            {
                tokens.add(partitioner_.getRandomToken().toString());
            }
        }
        else
        {
            for (int i = 1; i < splits; i++)
            {
                int index = i * (keys.size() / splits);
                tokens.add(keys.get(index).token.toString());
            }
        }

        tokens.add(range.right().toString());
        return tokens;
    }

