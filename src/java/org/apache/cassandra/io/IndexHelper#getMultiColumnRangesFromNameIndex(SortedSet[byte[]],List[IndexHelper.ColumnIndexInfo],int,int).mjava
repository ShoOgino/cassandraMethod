	/**
	 * Returns the sub-ranges that contain the list of columns in columnNames.
	 * @param columnNames The list of columns whose subranges need to be found
	 * @param columnIndexList the deserialized column indexes
	 * @param dataSize the total size of data
	 * @param totalNumCols the total number of columns
	 * @return a list of subranges which contain all the columns in columnNames
	 */
	static List<ColumnRange> getMultiColumnRangesFromNameIndex(SortedSet<byte[]> columnNames, List<IndexHelper.ColumnIndexInfo> columnIndexList, int dataSize, int totalNumCols)
	{
		List<ColumnRange> columnRanges = new ArrayList<ColumnRange>();

        if (columnIndexList.size() == 0)
        {
            columnRanges.add(new ColumnRange(0, dataSize, totalNumCols));
        }
        else
        {
            Map<Long, Boolean> offset = new HashMap<Long, Boolean>();
            for (byte[] name : columnNames)
            {
                IndexHelper.ColumnIndexInfo cIndexInfo = new IndexHelper.ColumnIndexInfo(name, 0, 0, (AbstractType)columnNames.comparator());
                ColumnRange columnRange = getColumnRangeFromNameIndex(cIndexInfo, columnIndexList, dataSize, totalNumCols);
                if (offset.get(columnRange.coordinate().start_) == null)
                {
                    columnRanges.add(columnRange);
                    offset.put(columnRange.coordinate().start_, true);
                }
            }
        }

        return columnRanges;
	}

