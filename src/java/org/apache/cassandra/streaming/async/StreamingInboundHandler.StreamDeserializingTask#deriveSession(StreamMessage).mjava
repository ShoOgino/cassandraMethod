        StreamSession deriveSession(StreamMessage message)
        {
            StreamSession streamSession = null;
            // StreamInitMessage starts a new channel, and IncomingStreamMessage potentially, as well.
            // IncomingStreamMessage needs a session to be established a priori, though
            if (message instanceof StreamInitMessage)
            {
                assert session == null : "initiator of stream session received a StreamInitMessage";
                StreamInitMessage init = (StreamInitMessage) message;
                StreamResultFuture.createFollower(init.sessionIndex, init.planId, init.streamOperation, init.from, channel, init.pendingRepair, init.previewKind);
                streamSession = sessionProvider.apply(new SessionIdentifier(init.from, init.planId, init.sessionIndex));
            }
            else if (message instanceof IncomingStreamMessage)
            {
                // TODO: it'd be great to check if the session actually exists before slurping in the entire stream,
                // but that's a refactoring for another day
                StreamMessageHeader header = ((IncomingStreamMessage) message).header;
                streamSession = sessionProvider.apply(new SessionIdentifier(header.sender, header.planId, header.sessionIndex));
            }

            if (streamSession == null)
                throw new IllegalStateException(createLogTag(null, channel) + " no session found for message " + message);

            // Attach this channel to the session: this only happens upon receiving the first init message as a follower;
            // in all other cases, no new control channel will be added, as the proper control channel will be already attached.
            streamSession.attachInbound(channel, message instanceof StreamInitMessage);
            return streamSession;
        }

