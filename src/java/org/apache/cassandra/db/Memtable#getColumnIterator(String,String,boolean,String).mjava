    /**
     * obtain an iterator of columns in this memtable in the specified order starting from a given column.
     */
    ColumnIterator getColumnIterator(final String key, final String cfName, final boolean isAscending, String startColumn)
    {
        ColumnFamily cf = columnFamilies_.get(key);
        final ColumnFamily columnFamily;
        if (cf != null)
            columnFamily = cf.cloneMeShallow();
        else
            columnFamily = new ColumnFamily(cfName, DatabaseDescriptor.getColumnFamilyType(cfName));

        final IColumn columns[] = (cf == null ? columnFamily : cf).getAllColumns().toArray(new IColumn[columnFamily.getAllColumns().size()]);
        // TODO if we are dealing with supercolumns, we need to clone them while we have the read lock since they can be modified later
        if (!isAscending)
            ArrayUtils.reverse(columns);
        IColumn startIColumn;
        if (DatabaseDescriptor.getColumnFamilyType(cfName).equals("Standard"))
            startIColumn = new Column(startColumn);
        else
            startIColumn = new SuperColumn(startColumn);

        // can't use a ColumnComparatorFactory comparator since those compare on both name and time (and thus will fail to match
        // our dummy column, since the time there is arbitrary).
        Comparator<IColumn> comparator = new Comparator<IColumn>()
        {
            public int compare(IColumn column1, IColumn column2)
            {
                return column1.name().compareTo(column2.name());
            }
        };
        if (!isAscending)
        {
            comparator = new ReverseComparator(comparator);
        }
        int index = Arrays.binarySearch(columns, startIColumn, comparator);
        final int startIndex = index < 0 ? -(index + 1) : index;

        return new ColumnIterator()
        {
            private int curIndex_ = startIndex;

            public ColumnFamily getColumnFamily()
            {
                return columnFamily;
            }

            public boolean hasNext()
            {
                return curIndex_ < columns.length;
            }

            public IColumn next()
            {
                return columns[curIndex_++];
            }

            public void close() throws IOException {}

            public void remove()
            {
                throw new UnsupportedOperationException();
            }
        };
    }

