    private IDiskAtomFilter makeFilter(List<ByteBuffer> variables, int limit)
    throws InvalidRequestException
    {
        if (isColumnRange())
        {
            // For sparse, we used to ask for 'defined columns' * 'asked limit' (where defined columns includes the row marker)
            // to account for the grouping of columns.
            // Since that doesn't work for maps/sets/lists, we now use the compositesToGroup option of SliceQueryFilter.
            // But we must preserve backward compatibility too (for mixed version cluster that is).
            int toGroup = cfDef.isCompact ? -1 : cfDef.columns.size();
            List<ByteBuffer> startBounds = getRequestedBound(Bound.START, variables);
            List<ByteBuffer> endBounds = getRequestedBound(Bound.END, variables);
            assert startBounds.size() == endBounds.size();

            // The case where startBounds == 1 is common enough that it's worth optimizing
            ColumnSlice[] slices;
            if (startBounds.size() == 1)
            {
                ColumnSlice slice = new ColumnSlice(startBounds.get(0), endBounds.get(0));
                if (slice.isAlwaysEmpty(cfDef.cfm.comparator, isReversed))
                    return null;
                slices = new ColumnSlice[]{slice};
            }
            else
            {
                // The IN query might not have listed the values in comparator order, so we need to re-sort
                // the bounds lists to make sure the slices works correctly
                Comparator<ByteBuffer> cmp = isReversed ? cfDef.cfm.comparator.reverseComparator : cfDef.cfm.comparator;
                Collections.sort(startBounds, cmp);
                Collections.sort(endBounds, cmp);

                List<ColumnSlice> l = new ArrayList<ColumnSlice>(startBounds.size());
                for (int i = 0; i < startBounds.size(); i++)
                {
                    ColumnSlice slice = new ColumnSlice(startBounds.get(i), endBounds.get(i));
                    if (!slice.isAlwaysEmpty(cfDef.cfm.comparator, isReversed))
                        l.add(slice);
                }
                if (l.isEmpty())
                    return null;
                slices = l.toArray(new ColumnSlice[l.size()]);
            }

            SliceQueryFilter filter = new SliceQueryFilter(slices,
                                                           isReversed,
                                                           limit,
                                                           toGroup);
            return filter;
        }
        else
        {
            SortedSet<ByteBuffer> columnNames = getRequestedColumns(variables);
            QueryProcessor.validateColumnNames(columnNames);
            return new NamesQueryFilter(columnNames, true);
        }
    }

