    private void buildMerkleTree(ColumnFamilyStore cfs, Refs<SSTableReader> sstables, Validator validator, int gcBefore)
    {
        // Create Merkle tree suitable to hold estimated partitions for given range.
        // We blindly assume that partition is evenly distributed on all sstables for now.
        long numPartitions = 0;
        for (SSTableReader sstable : sstables)
        {
            numPartitions += sstable.estimatedKeysForRanges(Collections.singleton(validator.desc.range));
        }
        // determine tree depth from number of partitions, but cap at 20 to prevent large tree.
        int depth = numPartitions > 0 ? (int) Math.min(Math.floor(Math.log(numPartitions)), 20) : 0;
        MerkleTree tree = new MerkleTree(cfs.partitioner, validator.desc.range, MerkleTree.RECOMMENDED_DEPTH, (int) Math.pow(2, depth));

        long start = System.nanoTime();
        try (AbstractCompactionStrategy.ScannerList scanners = cfs.getCompactionStrategy().getScanners(sstables, validator.desc.range))
        {
            CompactionIterable ci = new ValidationCompactionIterable(cfs, scanners.scanners, gcBefore);
            metrics.beginCompaction(ci);
            try (CloseableIterator<AbstractCompactedRow> iter = ci.iterator();)
            {
                // validate the CF as we iterate over it
                validator.prepare(cfs, tree);
                while (iter.hasNext())
                {
                    if (ci.isStopRequested())
                        throw new CompactionInterruptedException(ci.getCompactionInfo());
                    @SuppressWarnings("resource")
                    AbstractCompactedRow row = iter.next();
                    validator.add(row);
                }
                validator.complete();
            }
            catch (Exception e)
            {
                Throwables.propagate(e);
            }
            finally
            {
                metrics.finishCompaction(ci);
            }
        }

        if (logger.isDebugEnabled())
        {
            // MT serialize may take time
            long duration = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - start);
            logger.debug("Validation finished in {} msec, depth {} for {} keys, serialized size {} bytes for {}",
                         duration,
                         depth,
                         numPartitions,
                         MerkleTree.serializer.serializedSize(tree, 0),
                         validator.desc);
        }
    }

