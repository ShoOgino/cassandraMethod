    /**
     * Calculates and pushes updates to the views replicas. The replicas are determined by
     * {@link ViewUtils#getViewNaturalEndpoint(String, Token, Token)}.
     */
    public void pushViewReplicaUpdates(PartitionUpdate update, boolean writeCommitLog, AtomicLong baseComplete)
    {
        List<Mutation> mutations = null;
        TemporalRow.Set temporalRows = null;
        for (Map.Entry<String, View> view : viewsByName.entrySet())
        {
            // Make sure that we only get mutations from views which are affected since the set includes all views for a
            // keyspace. This will prevent calling getTemporalRowSet for the wrong base table.
            if (view.getValue().updateAffectsView(update))
            {
                temporalRows = view.getValue().getTemporalRowSet(update, temporalRows, false);

                Collection<Mutation> viewMutations = view.getValue().createMutations(update, temporalRows, false);
                if (viewMutations != null && !viewMutations.isEmpty())
                {
                    if (mutations == null)
                        mutations = Lists.newLinkedList();
                    mutations.addAll(viewMutations);
                }
            }
        }

        if (mutations != null)
            StorageProxy.mutateMV(update.partitionKey().getKey(), mutations, writeCommitLog, baseComplete);
    }

