        public void run()
        {
            try
            {
                activelyMeasuring = cfs;
                Memtable memtable = cfs.getMemtableThreadSafe();

                long start = System.nanoTime();
                // ConcurrentSkipListMap has cycles, so measureDeep will have to track a reference to EACH object it visits.
                // So to reduce the memory overhead of doing a measurement, we break it up to row-at-a-time.
                long deepSize = memtable.meter.measure(memtable.rows);
                int objects = 0;
                for (Map.Entry<RowPosition, AtomicSortedColumns> entry : memtable.rows.entrySet())
                {
                    deepSize += memtable.meter.measureDeep(entry.getKey()) + memtable.meter.measureDeep(entry.getValue());
                    objects += entry.getValue().getColumnCount();
                }
                double newRatio = (double) deepSize / memtable.currentSize.get();

                if (newRatio < MIN_SANE_LIVE_RATIO)
                {
                    logger.warn("setting live ratio to minimum of {} instead of {}", MIN_SANE_LIVE_RATIO, newRatio);
                    newRatio = MIN_SANE_LIVE_RATIO;
                }
                if (newRatio > MAX_SANE_LIVE_RATIO)
                {
                    logger.warn("setting live ratio to maximum of {} instead of {}", MAX_SANE_LIVE_RATIO, newRatio);
                    newRatio = MAX_SANE_LIVE_RATIO;
                }

                // we want to be very conservative about our estimate, since the penalty for guessing low is OOM
                // death.  thus, higher estimates are believed immediately; lower ones are averaged w/ the old
                if (newRatio > cfs.liveRatio)
                    cfs.liveRatio = newRatio;
                else
                    cfs.liveRatio = (cfs.liveRatio + newRatio) / 2.0;

                logger.info("{} liveRatio is {} (just-counted was {}).  calculation took {}ms for {} columns",
                            cfs, cfs.liveRatio, newRatio, TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - start), objects);
            }
            finally
            {
                activelyMeasuring = null;
                meteringInProgress.remove(cfs);
            }
        }

