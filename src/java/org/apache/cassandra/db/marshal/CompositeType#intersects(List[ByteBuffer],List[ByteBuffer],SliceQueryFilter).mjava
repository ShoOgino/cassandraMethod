    @Override
    public boolean intersects(List<ByteBuffer> minColumnNames, List<ByteBuffer> maxColumnNames, SliceQueryFilter filter)
    {
        assert minColumnNames.size() == maxColumnNames.size();

        // If any of the slices in the filter intersect, return true
        outer:
        for (ColumnSlice slice : filter.slices)
        {
            ByteBuffer[] start = split(filter.isReversed() ? slice.finish : slice.start);
            ByteBuffer[] finish = split(filter.isReversed() ? slice.start : slice.finish);

            if (compare(start, maxColumnNames, true) > 0 || compare(finish, minColumnNames, false) < 0)
                continue;  // slice does not intersect

            // We could safely return true here, but there's a minor optimization: if the first component is restricted
            // to a single value, we can check that the second component falls within the min/max for that component
            // (and repeat for all components).
            for (int i = 0; i < minColumnNames.size(); i++)
            {
                AbstractType<?> t = types.get(i);
                ByteBuffer s = i < start.length ? start[i] : ByteBufferUtil.EMPTY_BYTE_BUFFER;
                ByteBuffer f = i < finish.length ? finish[i] : ByteBufferUtil.EMPTY_BYTE_BUFFER;

                // we already know the first component falls within its min/max range (otherwise we wouldn't get here)
                if (i > 0 && !t.intersects(minColumnNames.get(i), maxColumnNames.get(i), s, f))
                    continue outer;

                // if this component isn't equal in the start and finish, we don't need to check any more
                if (i >= start.length || i >= finish.length || t.compare(s, f) != 0)
                    break;
            }
            return true;
        }

        // none of the slices intersected
        return false;
    }

