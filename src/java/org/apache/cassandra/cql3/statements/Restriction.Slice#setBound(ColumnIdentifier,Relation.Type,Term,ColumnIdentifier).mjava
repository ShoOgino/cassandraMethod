        public void setBound(ColumnIdentifier name, Relation.Type type, Term t, ColumnIdentifier previousName) throws InvalidRequestException
        {
            Bound b;
            boolean inclusive;
            switch (type)
            {
                case GT:
                    b = Bound.START;
                    inclusive = false;
                    break;
                case GTE:
                    b = Bound.START;
                    inclusive = true;
                    break;
                case LT:
                    b = Bound.END;
                    inclusive = false;
                    break;
                case LTE:
                    b = Bound.END;
                    inclusive = true;
                    break;
                default:
                    throw new AssertionError();
            }

            if (bounds[b.idx] != null)
                throw new InvalidRequestException(String.format("Invalid restrictions found on %s", name));

            bounds[b.idx] = t;
            boundInclusive[b.idx] = inclusive;

            // If a bound is part of a tuple notation (#4851), the other bound must either also be or must not be set at all,
            // and this even if there is a 2ndary index (it's not supported by the 2ndary code). And it's easier to validate
            // this here so we do.
            Bound reverse = Bound.reverse(b);
            if (hasBound(reverse) && !(Objects.equal(previousName, previous[reverse.idx])))
                throw new InvalidRequestException(String.format("Clustering column %s cannot be restricted both inside a tuple notation and outside it", name));

            previous[b.idx] = previousName;
        }

