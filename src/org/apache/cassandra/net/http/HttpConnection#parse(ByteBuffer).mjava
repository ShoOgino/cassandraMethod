    /*
     * Process the HTTP commands sent from the client. Reads
     * the socket and parses the HTTP request.
    */
    public void parse(ByteBuffer bb)
    {
        try
        {
            logger_.debug("Processing http requests from socket ...");
            switch (parseState_)
            {
                case IN_NEW:
                    parseState_ = ParseState.IN_START;
                    parseStartTime_ = System.currentTimeMillis();

                // fall through
                case IN_START:
                    if (startLineParser_.onMoreBytesNew(bb) == false)
                    {
                        break;
                    }
                    else
                    {
                        /* Already done through the callback */
                        parseState_ = ParseState.IN_HEADERS;
                    }

                // fall through
                case IN_HEADERS:
                    if (headerParser_.onMoreBytesNew(bb) == false)
                    {

                        break; // need more bytes
                    }
                    else
                    {
                        String len;
                        if (currentMsgType_ == HttpMessageType.REQUEST)
                        {
                            len = currentRequest_.getHeader(HttpProtocolConstants.CONTENT_LENGTH);

                            // find if we should close method
                            if (currentRequest_.getVersion().equalsIgnoreCase("HTTP/1.1"))
                            {
                                /*
                                 * Scan all of the headers for close messages
                                 */
                                String val = currentRequest_.getHeader(HttpProtocolConstants.CONNECTION);

                                if (val != null && val.equalsIgnoreCase(HttpProtocolConstants.CLOSE))
                                {
                                    shouldClose_ = true;
                                }
                            } else if (currentRequest_.getVersion().equalsIgnoreCase("HTTP/1.0"))
                            {
                                /* By default no keep-alive */
                                shouldClose_ = true;

                                /*
                                 * Scan all of the headers for keep-alive
                                 * messages
                                 */
                                String val = currentRequest_.getHeader(HttpProtocolConstants.CONNECTION);

                                if (val != null && val.equalsIgnoreCase(HttpProtocolConstants.KEEP_ALIVE))
                                {
                                    shouldClose_ = false;
                                }
                            } else
                            {
                                /* Assume 0.9 */
                                shouldClose_ = true;
                            }
                        }
                        else if (currentMsgType_ == HttpMessageType.RESPONSE)
                        {
                            len = currentResponse_.getHeader(HttpProtocolConstants.CONTENT_LENGTH);

                        // TODO: pay attention to keep-alive and
                        // close headers
                        }
                        else
                        {
                            logger_.warn("in HttpConnection::processInput_() Message type is not set");
                            return;
                        }

                        if (len != null)
                        {
                            try
                            {
                                if(len == null || len.equals(""))
                                    contentLength_ = 0;
                                else
                                    contentLength_ = Integer.parseInt(len);
                            }
                            catch (NumberFormatException ex)
                            {
                                throw new HttpParsingException();
                            }
                        }
                        parseState_ = ParseState.IN_BODY;
                    }

                // fall through
                case IN_BODY:
                    boolean done = false;

                    if (contentLength_ > 0)
                    {
                        if (bb.remaining() > contentLength_)
                        {
                            int newLimit = bb.position() + contentLength_;
                            bodyBuffers_.add(((ByteBuffer) bb.duplicate().limit(newLimit)).slice());
                            bb.position(newLimit);
                            contentLength_ = 0;
                        }
                        else
                        {
                            contentLength_ -= bb.remaining();
                            bodyBuffers_.add(bb.duplicate());
                            bb.position(bb.limit());
                        }
                    }

                if (contentLength_ == 0)
                {
                    done = true;
                }

                if (done)
                {
                    if (currentMsgType_ == HttpMessageType.REQUEST)
                    {
                        //currentRequest_.setParseTime(env_.getCurrentTime() - parseStartTime_);
                        currentRequest_.setBody(bodyBuffers_);

                        if (currentRequest_.getHeader("Content-Type") == null)
                        {
                            currentRequest_.addHeader("Content-Type", defaultContentType_);
                        }

                        handleRequest(currentRequest_);
                    }
                    else if (currentMsgType_ == HttpMessageType.RESPONSE)
                    {
                        logger_.info("Holy shit! We are not supposed to be here - ever !!!");
                    }
                    else
                    {
                        logger_.error("Http message type is still" +
                                " unset after we finish parsing the body?");
                    }

                    resetParserState();
                }
            }

        }
        catch (final Throwable e)
        {
            logger_.warn(LogUtil.throwableToString(e));
            //close();
        }
        finally
        {
            httpKey_.interestOps(httpKey_.interestOps() | SelectionKey.OP_READ);
        }
    }

