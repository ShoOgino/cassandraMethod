    /**
     * No locking required since it is called from a method that already
     * has acquired a lock. The gossip digest is built based on randomization
     * rather than just looping through the collection of live endpoints.
     *
     * @param gDigests list of Gossip Digests.
    */
    void makeRandomGossipDigest(List<GossipDigest> gDigests)
    {
        /* Add the local endpoint state */
        EndPointState epState = endPointStateMap_.get(localEndPoint_);
        int generation = epState.getHeartBeatState().getGeneration();
        int maxVersion = getMaxEndPointStateVersion(epState);
        gDigests.add( new GossipDigest(localEndPoint_, generation, maxVersion) );

        List<InetAddress> endpoints = new ArrayList<InetAddress>( liveEndpoints_ );
        Collections.shuffle(endpoints, random_);
        for ( InetAddress liveEndPoint : endpoints )
        {
            epState = endPointStateMap_.get(liveEndPoint);
            if ( epState != null )
            {
                generation = epState.getHeartBeatState().getGeneration();
                maxVersion = getMaxEndPointStateVersion(epState);
                gDigests.add( new GossipDigest(liveEndPoint, generation, maxVersion) );
            }
            else
            {
            	gDigests.add( new GossipDigest(liveEndPoint, 0, 0) );
            }
        }

        /* FOR DEBUG ONLY - remove later */
        StringBuilder sb = new StringBuilder();
        for ( GossipDigest gDigest : gDigests )
        {
            sb.append(gDigest);
            sb.append(" ");
        }
        if (logger_.isTraceEnabled())
            logger_.trace("Gossip Digests are : " + sb.toString());
    }

