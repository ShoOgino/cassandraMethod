    public static SCFilter sliceFilterToSC(CellNameType type, SliceQueryFilter filter)
    {
        /*
         * There is 3 main cases that we can translate back into super column
         * queries:
         *   1) We have only one slice where the first component of start and
         *   finish is the same, we translate as a slice query on one SC.
         *   2) We have only one slice, neither the start and finish have a 2nd
         *   component, and end has the 'end of component' set, we translate
         *   as a slice of SCs.
         *   3) Each slice has the same first component for start and finish, no
         *   2nd component and each finish has the 'end of component' set, we
         *   translate as a names query of SCs (the filter must then not be reversed).
         * Otherwise, we can't do much.
         */

        boolean reversed = filter.reversed;
        if (filter.slices.length == 1)
        {
            Composite start = filter.slices[0].start;
            Composite finish = filter.slices[0].start;

            if (filter.compositesToGroup == 1)
            {
                // Note: all the resulting filter must have compositeToGroup == 0 because this
                // make no sense for super column on the destination node otherwise
                if (start.isEmpty())
                {
                    if (finish.isEmpty())
                        // An 'IdentityFilter', keep as is (except for the compositeToGroup)
                        return new SCFilter(null, new SliceQueryFilter(filter.start(), filter.finish(), reversed, filter.count));

                    if (subName(finish) == null
                            && ((!reversed && !isEndOfRange(finish)) || (reversed && isEndOfRange(finish))))
                        return new SCFilter(null, new SliceQueryFilter(Composites.EMPTY, CellNames.simpleDense(scName(finish)), reversed, filter.count));
                }
                else if (finish.isEmpty())
                {
                    if (subName(start) == null
                            && ((!reversed && isEndOfRange(start)) || (reversed && !isEndOfRange(start))))
                        return new SCFilter(null, new SliceQueryFilter(CellNames.simpleDense(scName(start)), Composites.EMPTY, reversed, filter.count));
                }
                else if (subName(start) == null && subName(finish) == null
                        && ((   reversed && !isEndOfRange(start) && isEndOfRange(finish))
                            || (!reversed &&  isEndOfRange(start) && !isEndOfRange(finish))))
                {
                    // A slice of supercolumns
                    return new SCFilter(null, new SliceQueryFilter(CellNames.simpleDense(scName(start)),
                                                                   CellNames.simpleDense(scName(finish)),
                                                                   reversed,
                                                                   filter.count));
                }
            }
            else if (filter.compositesToGroup == 0 && type.subtype(0).compare(scName(start), scName(finish)) == 0)
            {
                // A slice of subcolumns
                return new SCFilter(scName(start), filter.withUpdatedSlice(CellNames.simpleDense(subName(start)), CellNames.simpleDense(subName(finish))));
            }
        }
        else if (!reversed)
        {
            SortedSet<CellName> columns = new TreeSet<CellName>(scType(type));
            for (int i = 0; i < filter.slices.length; ++i)
            {
                Composite start = filter.slices[i].start;
                Composite finish = filter.slices[i].finish;

                if (subName(start) != null || subName(finish) != null
                  || type.subtype(0).compare(scName(start), scName(finish)) != 0
                  || isEndOfRange(start) || !isEndOfRange(finish))
                    throw new RuntimeException("Cannot convert filter to old super column format. Update all nodes to Cassandra 2.0 first.");

                columns.add(CellNames.simpleDense(scName(start)));
            }
            return new SCFilter(null, new NamesQueryFilter(columns));
        }
        throw new RuntimeException("Cannot convert filter to old super column format. Update all nodes to Cassandra 2.0 first.");
    }

