    @Before
    public void setUp()
    {
        RequestSchedulerOptions options = new RequestSchedulerOptions();
        // Block the scheduler from running initially
        options.throttle_limit = -1;
        scheduler = new RoundRobinScheduler(options);
        SynchronousQueue<Runnable> queue = new SynchronousQueue<Runnable>();

        executor = new ThreadPoolExecutor(20,
                                          Integer.MAX_VALUE,
                                          60*1000,
                                          TimeUnit.MILLISECONDS,
                                          queue);
        // When there are large no. of threads, the results become
        // more unpredictable because of the JVM thread scheduling
        // and that will be very hard to provide a consistent test
        runKs1(1, 10);
        runKs2(11, 13);
        runKs3(14, 15);
        // Release some tasks for the scheduler to run, now that the requests
        // are queued in their various buckets, behavior will be more predictable
        scheduler.getTaskCount().release(2);
        try
        {
            Thread.sleep(3000);
        }
        catch (InterruptedException e)
        {
            throw new AssertionError(e);
        }
    }

