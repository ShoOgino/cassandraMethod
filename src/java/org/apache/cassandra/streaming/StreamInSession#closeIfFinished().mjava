    public void closeIfFinished() throws IOException
    {
        if (files.isEmpty())
        {
            // wait for bloom filters and row indexes to finish building
            HashMap <ColumnFamilyStore, List<SSTableReader>> cfstores = new HashMap<ColumnFamilyStore, List<SSTableReader>>();
            List<SSTableReader> referenced = new LinkedList<SSTableReader>();
            try
            {
                for (SSTableReader sstable : readers)
                {
                    assert sstable.getTableName().equals(table);

                    // Acquiring the reference (for secondary index building) before adding it makes sure we don't have to care about races
                    sstable.acquireReference();
                    referenced.add(sstable);

                    ColumnFamilyStore cfs = Table.open(sstable.getTableName()).getColumnFamilyStore(sstable.getColumnFamilyName());
                    cfs.addSSTable(sstable);
                    if (!cfstores.containsKey(cfs))
                        cfstores.put(cfs, new ArrayList<SSTableReader>());
                    cfstores.get(cfs).add(sstable);
                }

                // build secondary indexes
                for (Map.Entry<ColumnFamilyStore, List<SSTableReader>> entry : cfstores.entrySet())
                {
                    if (entry.getKey() != null)
                        entry.getKey().indexManager.buildSecondaryIndexes(entry.getValue(), entry.getKey().indexManager.getIndexedColumns());
                }
            }
            finally
            {
                SSTableReader.releaseReferences(referenced);
            }

            // send reply to source that we're done
            StreamReply reply = new StreamReply("", getSessionId(), StreamReply.Status.SESSION_FINISHED);
            logger.info("Finished streaming session {} from {}", getSessionId(), getHost());
            MessagingService.instance().sendOneWay(reply.getMessage(Gossiper.instance.getVersion(getHost())), getHost());

            if (callback != null)
                callback.run();
            sessions.remove(context);
        }
    }

