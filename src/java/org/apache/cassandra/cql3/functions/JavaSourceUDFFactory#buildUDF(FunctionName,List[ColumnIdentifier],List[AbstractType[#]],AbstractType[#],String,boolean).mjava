    static UDFunction buildUDF(FunctionName name,
                               List<ColumnIdentifier> argNames,
                               List<AbstractType<?>> argTypes,
                               AbstractType<?> returnType,
                               String body,
                               boolean deterministic)
    throws InvalidRequestException
    {
        // argDataTypes is just the C* internal argTypes converted to the Java Driver DataType
        DataType[] argDataTypes = UDHelper.driverTypes(argTypes);
        // returnDataType is just the C* internal returnType converted to the Java Driver DataType
        DataType returnDataType = UDHelper.driverType(returnType);
        // javaParamTypes is just the Java representation for argTypes resp. argDataTypes
        Class<?>[] javaParamTypes = UDHelper.javaTypes(argDataTypes);
        // javaReturnType is just the Java representation for returnType resp. returnDataType
        Class<?> javaReturnType = returnDataType.asJavaClass();

        String clsName = generateClassName(name);

        String codeCtor = generateConstructor(clsName);

        // Generate 'execute' method (implements org.apache.cassandra.cql3.functions.Function.execute)
        String codeExec = generateExecuteMethod(argNames, javaParamTypes);

        // Generate the 'executeInternal' method
        // It is separated to allow return type and argument type checks during compile time via javassist.
        String codeExecInt = generateExecuteInternalMethod(argNames, body, javaReturnType, javaParamTypes);

        logger.debug("Generating java source UDF for {} with following c'tor and functions:\n{}\n{}\n{}",
                     name, codeCtor, codeExecInt, codeExec);

        try
        {
            ClassPool classPool = ClassPool.getDefault();

            // get super class
            CtClass base = classPool.get(UDFunction.class.getName());

            // prepare class to generate
            CtClass cc = classPool.makeClass(GENERATED_CODE_PACKAGE + clsName, base);
            cc.setModifiers(cc.getModifiers() | Modifier.FINAL);

            // add c'tor plus methods (order matters)
            cc.addConstructor(CtNewConstructor.make(codeCtor, cc));
            cc.addMethod(CtNewMethod.make(codeExecInt, cc));
            cc.addMethod(CtNewMethod.make(codeExec, cc));

            Constructor ctor =
                cc.toClass().getDeclaredConstructor(
                   FunctionName.class, List.class, List.class, DataType[].class,
                   AbstractType.class, DataType.class,
                   String.class, boolean.class);
            return (UDFunction) ctor.newInstance(
                   name, argNames, argTypes, argDataTypes,
                   returnType, returnDataType,
                   body, deterministic);
        }
        catch (NotFoundException | CannotCompileException | NoSuchMethodException | LinkageError | InstantiationException | IllegalAccessException e)
        {
            throw new InvalidRequestException(String.format("Could not compile function '%s' from Java source: %s", name, e));
        }
        catch (InvocationTargetException e)
        {
            // in case of an ITE, use the cause
            throw new InvalidRequestException(String.format("Could not compile function '%s' from Java source: %s", name, e.getCause()));
        }
    }

