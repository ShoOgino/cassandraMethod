    /**
     * @return Mutation which is the transformed base table mutation for the view.
     */
    private PartitionUpdate createUpdatesForInserts(TemporalRow temporalRow)
    {
        TemporalRow.Resolver resolver = TemporalRow.latest;

        DecoratedKey partitionKey = viewPartitionKey(temporalRow, resolver);
        CFMetaData viewCfm = definition.metadata;

        if (partitionKey == null)
        {
            // Not having a partition key means we aren't updating anything
            return null;
        }

        Row.Builder regularBuilder = BTreeRow.unsortedBuilder(temporalRow.nowInSec);

        CBuilder clustering = CBuilder.create(viewCfm.comparator);
        for (int i = 0; i < viewCfm.clusteringColumns().size(); i++)
        {
            clustering.add(temporalRow.clusteringValue(viewCfm.clusteringColumns().get(i), resolver));
        }
        regularBuilder.newRow(clustering.build());
        regularBuilder.addPrimaryKeyLivenessInfo(LivenessInfo.create(viewCfm,
                                                                     temporalRow.viewClusteringTimestamp(),
                                                                     temporalRow.viewClusteringTtl(),
                                                                     temporalRow.viewClusteringLocalDeletionTime()));

        for (ColumnDefinition columnDefinition : viewCfm.allColumns())
        {
            if (columnDefinition.isPrimaryKeyColumn())
                continue;

            for (Cell cell : temporalRow.values(columnDefinition, resolver))
            {
                regularBuilder.addCell(cell);
            }
        }

        return PartitionUpdate.singleRowUpdate(viewCfm, partitionKey, regularBuilder.build());
    }

