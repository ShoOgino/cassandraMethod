    /**
     * compute all ranges we're going to query, in sorted order, so that we get the correct results back.
     *  1) computing range intersections is necessary because nodes can be replica destinations for many ranges,
     *     so if we do not restrict each scan to the specific range we want we will get duplicate results.
     *  2) sorting the intersection ranges is necessary because wraparound node ranges can be discontiguous.
     *     Consider a 2-node ring, (D, T] and (T, D]. A query for [A, Z] will intersect the 2nd node twice,
     *     at [A, D] and (T, Z]. We need to scan the (D, T] range in between those, or we will skip those
     *     results entirely if the limit is low enough.
     *  3) we unwrap the intersection ranges because otherwise we get results in the wrong order.
     *     Consider a 2-node ring, (D, T] and (T, D].  A query for [D, Z] will get results in the wrong
     *     order if we use (T, D] directly -- we need to start with that range, because our query starts with
     *     D, but we don't want any other results from it until after the (D, T] range.  Unwrapping so that
     *     the ranges we consider are (D, T], (T, MIN], (MIN, D] fixes this.
     */
    private static List<AbstractBounds> getRestrictedRanges(final AbstractBounds queryRange)
    {
        TokenMetadata tokenMetadata = StorageService.instance.getTokenMetadata();

        if (logger.isDebugEnabled())
            logger.debug("computing restricted ranges for query " + queryRange);

        List<AbstractBounds> ranges = new ArrayList<AbstractBounds>();
        // for each node, compute its intersection with the query range, and add its unwrapped components to our list
        for (Token nodeToken : tokenMetadata.sortedTokens())
        {
            Range nodeRange = new Range(tokenMetadata.getPredecessor(nodeToken), nodeToken);
            for (AbstractBounds range : queryRange.restrictTo(nodeRange))
            {
                for (AbstractBounds unwrapped : range.unwrap())
                {
                    if (logger.isDebugEnabled())
                        logger.debug("Adding to restricted ranges " + unwrapped + " for " + nodeRange);
                    ranges.add(unwrapped);
                }
            }
        }

        // re-sort ranges in ring order, post-unwrapping
        Comparator<AbstractBounds> comparator = new Comparator<AbstractBounds>()
        {
            // no restricted ranges will overlap so we don't need to worry about inclusive vs exclusive left,
            // just sort by raw token position.
            public int compare(AbstractBounds o1, AbstractBounds o2)
            {
                // sort in order that the original query range would see them.
                int queryOrder1 = queryRange.left.compareTo(o1.left);
                int queryOrder2 = queryRange.left.compareTo(o2.left);

                // check for exact match with query start
                assert !(queryOrder1 == 0 && queryOrder2 == 0);
                if (queryOrder1 == 0)
                    return -1;
                if (queryOrder2 == 0)
                    return 1;

                // order segments in order they should be traversed
                if (queryOrder1 < queryOrder2)
                    return -1; // o1 comes after query start, o2 wraps to after
                if (queryOrder1 > queryOrder2)
                    return 1; // o2 comes after query start, o1 wraps to after
                return o1.left.compareTo(o2.left); // o1 and o2 are on the same side of query start
            }
        };
        Collections.sort(ranges, comparator);
        if (logger.isDebugEnabled())
            logger.debug("Sorted ranges are [" + StringUtils.join(ranges, ", ") + "]");

        return ranges;
    }

