    /**
     * Split out files for all tables on disk locally for each range and then stream them to the target endpoint.
    */
    public static void transferRanges(InetAddress target, String tableName, Collection<Range> ranges, Runnable callback)
    {
        assert ranges.size() > 0;
        
        // this is so that this target shows up as a destination while anticompaction is happening.
        StreamOutManager.pendingDestinations.add(target);

        logger.debug("Beginning transfer process to " + target + " for ranges " + StringUtils.join(ranges, ", "));

        /*
         * (1) dump all the memtables to disk.
         * (2) anticompaction -- split out the keys in the range specified
         * (3) transfer the data.
        */
        try
        {
            Table table = Table.open(tableName);
            updateStatus("Flushing memtables for " + tableName + "...");
            for (Future f : table.flush())
            {
                try
                {
                    f.get();
                }
                catch (InterruptedException e)
                {
                    throw new RuntimeException(e);
                }
                catch (ExecutionException e)
                {
                    throw new RuntimeException(e);
                }
            }
            updateStatus("Performing anticompaction ...");
            /* Get the list of files that need to be streamed */
            transferSSTables(target, table.forceAntiCompaction(ranges, target), tableName); // SSTR GC deletes the file when done
        }
        catch (IOException e)
        {
            throw new IOError(e);
        }
        finally
        {
            StreamingService.instance.setStatus(StreamingService.NOTHING);
            StreamOutManager.remove(target);
        }
        if (callback != null)
            callback.run();
    }

