    public void append(DecoratedKey decoratedKey, ColumnFamily cf)
    {
        long startPosition = beforeAppend(decoratedKey);
        try
        {
            ByteBufferUtil.writeWithShortLength(decoratedKey.key, dataFile.stream);

            // Since the columnIndex may insert RangeTombstone marker, computing
            // the size of the data is tricky.
            DataOutputBuffer buffer = new DataOutputBuffer();

            // build column index && write columns
            ColumnIndex.Builder builder = new ColumnIndex.Builder(cf, decoratedKey.key, cf.getColumnCount(), buffer);
            ColumnIndex index = builder.build(cf);

            TypeSizes typeSizes = TypeSizes.NATIVE;
            long delSize = DeletionTime.serializer.serializedSize(cf.deletionInfo().getTopLevelDeletion(), typeSizes);
            dataFile.stream.writeLong(buffer.getLength() + delSize + typeSizes.sizeof(0));

            // Write deletion infos + column count
            DeletionInfo.serializer().serializeForSSTable(cf.deletionInfo(), dataFile.stream);
            dataFile.stream.writeInt(builder.writtenAtomCount());
            dataFile.stream.write(buffer.getData(), 0, buffer.getLength());
            afterAppend(decoratedKey, startPosition, cf.deletionInfo(), index);
            sstableMetadataCollector.update(dataFile.getFilePointer() - startPosition, cf.getColumnStats());
        }
        catch (IOException e)
        {
            throw new FSWriteError(e, dataFile.getPath());
        }
    }

