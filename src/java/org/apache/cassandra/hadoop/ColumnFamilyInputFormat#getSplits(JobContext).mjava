    public List<InputSplit> getSplits(JobContext context) throws IOException
    {
        Configuration conf = context.getConfiguration();
        keyspace = conf.get(KEYSPACE_CONFIG);
        columnFamily = conf.get(COLUMNFAMILY_CONFIG);
        predicate = predicateFromString(conf.get(PREDICATE_CONFIG));
        validateConfiguration();

        // cannonical ranges and nodes holding replicas
        List<TokenRange> masterRangeNodes = getRangeMap();

        int splitsize = context.getConfiguration().getInt(INPUT_SPLIT_SIZE_CONFIG, 16384);
        
        // cannonical ranges, split into pieces:
        // for each range, pick a live owner and ask it to compute bite-sized splits
        // TODO parallelize this thread-per-range
        Map<TokenRange, List<String>> splitRanges = new HashMap<TokenRange, List<String>>();
        for (TokenRange range : masterRangeNodes)
        {
            splitRanges.put(range, getSubSplits(range, splitsize));
        }

        // turn the sub-ranges into InputSplits
        ArrayList<InputSplit> splits = new ArrayList<InputSplit>();
        for (Map.Entry<TokenRange, List<String>> entry : splitRanges.entrySet())
        {
            TokenRange range = entry.getKey();
            List<String> tokens = entry.getValue();
            String[] endpoints = range.endpoints.toArray(new String[range.endpoints.size()]);

            int i = 1;
            for ( ; i < tokens.size(); i++)
            {
                ColumnFamilySplit split = new ColumnFamilySplit(keyspace, columnFamily, predicate, tokens.get(i - 1), tokens.get(i), endpoints);
                logger.debug("adding " + split);
                splits.add(split);
            }
        }
        assert splits.size() > 0;
        
        return splits;
    }

