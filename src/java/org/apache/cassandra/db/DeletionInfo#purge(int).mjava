    /**
     * Return a new DeletionInfo correspond to purging every tombstones that
     * are older than {@code gcbefore}.
     *
     * @param gcBefore timestamp (in seconds) before which tombstones should
     * be purged
     * @return a new DeletionInfo with the purged info remove. Should return
     * DeletionInfo.LIVE if no tombstones remain.
     */
    public DeletionInfo purge(int gcBefore)
    {
        if (ranges.isEmpty())
        {
            return topLevel.localDeletionTime < gcBefore ? LIVE : this;
        }
        else
        {
            // We rebuild a new intervalTree that contains only non expired range tombstones
            List<RangeTombstone> nonExpired = new ArrayList<RangeTombstone>();
            for (RangeTombstone range : ranges)
            {
                if (range.data.localDeletionTime >= gcBefore)
                    nonExpired.add(range);
            }
            IntervalTree<ByteBuffer, DeletionTime, RangeTombstone> newRanges = nonExpired.size() == ranges.intervalCount()
                                                                             ? ranges
                                                                             : IntervalTree.build(nonExpired, ranges.comparator());
            return topLevel.localDeletionTime < gcBefore
                 ? new DeletionInfo(DeletionTime.LIVE, newRanges)
                 : new DeletionInfo(topLevel, newRanges);
        }
    }

