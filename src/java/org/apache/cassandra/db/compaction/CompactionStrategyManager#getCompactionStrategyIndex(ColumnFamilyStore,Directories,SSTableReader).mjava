    /**
     * Get the correct compaction strategy for the given sstable. If the first token starts within a disk boundary, we
     * will add it to that compaction strategy.
     *
     * In the case we are upgrading, the first compaction strategy will get most files - we do not care about which disk
     * the sstable is on currently (unless we don't know the local tokens yet). Once we start compacting we will write out
     * sstables in the correct locations and give them to the correct compaction strategy instance.
     *
     * @param cfs
     * @param locations
     * @param sstable
     * @return
     */
    public static int getCompactionStrategyIndex(ColumnFamilyStore cfs, Directories locations, SSTableReader sstable)
    {
        if (!cfs.getPartitioner().splitter().isPresent())
            return 0;

        List<PartitionPosition> boundaries = StorageService.getDiskBoundaries(cfs, locations.getWriteableLocations());
        if (boundaries == null)
        {
            Directories.DataDirectory[] directories = locations.getWriteableLocations();

            // try to figure out location based on sstable directory:
            for (int i = 0; i < directories.length; i++)
            {
                Directories.DataDirectory directory = directories[i];
                if (sstable.descriptor.directory.getAbsolutePath().startsWith(directory.location.getAbsolutePath()))
                    return i;
            }
            return 0;
        }

        int pos = Collections.binarySearch(boundaries, sstable.first);
        assert pos < 0; // boundaries are .minkeybound and .maxkeybound so they should never be equal
        return -pos - 1;
    }

