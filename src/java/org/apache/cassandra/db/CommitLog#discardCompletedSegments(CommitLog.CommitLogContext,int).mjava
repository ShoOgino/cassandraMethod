    /*
     * Delete log segments whose contents have been turned into SSTables.
     *
     * param @ cLogCtx The commitLog context .
     * param @ id id of the columnFamily being flushed to disk.
     *
    */
    private void discardCompletedSegments(CommitLog.CommitLogContext cLogCtx, int id) throws IOException
    {
        if (logger_.isDebugEnabled())
            logger_.debug("discard completed log segments for " + cLogCtx + ", column family " + id + ". CFIDs are " + Table.TableMetadata.getColumnFamilyIDString());
        /* retrieve the commit log header associated with the file in the context */
        if (clHeaders_.get(cLogCtx.file) == null)
        {
            if (logFile_.equals(cLogCtx.file))
            {
                /* this means we are dealing with the current commit log. */
                clHeaders_.put(cLogCtx.file, clHeader_);
            }
            else
            {
                logger_.error("Unknown commitlog file " + cLogCtx.file);
                return;
            }
        }

        /*
         * log replay assumes that we only have to look at entries past the last
         * flush position, so verify that this flush happens after the last.
        */
        assert cLogCtx.position >= clHeaders_.get(cLogCtx.file).getPosition(id);

        /* Sort the commit logs based on creation time */
        List<String> oldFiles = new ArrayList<String>(clHeaders_.keySet());
        Collections.sort(oldFiles, new CommitLogFileComparator());

        /*
         * Loop through all the commit log files in the history. Now process
         * all files that are older than the one in the context. For each of
         * these files the header needs to modified by resetting the dirty
         * bit corresponding to the flushed CF.
        */
        for (String oldFile : oldFiles)
        {
            CommitLogHeader header = clHeaders_.get(oldFile);
            if (oldFile.equals(cLogCtx.file))
            {
                // we can't just mark the segment where the flush happened clean,
                // since there may have been writes to it between when the flush
                // started and when it finished. so mark the flush position as
                // the replay point for this CF, instead.
                if (logger_.isDebugEnabled())
                    logger_.debug("Marking replay position " + cLogCtx.position + " on commit log " + oldFile);
                header.turnOn(id, cLogCtx.position);
                if (oldFile.equals(logFile_))
                {
                    seekAndWriteCommitLogHeader(header.toByteArray());
                }
                else
                {
                    writeOldCommitLogHeader(oldFile, header);
                }
                break;
            }

            header.turnOff(id);
            if (header.isSafeToDelete())
            {
                logger_.info("Deleting obsolete commit log:" + oldFile);
                FileUtils.deleteAsync(oldFile);
                clHeaders_.remove(oldFile);
            }
            else
            {
                if (logger_.isDebugEnabled())
                    logger_.debug("Not safe to delete commit log " + oldFile + "; dirty is " + header.dirtyString());
                writeOldCommitLogHeader(oldFile, header);
            }
        }
    }

