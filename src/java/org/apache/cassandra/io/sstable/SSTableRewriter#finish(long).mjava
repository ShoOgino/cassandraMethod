    /**
     * Finishes the new file(s)
     *
     * Creates final files, adds the new files to the dataTracker (via replaceReader).
     *
     * We add them to the tracker to be able to get rid of the tmpfiles
     *
     * It is up to the caller to do the compacted sstables replacement
     * gymnastics (ie, call DataTracker#markCompactedSSTablesReplaced(..))
     *
     *
     * @param repairedAt the repair time, -1 if we should use the time we supplied when we created
     *                   the SSTableWriter (and called rewriter.switchWriter(..)), actual time if we want to override the
     *                   repair time.
     */
    public List<SSTableReader> finish(long repairedAt)
    {
        List<Pair<SSTableReader, SSTableReader>> toReplace = new ArrayList<>();
        switchWriter(null);
        // make real sstables of the written ones:
        Iterator<Pair<SSTableWriter, SSTableReader>> it = finishedWriters.iterator();
        while(it.hasNext())
        {
            Pair<SSTableWriter, SSTableReader> w = it.next();
            if (w.left.getFilePointer() > 0)
            {
                SSTableReader newReader = repairedAt < 0 ? w.left.closeAndOpenReader(maxAge) : w.left.closeAndOpenReader(maxAge, repairedAt);
                finished.add(newReader);

                if (w.right != null)
                    w.right.sharesBfWith(newReader);
                // w.right is the tmplink-reader we added when switching writer, replace with the real sstable.
                toReplace.add(Pair.create(w.right, newReader));
            }
            else
            {
                assert w.right == null;
                w.left.abort(true);
            }
            it.remove();
        }

        for (Pair<SSTableReader, SSTableReader> replace : toReplace)
            replaceEarlyOpenedFile(replace.left, replace.right);

        if (!isOffline)
        {
            dataTracker.unmarkCompacting(finished);
        }
        return finished;
    }

