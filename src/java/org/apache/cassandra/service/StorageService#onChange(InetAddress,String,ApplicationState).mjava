    /*
     * onChange only ever sees one ApplicationState piece change at a time, so we perform a kind of state machine here.
     * We are concerned with two events: knowing the token associated with an enpoint, and knowing its operation mode.
     * Nodes can start in either bootstrap or normal mode, and from bootstrap mode can change mode to normal.
     * A node in bootstrap mode needs to have pendingranges set in TokenMetadata; a node in normal mode
     * should instead be part of the token ring.
     */
    public void onChange(InetAddress endpoint, String stateName, ApplicationState state)
    {
        if (STATE_BOOTSTRAPPING.equals(stateName))
        {
            Token token = getPartitioner().getTokenFactory().fromString(state.getValue());
            if (logger_.isDebugEnabled())
                logger_.debug(endpoint + " state bootstrapping, token " + token);
            updateBootstrapRanges(token, endpoint);
        }
        else if (STATE_NORMAL.equals(stateName))
        {
            Token token = getPartitioner().getTokenFactory().fromString(state.getValue());
            if (logger_.isDebugEnabled())
                logger_.debug(endpoint + " state normal, token " + token);
            updateForeignToken(token, endpoint);
            replicationStrategy_.removeObsoletePendingRanges();
        }
        else if (STATE_LEAVING.equals(stateName))
        {
            Token token = getPartitioner().getTokenFactory().fromString(state.getValue());
            assert tokenMetadata_.getToken(endpoint).equals(token);
            updateLeavingRanges(endpoint);
        }
        else if (STATE_LEFT.equals(stateName))
        {
            Token token = getPartitioner().getTokenFactory().fromString(state.getValue());
            assert tokenMetadata_.getToken(endpoint).equals(token);
            tokenMetadata_.removeEndpoint(endpoint);
            replicationStrategy_.removeObsoletePendingRanges();
        }
    }

