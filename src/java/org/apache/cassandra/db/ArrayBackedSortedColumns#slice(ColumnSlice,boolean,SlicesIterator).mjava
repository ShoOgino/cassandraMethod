    /**
     * @return a sub-range of our cells as an Iterator, between the provided composites (inclusive)
     *
     * @param slice  The slice with the inclusive start and finish bounds
     * @param invert If the sort order of our collection is opposite to the desired sort order of the result;
     *               this results in swapping the start/finish (since they are provided based on the desired
     *               sort order, not our sort order), to normalise to our sort order, and a backwards iterator is returned
     * @param iter   If this slice is part of a multi-slice, the iterator will be updated to ensure cells are visited only once
     */
    private Iterator<Cell> slice(ColumnSlice slice, boolean invert, SlicesIterator iter)
    {
        Composite start = invert ? slice.finish : slice.start;
        Composite finish = invert ? slice.start : slice.finish;

        int lowerBound = 0, upperBound = size;
        if (iter != null)
        {
            if (invert)
                upperBound = iter.previousSliceEnd;
            else
                lowerBound = iter.previousSliceEnd;
        }

        if (!start.isEmpty())
        {
            lowerBound = binarySearch(lowerBound, upperBound, start, internalComparator());
            if (lowerBound < 0)
                lowerBound = -lowerBound - 1;
        }

        if (!finish.isEmpty())
        {
            upperBound = binarySearch(lowerBound, upperBound, finish, internalComparator());
            upperBound = upperBound < 0
                       ? -upperBound - 1
                       : upperBound + 1; // upperBound is exclusive for the iterators
        }

        // If we're going backwards (wrt our sort order) we store the startIdx and use it as our upper bound next round
        if (iter != null)
            iter.previousSliceEnd = invert ? lowerBound : upperBound;

        return invert
             ? new BackwardsCellIterator(lowerBound, upperBound)
             : new ForwardsCellIterator(lowerBound, upperBound);
    }

