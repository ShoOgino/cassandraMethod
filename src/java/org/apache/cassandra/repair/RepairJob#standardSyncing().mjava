    private AsyncFunction<List<TreeResponse>, List<SyncStat>> standardSyncing()
    {
        return trees ->
        {
            InetAddressAndPort local = FBUtilities.getLocalAddressAndPort();

            List<AbstractSyncTask> syncTasks = new ArrayList<>();
            // We need to difference all trees one against another
            for (int i = 0; i < trees.size() - 1; ++i)
            {
                TreeResponse r1 = trees.get(i);
                for (int j = i + 1; j < trees.size(); ++j)
                {
                    TreeResponse r2 = trees.get(j);

                    if (isTransient(r1.endpoint) && isTransient(r2.endpoint))
                        continue;

                    AbstractSyncTask task;
                    if (r1.endpoint.equals(local) || r2.endpoint.equals(local))
                    {
                        InetAddressAndPort remote = r1.endpoint.equals(local) ? r2.endpoint : r1.endpoint;
                        task = new SymmetricLocalSyncTask(desc, r1, r2, isTransient(remote), isIncremental ? desc.parentSessionId : null, session.pullRepair, session.previewKind);
                    }
                    else if (isTransient(r1.endpoint) || isTransient(r2.endpoint))
                    {
                        TreeResponse streamFrom = isTransient(r1.endpoint) ? r1 : r2;
                        TreeResponse streamTo = isTransient(r1.endpoint) ? r2: r1;
                        task = new AsymmetricRemoteSyncTask(desc, streamTo, streamFrom, previewKind);
                        session.waitForSync(Pair.create(desc, new NodePair(streamTo.endpoint, streamFrom.endpoint)), (AsymmetricRemoteSyncTask) task);
                    }
                    else
                    {
                        task = new SymmetricRemoteSyncTask(desc, r1, r2, session.previewKind);
                        // SymmetricRemoteSyncTask expects SyncComplete message sent back.
                        // Register task to RepairSession to receive response.
                        session.waitForSync(Pair.create(desc, new NodePair(r1.endpoint, r2.endpoint)), (SymmetricRemoteSyncTask) task);
                    }
                    syncTasks.add(task);
                    taskExecutor.submit(task);
                }
            }
            return Futures.allAsList(syncTasks);
        };
    }

