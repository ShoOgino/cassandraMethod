    public void validate(ClientState state) throws RequestValidationException
    {
        CFMetaData cfm = ThriftValidation.validateColumnFamily(keyspace(), columnFamily());
        if (cfm.isCounter())
            throw new InvalidRequestException("Secondary indexes are not supported on counter tables");

        IndexTarget target = rawTarget.prepare(cfm);
        ColumnDefinition cd = cfm.getColumnDefinition(target.column);

        if (cd == null)
            throw new InvalidRequestException("No column definition found for column " + target.column);

        boolean isMap = cd.type instanceof MapType;
        boolean isFrozenCollection = cd.type.isCollection() && !cd.type.isMultiCell();

        if (isFrozenCollection)
        {
            validateForFrozenCollection(target);
        }
        else
        {
            validateNotFullIndex(target);
            validateIsValuesIndexIfTargetColumnNotCollection(cd, target);
            validateTargetColumnIsMapIfIndexInvolvesKeys(isMap, target);
        }

        Indexes existingIndexes = cfm.getIndexes();
        for (IndexMetadata index : existingIndexes)
        {
            if (index.indexedColumn(cfm).equals(cd))
            {
                IndexTarget.TargetType prevType = IndexTarget.TargetType.fromIndexMetadata(index, cfm);
                if (isMap && target.type != prevType)
                {
                    String msg = "Cannot create index on %s(%s): an index on %s(%s) already exists and indexing " +
                                 "a map on more than one dimension at the same time is not currently supported";
                    throw new InvalidRequestException(String.format(msg,
                                                                    target.type, target.column,
                                                                    prevType, target.column));
                }

                if (ifNotExists)
                    return;
                else
                    throw new InvalidRequestException("Index already existss");
            }
        }

        if (!Strings.isNullOrEmpty(indexName))
        {
            if (Schema.instance.getKSMetaData(keyspace()).existingIndexNames(null).contains(indexName))
                throw new InvalidRequestException("Index already exists");
        }

        properties.validate();

        if (cfm.isCompactTable())
        {
            if (!cfm.isStaticCompactTable())
                throw new InvalidRequestException("Secondary indexes are not supported on COMPACT STORAGE tables that have clustering columns");
            else if (cd.isPrimaryKeyColumn())
                // TODO: we could lift that limitation
                throw new InvalidRequestException("Secondary indexes are not supported on PRIMARY KEY columns in COMPACT STORAGE tables");
        }

        // It would be possible to support 2ndary index on static columns (but not without modifications of at least ExtendedFilter and
        // CompositesIndex) and maybe we should, but that means a query like:
        //     SELECT * FROM foo WHERE static_column = 'bar'
        // would pull the full partition every time the static column of partition is 'bar', which sounds like offering a
        // fair potential for foot-shooting, so I prefer leaving that to a follow up ticket once we have identified cases where
        // such indexing is actually useful.
        if (!cfm.isCompactTable() && cd.isStatic())
            throw new InvalidRequestException("Secondary indexes are not allowed on static columns");

        if (cd.kind == ColumnDefinition.Kind.PARTITION_KEY && cd.isOnAllComponents())
            throw new InvalidRequestException(String.format("Cannot create secondary index on partition key column %s", target.column));
    }

