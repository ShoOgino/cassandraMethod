    /**
     * Calculate the size of this message for the specified protocol version and memoize the result for the specified
     * protocol version. Memoization only covers the protocol version of the first invocation.
     *
     * It is not safe to call this function concurrently from multiple threads unless it has already been invoked
     * once from a single thread and there is a happens before relationship between that invocation and other
     * threads concurrently invoking this function.
     *
     * For instance it would be safe to invokePayload size to make a decision in the thread that created the message
     * and then hand it off to other threads via a thread-safe queue, volatile write, or synchronized/ReentrantLock.
     *
     * @param version Protocol version to use when calculating size
     * @return Size of this message in bytes, which will be less than or equal to {@link Integer#MAX_VALUE}
     */
    public int serializedSize(int version)
    {
        if (serializedSize > 0 && serializedSizeVersion == version)
            return serializedSize;

        MessageOutSizes sizes = calculateSerializedSize(version);
        if (sizes.messageSize > Integer.MAX_VALUE)
            throw new IllegalStateException("message size exceeds maximum allowed size: size = " + sizes.messageSize);

        if (serializedSizeVersion == SERIALIZED_SIZE_VERSION_UNDEFINED)
        {
            serializedSize = Ints.checkedCast(sizes.messageSize);
            payloadSerializedSize = Ints.checkedCast(sizes.payloadSize);
            serializedSizeVersion = version;
        }

        return Ints.checkedCast(sizes.messageSize);
    }

