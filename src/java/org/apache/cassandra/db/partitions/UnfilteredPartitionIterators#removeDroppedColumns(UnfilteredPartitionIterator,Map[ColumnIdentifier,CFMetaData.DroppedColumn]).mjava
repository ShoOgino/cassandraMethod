    public static UnfilteredPartitionIterator removeDroppedColumns(UnfilteredPartitionIterator iterator, final Map<ColumnIdentifier, CFMetaData.DroppedColumn> droppedColumns)
    {
        return new FilteringPartitionIterator(iterator)
        {
            @Override
            protected FilteringRow makeRowFilter()
            {
                return new FilteringRow()
                {
                    @Override
                    protected boolean include(Cell cell)
                    {
                        return include(cell.column(), cell.livenessInfo().timestamp());
                    }

                    @Override
                    protected boolean include(ColumnDefinition c, DeletionTime dt)
                    {
                        return include(c, dt.markedForDeleteAt());
                    }

                    private boolean include(ColumnDefinition column, long timestamp)
                    {
                        CFMetaData.DroppedColumn dropped = droppedColumns.get(column.name);
                        return dropped == null || timestamp > dropped.droppedTime;
                    }
                };
            }

            @Override
            protected boolean shouldFilter(UnfilteredRowIterator iterator)
            {
                // TODO: We could have row iterators return the smallest timestamp they might return
                // (which we can get from sstable stats), and ignore any dropping if that smallest
                // timestamp is bigger that the biggest droppedColumns timestamp.

                // If none of the dropped columns is part of the columns that the iterator actually returns, there is nothing to do;
                for (ColumnDefinition c : iterator.columns())
                    if (droppedColumns.containsKey(c.name))
                        return true;

                return false;
            }
        };
    }

