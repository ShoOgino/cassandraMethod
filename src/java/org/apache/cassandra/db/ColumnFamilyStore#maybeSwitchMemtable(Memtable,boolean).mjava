    /** flush the given memtable and swap in a new one for its CFS, if it hasn't been frozen already.  threadsafe. */
    Future<?> maybeSwitchMemtable(Memtable oldMemtable, final boolean writeCommitLog)
    {
        // Only one thread will succeed in marking it as pending flush; the others can go back to processing writes
        if (!oldMemtable.markPendingFlush())
        {
            logger.debug("memtable is already pending flush; another thread must be flushing it");
            return null;
        }
        assert memtable == oldMemtable;

        boolean isDropped = isIndex()
                          ? DatabaseDescriptor.getCFMetaData(table.name, getParentColumnfamily()) == null
                          : DatabaseDescriptor.getCFMetaData(metadata.cfId) == null;
        if (isDropped)
        {
            logger.debug("column family was dropped; no point in flushing");
            return null;
        }

        // Table.flusherLock ensures that we schedule discardCompletedSegments calls in the same order as their
        // contexts (commitlog position) were read, even though the flush executor is multithreaded.
        Table.flusherLock.lock();
        try
        {
            final CommitLogSegment.CommitLogContext ctx = writeCommitLog ? CommitLog.instance.getContext() : null;

            // submit the memtable for any indexed sub-cfses, and our own.
            List<ColumnFamilyStore> icc = new ArrayList<ColumnFamilyStore>(indexedColumns.size());
            // don't assume that this.memtable is dirty; forceFlush can bring us here during index build even if it is not
            for (ColumnFamilyStore cfs : Iterables.concat(Collections.singleton(this), indexedColumns.values()))
            {
                if (!cfs.memtable.isClean())
                    icc.add(cfs);
            }
            final CountDownLatch latch = new CountDownLatch(icc.size());
            for (ColumnFamilyStore cfs : icc)
            {
                if (!reverseReadWriteOrder())
                {
                    //XXX: race condition: may allow double reconcile; but never misses an MT
                    submitFlush(cfs.memtable, latch);
                    cfs.memtable = new Memtable(cfs);
                }
                else
                {
                    //XXX: race condition: may miss an MT, but no double counts
                    Memtable pendingFlush = cfs.memtable;
                    cfs.memtable = new Memtable(cfs);
                    submitFlush(pendingFlush, latch);
                }
            }
            // we marked our memtable as frozen as part of the concurrency control,
            // so even if there was nothing to flush we need to switch it out
            if (!icc.contains(this))
                memtable = new Memtable(this);

            // when all the memtables have been written, including for indexes, mark the flush in the commitlog header.
            // a second executor makes sure the onMemtableFlushes get called in the right order,
            // while keeping the wait-for-flush (future.get) out of anything latency-sensitive.
            return postFlushExecutor.submit(new WrappedRunnable()
            {
                public void runMayThrow() throws InterruptedException, IOException
                {
                    latch.await();
                    if (writeCommitLog)
                    {
                        // if we're not writing to the commit log, we are replaying the log, so marking
                        // the log header with "you can discard anything written before the context" is not valid
                        CommitLog.instance.discardCompletedSegments(metadata.cfId, ctx);
                    }
                }
            });
        }
        finally
        {
            Table.flusherLock.unlock();
            if (memtableSwitchCount == Integer.MAX_VALUE)
            {
                memtableSwitchCount = 0;
            }
            memtableSwitchCount++;
        }
    }

