    private void toSchemaNoColumnsNoTriggers(Mutation mutation, long timestamp)
    {
        // For property that can be null (and can be changed), we insert tombstones, to make sure
        // we don't keep a property the user has removed
        ColumnFamily cf = mutation.addOrGet(SchemaColumnFamiliesCf);
        Composite prefix = SchemaColumnFamiliesCf.comparator.make(cfName);
        CFRowAdder adder = new CFRowAdder(cf, prefix, timestamp);

        adder.add("cf_id", cfId);
        adder.add("type", cfType.toString());

        if (isSuper())
        {
            // We need to continue saving the comparator and subcomparator separatly, otherwise
            // we won't know at deserialization if the subcomparator should be taken into account
            // TODO: we should implement an on-start migration if we want to get rid of that.
            adder.add("comparator", comparator.subtype(0).toString());
            adder.add("subcomparator", comparator.subtype(1).toString());
        }
        else
        {
            adder.add("comparator", comparator.toString());
        }

        adder.add("comment", comment);
        adder.add("read_repair_chance", readRepairChance);
        adder.add("local_read_repair_chance", dcLocalReadRepairChance);
        adder.add("populate_io_cache_on_flush", populateIoCacheOnFlush);
        adder.add("gc_grace_seconds", gcGraceSeconds);
        adder.add("default_validator", defaultValidator.toString());
        adder.add("key_validator", keyValidator.toString());
        adder.add("min_compaction_threshold", minCompactionThreshold);
        adder.add("max_compaction_threshold", maxCompactionThreshold);
        adder.add("bloom_filter_fp_chance", bloomFilterFpChance);

        adder.add("memtable_flush_period_in_ms", memtableFlushPeriod);
        adder.add("caching", caching.toString());
        adder.add("default_time_to_live", defaultTimeToLive);
        adder.add("compaction_strategy_class", compactionStrategyClass.getName());
        adder.add("compression_parameters", json(compressionParameters.asThriftOptions()));
        adder.add("compaction_strategy_options", json(compactionStrategyOptions));
        adder.add("min_index_interval", minIndexInterval);
        adder.add("max_index_interval", maxIndexInterval);
        adder.add("index_interval", null);
        adder.add("speculative_retry", speculativeRetry.toString());

        for (Map.Entry<ColumnIdentifier, Long> entry : droppedColumns.entrySet())
            adder.addMapEntry("dropped_columns", entry.getKey().toString(), entry.getValue());

        // Save the CQL3 metadata "the old way" for compatibility sake
        adder.add("key_aliases", aliasesToJson(partitionKeyColumns));
        adder.add("column_aliases", aliasesToJson(clusteringColumns));
        adder.add("value_alias", compactValueColumn == null ? null : compactValueColumn.name.toString());
    }

