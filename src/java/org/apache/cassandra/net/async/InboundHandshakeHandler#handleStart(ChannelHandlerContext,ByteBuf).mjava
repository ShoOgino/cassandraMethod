    /**
     * Handles receiving the first message in the internode messaging handshake protocol. If the sender's protocol version
     * is accepted, we respond with the second message of the handshake protocol.
     */
    @VisibleForTesting
    State handleStart(ChannelHandlerContext ctx, ByteBuf in) throws IOException
    {
        FirstHandshakeMessage msg = FirstHandshakeMessage.maybeDecode(in);
        if (msg == null)
            return State.START;

        logger.trace("received first handshake message from peer {}, message = {}", ctx.channel().remoteAddress(), msg);
        version = msg.messagingVersion;

        if (msg.mode == NettyFactory.Mode.STREAMING)
        {
            // streaming connections are per-session and have a fixed version.  we can't do anything with a wrong-version stream connection, so drop it.
            if (version != StreamMessage.CURRENT_VERSION)
            {
                logger.warn("Received stream using protocol version %d (my version %d). Terminating connection", version, MessagingService.current_version);
                ctx.close();
                return State.HANDSHAKE_FAIL;
            }

            setupStreamingPipeline(ctx, version);
            return State.HANDSHAKE_COMPLETE;
        }
        else
        {
            if (version < MessagingService.VERSION_30)
            {
                logger.error("Unable to read obsolete message version {} from {}; The earliest version supported is 3.0.0", version, ctx.channel().remoteAddress());
                ctx.close();
                return State.HANDSHAKE_FAIL;
            }

            logger.trace("Connection version {} from {}", version, ctx.channel().remoteAddress());
            compressed = msg.compressionEnabled;

            // if this version is < the MS version the other node is trying
            // to connect with, the other node will disconnect
            ctx.writeAndFlush(new SecondHandshakeMessage(MessagingService.current_version).encode(ctx.alloc()))
               .addListener(ChannelFutureListener.CLOSE_ON_FAILURE);

            // outbound side will reconnect to change the version
            if (version > MessagingService.current_version)
            {
                logger.info("peer wants to use a messaging version higher ({}) than what this node supports ({})", version, MessagingService.current_version);
                ctx.close();
                return State.HANDSHAKE_FAIL;
            }

            long timeout = TimeUnit.MILLISECONDS.toNanos(DatabaseDescriptor.getRpcTimeout());
            handshakeTimeout = ctx.executor().schedule(() -> failHandshake(ctx), timeout, TimeUnit.MILLISECONDS);
            return State.AWAIT_MESSAGING_START_RESPONSE;
        }
    }

