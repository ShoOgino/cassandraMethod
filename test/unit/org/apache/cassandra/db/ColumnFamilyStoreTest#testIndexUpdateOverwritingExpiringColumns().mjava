    @Test
    public void testIndexUpdateOverwritingExpiringColumns() throws Exception
    {
        // see CASSANDRA-7268
        Keyspace keyspace = Keyspace.open(KEYSPACE2);

        // create a row and update the birthdate value with an expiring column
        Mutation rm;
        rm = new Mutation(KEYSPACE2, ByteBufferUtil.bytes("k100"));
        rm.add("Indexed1", cellname("birthdate"), ByteBufferUtil.bytes(100L), 1, 1000);
        rm.apply();

        IndexExpression expr = new IndexExpression(ByteBufferUtil.bytes("birthdate"), IndexExpression.Operator.EQ, ByteBufferUtil.bytes(100L));
        List<IndexExpression> clause = Arrays.asList(expr);
        IDiskAtomFilter filter = new IdentityQueryFilter();
        Range<RowPosition> range = Util.range("", "");
        List<Row> rows = keyspace.getColumnFamilyStore("Indexed1").search(range, clause, filter, 100);
        assertEquals(1, rows.size());

        // requires a 1s sleep because we calculate local expiry time as (now() / 1000) + ttl
        TimeUnit.SECONDS.sleep(1);

        // now overwrite with the same name/value/ttl, but the local expiry time will be different
        rm = new Mutation(KEYSPACE2, ByteBufferUtil.bytes("k100"));
        rm.add("Indexed1", cellname("birthdate"), ByteBufferUtil.bytes(100L), 1, 1000);
        rm.apply();

        rows = keyspace.getColumnFamilyStore("Indexed1").search(range, clause, filter, 100);
        assertEquals(1, rows.size());

        // check that modifying the indexed value using the same timestamp behaves as expected
        rm = new Mutation(KEYSPACE2, ByteBufferUtil.bytes("k101"));
        rm.add("Indexed1", cellname("birthdate"), ByteBufferUtil.bytes(101L), 1, 1000);
        rm.apply();

        expr = new IndexExpression(ByteBufferUtil.bytes("birthdate"), IndexExpression.Operator.EQ, ByteBufferUtil.bytes(101L));
        clause = Arrays.asList(expr);
        rows = keyspace.getColumnFamilyStore("Indexed1").search(range, clause, filter, 100);
        assertEquals(1, rows.size());

        TimeUnit.SECONDS.sleep(1);
        rm = new Mutation(KEYSPACE2, ByteBufferUtil.bytes("k101"));
        rm.add("Indexed1", cellname("birthdate"), ByteBufferUtil.bytes(102L), 1, 1000);
        rm.apply();
        // search for the old value
        rows = keyspace.getColumnFamilyStore("Indexed1").search(range, clause, filter, 100);
        assertEquals(0, rows.size());
        // and for the new
        expr = new IndexExpression(ByteBufferUtil.bytes("birthdate"), IndexExpression.Operator.EQ, ByteBufferUtil.bytes(102L));
        clause = Arrays.asList(expr);
        rows = keyspace.getColumnFamilyStore("Indexed1").search(range, clause, filter, 100);
        assertEquals(1, rows.size());
    }

