    @Test
    public void testPurgedVsNonExisting() throws Throwable
    {
        Range<Token> range = new Range<>(partitioner.getMinimumToken(), partitioner.getRandomToken());
        final RepairJobDesc desc = new RepairJobDesc(UUID.randomUUID(), keyspace, columnFamily, range);

        InetAddress remote = InetAddress.getByName("127.0.0.2");

        ColumnFamilyStore cfs = Keyspace.open(keyspace).getColumnFamilyStore(columnFamily);

        Token mid = partitioner.midpoint(range.left, range.right);
        DecoratedKey key = new DecoratedKey(mid, ByteBufferUtil.bytes("inconceivable!"));

        // create validator with zero rows
        Validator validator1 = new Validator(desc, remote, 0);
        validator1.prepare(cfs);
        validator1.complete();

        // create validator with a single row with null cf
        Validator validator2 = new Validator(desc, remote, 0);
        validator2.prepare(cfs);
        // a precompacted row with a cf null value indicates that there are no columns or tombstones left for this row
        // this should give us the identical hash compared to the case as if the row would not have been added at all
        // as with validator1
        PrecompactedRow row2 = new PrecompactedRow(key, null);
        validator2.add(row2);
        validator2.complete();

        // confirm that both trees are equal
        List<TreeRange> diff = MerkleTree.difference(validator1.tree, validator2.tree);
        assertTrue("Found tree mismatch: " + diff, diff.size() == 0);
    }

