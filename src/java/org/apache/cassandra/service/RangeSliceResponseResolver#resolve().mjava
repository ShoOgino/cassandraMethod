    // Note: this deserializes the response a 2nd time if getData was called first
    // (this is not currently an issue since we don't do read repair for range queries.)
    public Iterable<Row> resolve() throws IOException
    {
        CollatingIterator collator = new CollatingIterator(new Comparator<Pair<Row,InetAddress>>()
        {
            public int compare(Pair<Row,InetAddress> o1, Pair<Row,InetAddress> o2)
            {
                return o1.left.key.compareTo(o2.left.key);
            }
        });
        
        int n = 0;
        for (Message response : responses)
        {
            RangeSliceReply reply = RangeSliceReply.read(response.getMessageBody(), response.getVersion());
            n = Math.max(n, reply.rows.size());
            collator.addIterator(new RowIterator(reply.rows.iterator(), response.getFrom()));
        }

        // for each row, compute the combination of all different versions seen, and repair incomplete versions

        return new ReducingIterator<Pair<Row,InetAddress>, Row>(collator)
        {
            List<ColumnFamily> versions = new ArrayList<ColumnFamily>(sources.size());
            List<InetAddress> versionSources = new ArrayList<InetAddress>(sources.size());
            DecoratedKey key;

            @Override
            protected boolean isEqual(Pair<Row, InetAddress> o1, Pair<Row, InetAddress> o2)
            {
                return o1.left.key.equals(o2.left.key);
            }

            public void reduce(Pair<Row,InetAddress> current)
            {
                key = current.left.key;
                versions.add(current.left.cf);
                versionSources.add(current.right);
            }

            protected Row getReduced()
            {
                ColumnFamily resolved = RowRepairResolver.resolveSuperset(versions);
                RowRepairResolver.maybeScheduleRepairs(resolved, table, key, versions, versionSources);
                versions.clear();
                versionSources.clear();
                return new Row(key, resolved);
            }
        };
    }

