    public void collateColumns(final ColumnFamily returnCF, List<? extends Iterator<Column>> toCollate, final int gcBefore)
    {
        final Comparator<Column> fcomp = filter.getColumnComparator(returnCF.getComparator());
        // define a 'reduced' iterator that merges columns w/ the same name, which
        // greatly simplifies computing liveColumns in the presence of tombstones.
        MergeIterator.Reducer<Column, Column> reducer = new MergeIterator.Reducer<Column, Column>()
        {
            Column current;

            public void reduce(Column next)
            {
                assert current == null || fcomp.compare(current, next) == 0;
                current = current == null ? next : current.reconcile(next, HeapAllocator.instance);
            }

            protected Column getReduced()
            {
                assert current != null;
                Column toReturn = current;
                current = null;
                return toReturn;
            }
        };
        Iterator<Column> reduced = MergeIterator.get(toCollate, fcomp, reducer);

        filter.collectReducedColumns(returnCF, reduced, gcBefore, timestamp);
    }

