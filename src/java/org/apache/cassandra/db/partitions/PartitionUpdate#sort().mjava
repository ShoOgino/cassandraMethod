    private synchronized void sort()
    {
        if (isSorted)
            return;

        if (rows <= 1)
        {
            isSorted = true;
            return;
        }

        // Sort the rows - will still potentially contain duplicate (non-reconciled) rows
        Sorting.sort(this);

        // Now find duplicates and merge them together
        int previous = 0; // The last element that was set
        int nowInSec = FBUtilities.nowInSeconds();
        for (int current = 1; current < rows; current++)
        {
            // There is really only 2 possible comparison: < 0 or == 0 since we've sorted already
            int cmp = compare(previous, current);
            if (cmp == 0)
            {
                // current and previous are the same row. Merge current into previous
                // (and so previous + 1 will be "free").
                merge(current, previous, nowInSec);
            }
            else
            {
                // data[current] != [previous], so move current just after previous if needs be
                ++previous;
                if (previous != current)
                    move(current, previous);
            }
        }

        // previous is on the last value to keep
        rows = previous + 1;

        isSorted = true;
    }

