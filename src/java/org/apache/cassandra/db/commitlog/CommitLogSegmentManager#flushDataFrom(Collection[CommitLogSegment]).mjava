    /**
     * Force a flush on all CFs that are still dirty in @param segments.
     *
     * @return a Future that will finish when all the flushes are complete.
     */
    private Future<?> flushDataFrom(Collection<CommitLogSegment> segments)
    {
        // a map of CfId -> forceFlush() to ensure we only queue one flush per cf
        final Map<UUID, Future<?>> flushes = new LinkedHashMap<>();

        for (CommitLogSegment segment : segments)
        {
            for (UUID dirtyCFId : segment.getDirtyCFIDs())
            {
                Pair<String,String> pair = Schema.instance.getCF(dirtyCFId);
                if (pair == null)
                {
                    // even though we remove the schema entry before a final flush when dropping a CF,
                    // it's still possible for a writer to race and finish his append after the flush.
                    logger.debug("Marking clean CF {} that doesn't exist anymore", dirtyCFId);
                    segment.markClean(dirtyCFId, segment.getContext());
                }
                else if (!flushes.containsKey(dirtyCFId))
                {
                    String keyspace = pair.left;
                    final ColumnFamilyStore cfs = Keyspace.open(keyspace).getColumnFamilyStore(dirtyCFId);
                    // Push the flush out to another thread to avoid potential deadlock: Table.add
                    // acquires switchlock, and could be blocking for the manager thread.  So if the manager
                    // thread itself tries to acquire switchlock (via flush -> switchMemtable) we'd have a problem.
                    Runnable runnable = new Runnable()
                    {
                        public void run()
                        {
                            cfs.forceFlush();
                        }
                    };
                    flushes.put(dirtyCFId, StorageService.optionalTasks.submit(runnable));
                }
            }
        }

        return new FutureTask<>(new Callable<Object>()
        {
            public Object call()
            {
                FBUtilities.waitOnFutures(flushes.values());
                return null;
            }
        });
    }

