    private boolean addToMutation(ColumnFamily cf,
                                  ColumnNameBuilder builder,
                                  CFDefinition.Name valueDef,
                                  Operation valueOperation,
                                  UpdateParameters params,
                                  List<Pair<ByteBuffer, IColumn>> list) throws InvalidRequestException
    {
        Operation.Type type = valueOperation.getType();

        switch (type)
        {
            case COLUMN:
                if (valueDef != null && valueDef.type.isCollection())
                {
                    // This means this was a prepared statement where the whole collection was provided
                    // For have to deserialize it since it will be multiple columns
                    ((ColumnOperation)valueOperation).executePreparedCollection(cf, builder.copy(), (CollectionType)valueDef.type, params);
                }
                else
                {
                    valueOperation.execute(cf, builder.copy(), valueDef == null ? null : valueDef.type, params);
                }
                break;
            case COUNTER:
                if (valueDef != null && valueDef.type.isCollection())
                    throw new InvalidRequestException("Cannot assign collection value to column with " + valueDef.type + " type.");

                valueOperation.execute(cf, builder.copy(), valueDef == null ? null : valueDef.type, params);
                break;
            default:
                if (!valueDef.type.isCollection())
                    throw new InvalidRequestException("Can't apply collection operation on column with " + valueDef.type + " type.");

                valueOperation.execute(cf, builder.copy(), (CollectionType) valueDef.type, params, list);
                break;
        }
        return valueOperation.getType() == Operation.Type.COUNTER;
    }

