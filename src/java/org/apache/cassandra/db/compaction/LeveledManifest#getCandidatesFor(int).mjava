    private Collection<SSTableReader> getCandidatesFor(int level)
    {
        assert !generations[level].isEmpty();

        if (level == 0)
        {
            // because L0 files may overlap each other, we treat compactions there specially:
            // a L0 compaction also checks other L0 files for overlap.
            Set<SSTableReader> candidates = new HashSet<SSTableReader>();
            Set<SSTableReader> remaining = new HashSet<SSTableReader>(generations[0]);

            while (!remaining.isEmpty())
            {
                // pick a random sstable from L0, and any that overlap with it
                List<SSTableReader> L0 = overlapping(remaining.iterator().next(), remaining);
                //but not too many, as we could run out of memory
                L0 = L0.size() > MAX_COMPACTING_L0 ? L0.subList(0, MAX_COMPACTING_L0) : L0;
                // add the overlapping ones from L1
                for (SSTableReader sstable : L0)
                {
                    candidates.addAll(overlapping(sstable, generations[1]));
                    remaining.remove(sstable);
                }
            }
            return candidates;
        }

        // for non-L0 compactions, pick up where we left off last time
        Collections.sort(generations[level], SSTable.sstableComparator);
        for (SSTableReader sstable : generations[level])
        {
            // the first sstable that is > than the marked
            if (sstable.first.compareTo(lastCompactedKeys[level]) > 0)
                return overlapping(sstable, generations[(level + 1)]);
        }
        // or if there was no last time, start with the first sstable
        return overlapping(generations[level].get(0), generations[(level + 1)]);
    }

