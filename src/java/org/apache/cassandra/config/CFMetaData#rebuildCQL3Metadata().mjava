    private void rebuildCQL3Metadata()
    {
        List<ColumnDefinition> pkCols = nullInitializedList(keyValidator.componentsCount());
        int nbCkCols = isDense(comparator, column_metadata.values())
                     ? comparator.componentsCount()
                     : comparator.componentsCount() - (hasCollection() ? 2 : 1);
        List<ColumnDefinition> ckCols = nullInitializedList(nbCkCols);
        Set<ColumnDefinition> regCols = new HashSet<ColumnDefinition>();
        ColumnDefinition compactCol = null;

        for (ColumnDefinition def : column_metadata.values())
        {
            switch (def.type)
            {
                case PARTITION_KEY:
                    assert !(def.componentIndex == null && keyValidator instanceof CompositeType);
                    pkCols.set(def.componentIndex == null ? 0 : def.componentIndex, def);
                    break;
                case CLUSTERING_KEY:
                    assert !(def.componentIndex == null && comparator instanceof CompositeType);
                    ckCols.set(def.componentIndex == null ? 0 : def.componentIndex, def);
                    break;
                case REGULAR:
                    regCols.add(def);
                    break;
                case COMPACT_VALUE:
                    assert compactCol == null : "There shouldn't be more than one compact value defined";
                    compactCol = def;
                    break;
            }
        }

        // Now actually assign the correct value. This is not atomic, but then again, updating CFMetaData is never atomic anyway.
        partitionKeyColumns = pkCols;
        clusteringKeyColumns = ckCols;
        regularColumns = regCols;
        compactValueColumn = compactCol;
    }

