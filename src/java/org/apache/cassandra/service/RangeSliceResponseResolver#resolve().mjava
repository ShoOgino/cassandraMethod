    // Note: this would deserialize the response a 2nd time if getData was called first.
    // (this is not currently an issue since we don't do read repair for range queries.)
    public Iterable<Row> resolve() throws IOException
    {
        ArrayList<RowIterator> iters = new ArrayList<RowIterator>(responses.size());
        int n = 0;
        for (Message response : responses)
        {
            RangeSliceReply reply = RangeSliceReply.read(response.getMessageBody(), response.getVersion());
            n = Math.max(n, reply.rows.size());
            iters.add(new RowIterator(reply.rows.iterator(), response.getFrom()));
        }
        // for each row, compute the combination of all different versions seen, and repair incomplete versions
        MergeIterator<Pair<Row,InetAddress>, Row> iter = MergeIterator.get(iters, new Comparator<Pair<Row,InetAddress>>()
        {
            public int compare(Pair<Row,InetAddress> o1, Pair<Row,InetAddress> o2)
            {
                return o1.left.key.compareTo(o2.left.key);
            }
        }, new MergeIterator.Reducer<Pair<Row,InetAddress>, Row>()
        {
            List<ColumnFamily> versions = new ArrayList<ColumnFamily>(sources.size());
            List<InetAddress> versionSources = new ArrayList<InetAddress>(sources.size());
            DecoratedKey key;

            public void reduce(Pair<Row,InetAddress> current)
            {
                key = current.left.key;
                versions.add(current.left.cf);
                versionSources.add(current.right);
            }

            protected Row getReduced()
            {
                ColumnFamily resolved = versions.size() > 1
                                      ? RowRepairResolver.resolveSuperset(versions)
                                      : versions.get(0);
                if (versions.size() < sources.size())
                {
                    // add placeholder rows for sources that didn't have any data, so maybeScheduleRepairs sees them
                    for (InetAddress source : sources)
                    {
                        if (!versionSources.contains(source))
                        {
                            versions.add(null);
                            versionSources.add(source);
                        }
                    }
                }
                RowRepairResolver.maybeScheduleRepairs(resolved, table, key, versions, versionSources);
                versions.clear();
                versionSources.clear();
                return new Row(key, resolved);
            }
        });

        List<Row> resolvedRows = new ArrayList<Row>(n);
        while (iter.hasNext())
            resolvedRows.add(iter.next());

        return resolvedRows;
    }

