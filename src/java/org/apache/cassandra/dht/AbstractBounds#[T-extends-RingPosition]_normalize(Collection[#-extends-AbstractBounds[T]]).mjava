    /**
     * @return A copy of the given list of with all bounds unwrapped, sorted by bound.left and with overlapping bounds merged.
     * This method does not allow allow to mix Range and Bound in the input list.
     */
    public static <T extends RingPosition> List<AbstractBounds<T>> normalize(Collection<? extends AbstractBounds<T>> bounds)
    {
        // unwrap all
        List<AbstractBounds<T>> output = new ArrayList<AbstractBounds<T>>();
        for (AbstractBounds<T> bound : bounds)
            output.addAll(bound.unwrap());

        // sort by left
        Collections.sort(output, new Comparator<AbstractBounds<T>>()
        {
            public int compare(AbstractBounds<T> b1, AbstractBounds<T> b2)
            {
                return b1.left.compareTo(b2.left);
            }
        });

        // deoverlap
        return deoverlap(output);
    }

