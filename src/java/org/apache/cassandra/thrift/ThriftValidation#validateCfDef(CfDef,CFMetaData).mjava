    public static void validateCfDef(CfDef cf_def, CFMetaData old) throws InvalidRequestException
    {
        try
        {
            if (cf_def.key_alias != null)
            {
                if (!cf_def.key_alias.hasRemaining())
                    throw new InvalidRequestException("key_alias may not be empty");
                try
                {
                    // it's hard to use a key in a select statement if we can't type it.
                    // for now let's keep it simple and require ascii.
                    AsciiType.instance.validate(cf_def.key_alias);
                }
                catch (MarshalException e)
                {
                    throw new InvalidRequestException("Key aliases must be ascii");
                }
            }

            ColumnFamilyType cfType = ColumnFamilyType.create(cf_def.column_type);
            if (cfType == null)
                throw new InvalidRequestException("invalid column type " + cf_def.column_type);

            TypeParser.parse(cf_def.key_validation_class);
            TypeParser.parse(cf_def.comparator_type);
            TypeParser.parse(cf_def.subcomparator_type);
            TypeParser.parse(cf_def.default_validation_class);
            if (cfType != ColumnFamilyType.Super && cf_def.subcomparator_type != null)
                throw new InvalidRequestException("subcomparator_type is invalid for standard columns");

            if (cf_def.column_metadata == null)
                return;

            AbstractType comparator = cfType == ColumnFamilyType.Standard
                                    ? TypeParser.parse(cf_def.comparator_type)
                                    : TypeParser.parse(cf_def.subcomparator_type);

            if (cf_def.key_alias != null)
            {
                // check if any of the columns has name equal to the cf.key_alias
                for (ColumnDef columnDef : cf_def.column_metadata)
                {
                    if (cf_def.key_alias.equals(columnDef.name))
                        throw new InvalidRequestException("Invalid column name: "
                                                          + AsciiType.instance.compose(cf_def.key_alias)
                                                          + ", because it equals to the key_alias.");
                }
            }

            // initialize a set of names NOT in the CF under consideration
            Set<String> indexNames = new HashSet<String>();
            for (ColumnFamilyStore cfs : ColumnFamilyStore.all())
            {
                if (!cfs.getColumnFamilyName().equals(cf_def.name))
                    for (ColumnDefinition cd : cfs.metadata.getColumn_metadata().values())
                        indexNames.add(cd.getIndexName());
            }

            for (ColumnDef c : cf_def.column_metadata)
            {
                TypeParser.parse(c.validation_class);

                try
                {
                    comparator.validate(c.name);
                }
                catch (MarshalException e)
                {
                    throw new InvalidRequestException(String.format("Column name %s is not valid for comparator %s",
                                                                    ByteBufferUtil.bytesToHex(c.name), cf_def.comparator_type));
                }

                if (c.index_type == null)
                {
                    if (c.index_name != null)
                        throw new ConfigurationException("index_name cannot be set without index_type");
                }
                else
                {
                    if (cfType == ColumnFamilyType.Super)
                        throw new InvalidRequestException("Secondary indexes are not supported on supercolumns");
                    assert c.index_name != null; // should have a default set by now if none was provided
                    if (!Migration.isLegalName(c.index_name))
                        throw new InvalidRequestException("Illegal index name " + c.index_name);
                    // check index names against this CF _and_ globally
                    if (indexNames.contains(c.index_name))
                        throw new InvalidRequestException("Duplicate index name " + c.index_name);
                    indexNames.add(c.index_name);

                    ColumnDefinition oldCd = old == null ? null : old.getColumnDefinition(c.name);
                    if (oldCd != null && oldCd.getIndexType() != null)
                    {
                        assert oldCd.getIndexName() != null;
                        if (!oldCd.getIndexName().equals(c.index_name))
                            throw new InvalidRequestException("Cannot modify index name");
                    }
                }
            }
            validateMinMaxCompactionThresholds(cf_def);
            validateMemtableSettings(cf_def);
        }
        catch (ConfigurationException e)
        {
            throw new InvalidRequestException(e.getMessage());
        }
    }

