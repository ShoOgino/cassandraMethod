        public boolean allowOutgoingMessage(MessageOut messageOut, int id, InetAddress to)
        {
            InetAddressAndPort from = broadcastAddressAndPort();
            assert from.equals(lookupAddressAndPort.apply(messageOut.from));
            InetAddressAndPort toFull = lookupAddressAndPort.apply(to);
            IMessage message = serializeMessage(messageOut, id, from, toFull);

            // Tracing logic - similar to org.apache.cassandra.net.OutboundTcpConnection.writeConnected
            byte[] sessionBytes = (byte[]) messageOut.parameters.get(Tracing.TRACE_HEADER);
            if (sessionBytes != null)
            {
                UUID sessionId = UUIDGen.getUUID(ByteBuffer.wrap(sessionBytes));
                TraceState state = Tracing.instance.get(sessionId);
                String traceMessage = String.format("Sending %s message to %s", messageOut.verb, toFull.address);
                // session may have already finished; see CASSANDRA-5668
                if (state == null)
                {
                    byte[] traceTypeBytes = (byte[]) messageOut.parameters.get(Tracing.TRACE_TYPE);
                    Tracing.TraceType traceType = traceTypeBytes == null ? Tracing.TraceType.QUERY : Tracing.TraceType.deserialize(traceTypeBytes[0]);
                    TraceState.mutateWithTracing(ByteBuffer.wrap(sessionBytes), traceMessage, -1, traceType.getTTL());
                }
                else
                {
                    state.trace(traceMessage);
                    if (messageOut.verb == MessagingService.Verb.REQUEST_RESPONSE)
                        Tracing.instance.doneWithNonLocalSession(state);
                }
            }

            deliver.accept(toFull, message);
            return false;
        }

