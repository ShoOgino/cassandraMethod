    private ColumnFamily getTopLevelColumns(QueryFilter filter, int gcBefore)
    {
        // we are querying top-level columns, do a merging fetch with indexes.
        List<ColumnIterator> iterators = new ArrayList<ColumnIterator>();
        try
        {
            final ColumnFamily returnCF;
            ColumnIterator iter;

            /* add the current memtable */
            Table.flusherLock.readLock().lock();
            try
            {
                iter = filter.getMemColumnIterator(memtable_, getComparator());
                // TODO this is a little subtle: the Memtable ColumnIterator has to be a shallow clone of the source CF,
                // with deletion times set correctly, so we can use it as the "base" CF to add query results to.
                // (for sstable ColumnIterators we do not care if it is a shallow clone or not.)
                returnCF = iter.getColumnFamily();
            }
            finally
            {
                Table.flusherLock.readLock().unlock();
            }
            iterators.add(iter);

            /* add the memtables being flushed */
            for (Memtable memtable : getMemtablesPendingFlush())
            {
                iter = filter.getMemColumnIterator(memtable, getComparator());
                returnCF.delete(iter.getColumnFamily());
                iterators.add(iter);
            }

            /* add the SSTables on disk */
            for (SSTableReader sstable : ssTables_)
            {
                iter = filter.getSSTableColumnIterator(sstable);
                if (iter.hasNext()) // initializes iter.CF
                {
                    returnCF.delete(iter.getColumnFamily());
                }
                iterators.add(iter);
            }

            Comparator<IColumn> comparator = filter.getColumnComparator(getComparator());
            Iterator collated = IteratorUtils.collatedIterator(comparator, iterators);
            if (!collated.hasNext())
                return null;

            filter.collectCollatedColumns(returnCF, collated, gcBefore);
            return returnCF;
        }
        finally
        {
            /* close all cursors */
            for (ColumnIterator ci : iterators)
            {
                try
                {
                    ci.close();
                }
                catch (Throwable th)
                {
                    logger_.error("error closing " + ci, th);
                }
            }
        }
    }

