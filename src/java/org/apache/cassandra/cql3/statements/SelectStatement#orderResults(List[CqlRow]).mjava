    /**
     * Orders results when multiple keys are selected (using IN)
     */
    private void orderResults(List<CqlRow> cqlRows)
    {
        // There is nothing to do if
        //   a. there are no results,
        //   b. no ordering information where given,
        //   c. key restriction wasn't given or it's not an IN expression
        if (cqlRows.isEmpty() || parameters.orderings.isEmpty() || keyRestriction == null || keyRestriction.eqValues.size() < 2)
            return;

        // optimization when only *one* order condition was given
        // because there is no point of using composite comparator if there is only one order condition
        if (parameters.orderings.size() == 1)
        {
            CFDefinition.Name ordering = cfDef.get(parameters.orderings.keySet().iterator().next());
            Collections.sort(cqlRows, new SingleColumnComparator(ordering.position + 1, ordering.type));
            return;
        }

        // figures out where ordering would start in results (startPosition),
        // builds a composite type for multi-column comparison from the comparators of the ordering components
        // and passes collected position information and built composite comparator to CompositeComparator to do
        // an actual comparison of the CQL rows.
        int startPosition = -1;
        List<AbstractType<?>> types = new ArrayList<AbstractType<?>>();

        for (ColumnIdentifier identifier : parameters.orderings.keySet())
        {
            CFDefinition.Name orderingColumn = cfDef.get(identifier);

            if (startPosition == -1)
                startPosition = orderingColumn.position + 1;

            types.add(orderingColumn.type);
        }

        Collections.sort(cqlRows, new CompositeComparator(startPosition, types));
    }

