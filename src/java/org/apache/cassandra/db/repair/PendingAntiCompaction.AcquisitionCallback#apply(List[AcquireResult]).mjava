        public ListenableFuture apply(List<AcquireResult> results) throws Exception
        {
            if (Iterables.any(results, t -> t == null))
            {
                // Release all sstables, and report failure back to coordinator
                for (AcquireResult result : results)
                {
                    if (result != null)
                    {
                        logger.info("Releasing acquired sstables for {}.{}", result.cfs.metadata.keyspace, result.cfs.metadata.name);
                        result.abort();
                    }
                }
                logger.warn("Prepare phase for incremental repair session {} was unable to " +
                            "acquire exclusive access to the neccesary sstables. " +
                            "This is usually caused by running multiple incremental repairs on nodes that share token ranges",
                            parentRepairSession);
                return Futures.immediateFailedFuture(new SSTableAcquisitionException());
            }
            else
            {
                List<ListenableFuture<?>> pendingAntiCompactions = new ArrayList<>(results.size());
                for (AcquireResult result : results)
                {
                    if (result.txn != null)
                    {
                        ListenableFuture<?> future = submitPendingAntiCompaction(result);
                        pendingAntiCompactions.add(future);
                    }
                }

                return Futures.allAsList(pendingAntiCompactions);
            }
        }

