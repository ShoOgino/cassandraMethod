    @Test
    public void mixedModeReadRepairDuplicateRows() throws Throwable
    {
        final String[] workload1 = new String[]
        {
            "DELETE FROM " + DistributedTestBase.KEYSPACE + ".tbl USING TIMESTAMP 1 WHERE pk = 1 AND ck = 2;",
            "INSERT INTO " + DistributedTestBase.KEYSPACE + ".tbl (pk, ck, v) VALUES (1, 1, {'a':'b'}) USING TIMESTAMP 3;",
            "INSERT INTO " + DistributedTestBase.KEYSPACE + ".tbl (pk, ck, v) VALUES (1, 2, {'c':'d'}) USING TIMESTAMP 3;",
            "INSERT INTO " + DistributedTestBase.KEYSPACE + ".tbl (pk, ck, v) VALUES (1, 3, {'e':'f'}) USING TIMESTAMP 3;",
        };

        final String[] workload2 = new String[]
        {
            "INSERT INTO " + DistributedTestBase.KEYSPACE + ".tbl (pk, ck, v) VALUES (1, 2, {'g':'h'}) USING TIMESTAMP 5;",
        };

        new TestCase()
        .nodes(2)
        .upgrade(Versions.Major.v22, Versions.Major.v30)
        .setup((cluster) ->
        {
            cluster.schemaChange("CREATE TABLE " + DistributedTestBase.KEYSPACE + ".tbl (pk int, ck int, v map<text, text>, PRIMARY KEY (pk, ck));");
        })
        .runAfterNodeUpgrade((cluster, node) ->
        {
            if (node == 2)
                return;

            // now node1 is 3.0 and node2 is 2.2
            for (int i = 0; i < workload1.length; i++ )
                cluster.coordinator(2).execute(workload1[i], ConsistencyLevel.QUORUM);

            cluster.get(1).flush(KEYSPACE);
            cluster.get(2).flush(KEYSPACE);

            validate(cluster, 2, false);

            for (int i = 0; i < workload2.length; i++ )
                cluster.coordinator(2).execute(workload2[i], ConsistencyLevel.QUORUM);

            cluster.get(1).flush(KEYSPACE);
            cluster.get(2).flush(KEYSPACE);

            validate(cluster, 1, true);
        })
        .run();
    }

