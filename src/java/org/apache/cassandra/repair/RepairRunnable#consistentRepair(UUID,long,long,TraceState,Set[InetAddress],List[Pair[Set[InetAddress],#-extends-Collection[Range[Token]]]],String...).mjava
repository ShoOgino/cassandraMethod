    private void consistentRepair(UUID parentSession,
                                  long repairedAt,
                                  long startTime,
                                  TraceState traceState,
                                  Set<InetAddress> allNeighbors,
                                  List<Pair<Set<InetAddress>, ? extends Collection<Range<Token>>>> commonRanges,
                                  String... cfnames)
    {
        // the local node also needs to be included in the set of
        // participants, since coordinator sessions aren't persisted
        Set<InetAddress> allParticipants = new HashSet<>(allNeighbors);
        allParticipants.add(FBUtilities.getBroadcastAddress());

        CoordinatorSession coordinatorSession = ActiveRepairService.instance.consistent.coordinated.registerSession(parentSession, allParticipants);
        ListeningExecutorService executor = createExecutor();
        AtomicBoolean hasFailure = new AtomicBoolean(false);
        ListenableFuture repairResult = coordinatorSession.execute(executor,
                                                                   () -> submitRepairSessions(parentSession, repairedAt, true, executor, commonRanges, cfnames),
                                                                   hasFailure);
        Collection<Range<Token>> ranges = new HashSet<>();
        for (Collection<Range<Token>> range : Iterables.transform(commonRanges, cr -> cr.right))
        {
            ranges.addAll(range);
        }
        Futures.addCallback(repairResult, new RepairCompleteCallback(parentSession, ranges, startTime, traceState, hasFailure, executor));
    }

