    /**
     * Validate an array of column slices.
     * To be valid, the slices must be sorted and non-overlapping and each slice must be valid.
     *
     * @throws IllegalArgumentException if the input slices are not valid.
     */
    public static void validate(ColumnSlice[] slices, AbstractType<?> comparator, boolean reversed)
    {
        for (int i = 0; i < slices.length; i++)
        {
            ColumnSlice slice = slices[i];
            validate(slice, comparator, reversed);
            if (i > 0)
            {
                if (slices[i - 1].finish.remaining() == 0 || slice.start.remaining() == 0)
                    throw new IllegalArgumentException("Invalid column slices: slices must be sorted and non-overlapping");

                int cmp = comparator.compare(slices[i -1].finish, slice.start);
                if (reversed ? cmp <= 0 : cmp >= 0)
                    throw new IllegalArgumentException("Invalid column slices: slices must be sorted and non-overlapping");
            }
        }
    }

