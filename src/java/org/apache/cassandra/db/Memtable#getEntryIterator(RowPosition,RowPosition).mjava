    /**
     * @param startWith Include data in the result from and including this key and to the end of the memtable
     * @return An iterator of entries with the data from the start key
     */
    public Iterator<Map.Entry<DecoratedKey, AtomicBTreeColumns>> getEntryIterator(final RowPosition startWith, final RowPosition stopAt)
    {
        return new Iterator<Map.Entry<DecoratedKey, AtomicBTreeColumns>>()
        {
            private Iterator<? extends Map.Entry<RowPosition, AtomicBTreeColumns>> iter = stopAt.isMinimum(cfs.partitioner)
                                                                                        ? rows.tailMap(startWith).entrySet().iterator()
                                                                                        : rows.subMap(startWith, true, stopAt, true).entrySet().iterator();
            private Map.Entry<RowPosition, AtomicBTreeColumns> currentEntry;

            public boolean hasNext()
            {
                return iter.hasNext();
            }

            public Map.Entry<DecoratedKey, AtomicBTreeColumns> next()
            {
                Map.Entry<RowPosition, AtomicBTreeColumns> entry = iter.next();
                // Store the reference to the current entry so that remove() can update the current size.
                currentEntry = entry;
                // Actual stored key should be true DecoratedKey
                assert entry.getKey() instanceof DecoratedKey;
                // Object cast is required since otherwise we can't turn RowPosition into DecoratedKey
                return (Map.Entry<DecoratedKey, AtomicBTreeColumns>) (Object)entry;
            }

            public void remove()
            {
                iter.remove();
                liveDataSize.addAndGet(-currentEntry.getValue().dataSize());
                currentEntry = null;
            }
        };
    }

