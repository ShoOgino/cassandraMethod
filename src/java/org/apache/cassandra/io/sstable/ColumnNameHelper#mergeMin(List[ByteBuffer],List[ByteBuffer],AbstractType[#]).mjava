    /**
     * if columnNameComparator is CompositeType the columns are compared by components using the subcomparator
     * on the same position.
     *
     * if comparator is not CompositeType, the lists are assumed to be of max size 1 and compared using the comparator
     * directly.
     *
     * @param minColumnNames lhs
     * @param candidates rhs
     * @param columnNameComparator comparator to use
     * @return a list with smallest column names according to (sub)comparator
     */
    public static List<ByteBuffer> mergeMin(List<ByteBuffer> minColumnNames, List<ByteBuffer> candidates, AbstractType<?> columnNameComparator)
    {
        if (minColumnNames.isEmpty())
            return candidates;

        if (candidates.isEmpty())
            return minColumnNames;

        if (columnNameComparator instanceof CompositeType)
        {
            CompositeType ct = (CompositeType)columnNameComparator;
            List<ByteBuffer> biggest = minColumnNames.size() > candidates.size() ? minColumnNames : candidates;
            int typeCount = getTypeCount(ct);
            int minSize = Math.min(typeCount, Math.min(minColumnNames.size(), candidates.size()));
            int maxSize = Math.min(typeCount, biggest.size());

            List<ByteBuffer> retList = new ArrayList<ByteBuffer>(maxSize);

            for (int i = 0; i < minSize; i++)
                retList.add(min(minColumnNames.get(i), candidates.get(i), ct.types.get(i)));
            for (int i = minSize; i < maxSize; i++)
                retList.add(biggest.get(i));

            return retList;
        }
        else
        {
            return Collections.singletonList(min(minColumnNames.get(0), candidates.get(0), columnNameComparator));
        }
    }

