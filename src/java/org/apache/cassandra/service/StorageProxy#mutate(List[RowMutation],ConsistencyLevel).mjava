    /**
     * Use this method to have these RowMutations applied
     * across all replicas. This method will take care
     * of the possibility of a replica being down and hint
     * the data across to some other replica.
     *
     * @param mutations the mutations to be applied across the replicas
     * @param consistency_level the consistency level for the operation
    */
    public static void mutate(List<RowMutation> mutations, ConsistencyLevel consistencyLevel) throws UnavailableException, TimeoutException
    {
        long startTime = System.nanoTime();
        List<IWriteResponseHandler> responseHandlers = new ArrayList<IWriteResponseHandler>();

        RowMutation mostRecentRowMutation = null;
        StorageService ss = StorageService.instance;
        String localDataCenter = getDataCenter(FBUtilities.getLocalAddress());
        
        try
        {
            for (RowMutation rm : mutations)
            {
                mostRecentRowMutation = rm;
                String table = rm.getTable();
                AbstractReplicationStrategy rs = Table.open(table).getReplicationStrategy();

                List<InetAddress> naturalEndpoints = ss.getNaturalEndpoints(table, rm.key());
                Collection<InetAddress> writeEndpoints = ss.getTokenMetadata().getWriteEndpoints(StorageService.getPartitioner().getToken(rm.key()), table, naturalEndpoints);
                Multimap<InetAddress, InetAddress> hintedEndpoints = rs.getHintedEndpoints(writeEndpoints);
                
                final IWriteResponseHandler responseHandler = rs.getWriteResponseHandler(writeEndpoints, hintedEndpoints, consistencyLevel);
                
                // exit early if we can't fulfuill the CL at this time
                responseHandler.assureSufficientLiveNodes();
                
                responseHandlers.add(responseHandler);
                
                // Creates a Multimap that holds onto all the messages and addresses meant for a specific datacenter.
                Multimap<String, Pair<Message, InetAddress>> dcMap = groupEndpointsByDataCenter(rm, hintedEndpoints, responseHandler);
				
				// Traverse all dataCenters where messages will be sent to.
                for (Map.Entry<String, Collection<Pair<Message, InetAddress>>> entry : dcMap.asMap().entrySet())
                {
                    String dataCenter = entry.getKey();
                    
                    // Grab a set of all the messages bound for this dataCenter and create an iterator over this set. 
                    Collection<Pair<Message, InetAddress>> messagesForDataCenter = entry.getValue();
                    Iterator<Pair<Message, InetAddress>> iter = messagesForDataCenter.iterator();
                    assert iter.hasNext();

                    // First endpoint in list is the destination for this group
                    Pair<Message, InetAddress> messageAndDestination = iter.next();

                    Message primaryMessage = messageAndDestination.left;
                    InetAddress target = messageAndDestination.right;

                    // Add all the other destinations that are bound for the same dataCenter as a header in the primary message.
                    while (iter.hasNext())
                    {
                        messageAndDestination = iter.next();
                        assert messageAndDestination.left == primaryMessage;
                       
                        if (dataCenter.equals(localDataCenter))
                        {
                            // direct write to local DC
                            assert primaryMessage.getHeader(RowMutation.FORWARD_HEADER) == null;
                            MessagingService.instance.sendOneWay(primaryMessage, target);
                        }
                        else
                        {
                            // group all nodes in this DC as forward headers on the primary message
                            ByteArrayOutputStream bos = new ByteArrayOutputStream();
                            DataOutputStream dos = new DataOutputStream(bos);

                            // append to older addresses
                            byte[] previousHints = primaryMessage.getHeader(RowMutation.FORWARD_HEADER);
                            if (previousHints != null)
                                dos.write(previousHints);

                            dos.write(messageAndDestination.right.getAddress());
                            primaryMessage.setHeader(RowMutation.FORWARD_HEADER, bos.toByteArray());
                        }
                    }                                
                    
                    MessagingService.instance.sendOneWay(primaryMessage, target);
                }
            }
                        
            // wait for writes.  throws timeoutexception if necessary
            for (IWriteResponseHandler responseHandler : responseHandlers)
            {                  
                responseHandler.get();
            }
        }
        catch (IOException e)
        {
            if (mostRecentRowMutation == null)
                throw new RuntimeException("no mutations were seen but found an error during write anyway", e);
            else
                throw new RuntimeException("error writing key " + FBUtilities.bytesToHex(mostRecentRowMutation.key()), e);
        }
        finally
        {
            writeStats.addNano(System.nanoTime() - startTime);
        }

    }

