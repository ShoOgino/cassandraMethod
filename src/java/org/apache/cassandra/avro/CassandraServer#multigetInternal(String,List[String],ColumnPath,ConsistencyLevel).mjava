    private Map<String, ColumnOrSuperColumn> multigetInternal(String keyspace, List<String> keys, ColumnPath cp, ConsistencyLevel level)
    throws InvalidRequestException, UnavailableException, TimedOutException
    {
        AvroValidation.validateColumnPath(keyspace, cp);
        
        // FIXME: This is repetitive.
        byte[] column, super_column;
        column = cp.column == null ? null : cp.column.array();
        super_column = cp.super_column == null ? null : cp.super_column.array();
        
        QueryPath path = new QueryPath(cp.column_family.toString(), column == null ? null : super_column);
        List<byte[]> nameAsList = Arrays.asList(column == null ? super_column : column);
        List<ReadCommand> commands = new ArrayList<ReadCommand>();
        for (String key: keys)
        {
            AvroValidation.validateKey(key);
            commands.add(new SliceByNamesReadCommand(keyspace, key, path, nameAsList));
        }
        
        Map<String, ColumnOrSuperColumn> columnFamiliesMap = new HashMap<String, ColumnOrSuperColumn>();
        Map<String, Collection<IColumn>> columnsMap = multigetColumns(commands, level);
        
        for (ReadCommand command: commands)
        {
            ColumnOrSuperColumn columnorsupercolumn;

            Collection<IColumn> columns = columnsMap.get(command.key);
            if (columns == null)
            {
               columnorsupercolumn = new ColumnOrSuperColumn();
            }
            else
            {
                assert columns.size() == 1;
                IColumn col = columns.iterator().next();


                if (col.isMarkedForDelete())
                {
                    columnorsupercolumn = new ColumnOrSuperColumn();
                }
                else
                {
                    columnorsupercolumn = col instanceof org.apache.cassandra.db.Column
                                          ? newColumnOrSuperColumn(newColumn(col.name(), col.value(), col.timestamp()))
                                          : newColumnOrSuperColumn(newSuperColumn(col.name(), avronateSubColumns(col.getSubColumns())));
                }

            }
            columnFamiliesMap.put(command.key, columnorsupercolumn);
        }

        return columnFamiliesMap;
    }

