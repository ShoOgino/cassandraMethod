    /**
     * @return a ViewFragment containing the sstables and memtables that may need to be merged
     * for rows for all of @param rowBoundsCollection, inclusive, according to the interval tree.
     */
    public Function<View, List<SSTableReader>> viewFilter(final Collection<AbstractBounds<RowPosition>> rowBoundsCollection, final boolean includeRepaired)
    {
        assert AbstractBounds.noneStrictlyWrapsAround(rowBoundsCollection);
        return new Function<View, List<SSTableReader>>()
        {
            public List<SSTableReader> apply(View view)
            {
                Set<SSTableReader> sstables = Sets.newHashSet();
                for (AbstractBounds<RowPosition> rowBounds : rowBoundsCollection)
                {
                    // Note that View.sstablesInBounds always includes it's bound while rowBounds may not. This is ok however
                    // because the fact we restrict the sstables returned by this function is an optimization in the first
                    // place and the returned sstables will (almost) never cover *exactly* rowBounds anyway. It's also
                    // *very* unlikely that a sstable is included *just* because we consider one of the bound inclusively
                    // instead of exclusively, so the performance impact is negligible in practice.
                    for (SSTableReader sstable : view.sstablesInBounds(rowBounds.left, rowBounds.right))
                    {
                        if (includeRepaired || !sstable.isRepaired())
                            sstables.add(sstable);
                    }
                }

                logger.trace("ViewFilter for {}/{} sstables", sstables.size(), getSSTables().size());
                return ImmutableList.copyOf(sstables);
            }
        };
    }

