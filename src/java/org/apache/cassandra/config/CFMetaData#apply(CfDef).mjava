    /**
     * Updates CFMetaData in-place to match cf_def
     *
     * *Note*: This method left public only for DefsTest, don't use directly!
     *
     * @throws ConfigurationException if ks/cf names or cf ids didn't match
     */
    public void apply(CfDef cf_def) throws ConfigurationException
    {
        logger.debug("applying {} to {}", cf_def, this);
        // validate
        if (!cf_def.keyspace.equals(ksName))
            throw new ConfigurationException(String.format("Keyspace mismatch (found %s; expected %s)",
                                                           cf_def.keyspace, ksName));
        if (!cf_def.name.equals(cfName))
            throw new ConfigurationException(String.format("Column family mismatch (found %s; expected %s)",
                                                           cf_def.name, cfName));
        if (cf_def.id != cfId)
            throw new ConfigurationException(String.format("Column family ID mismatch (found %s; expected %s)",
                                                           cf_def.id, cfId));

        if (!cf_def.column_type.equals(cfType.name()))
            throw new ConfigurationException("types do not match.");

        AbstractType<?> newComparator = TypeParser.parse(cf_def.comparator_type);
        AbstractType<?> newSubComparator = (cf_def.subcomparator_type == null || cf_def.subcomparator_type.equals(""))
                                         ? null
                                         : TypeParser.parse(cf_def.subcomparator_type);

        if (!newComparator.isCompatibleWith(comparator))
            throw new ConfigurationException("comparators do not match or are not compatible.");
        if (newSubComparator == null)
        {
            if (subcolumnComparator != null)
                throw new ConfigurationException("subcolumncomparators do not match.");
            // else, it's null and we're good.
        }
        else if (!newSubComparator.isCompatibleWith(subcolumnComparator))
            throw new ConfigurationException("subcolumncomparators do not match or are note compatible.");

        // TODO: this method should probably return a new CFMetaData so that
        // 1) we can keep comparator and subcolumnComparator final
        // 2) updates are applied atomically
        comparator = newComparator;
        subcolumnComparator = newSubComparator;

        validateMinMaxCompactionThresholds(cf_def);

        comment = enforceCommentNotNull(cf_def.comment);
        readRepairChance = cf_def.read_repair_chance;
        if (cf_def.isSetDclocal_read_repair_chance())
            dcLocalReadRepairChance = cf_def.dclocal_read_repair_chance;
        replicateOnWrite = cf_def.replicate_on_write;
        gcGraceSeconds = cf_def.gc_grace_seconds;
        defaultValidator = TypeParser.parse(cf_def.default_validation_class);
        keyValidator = TypeParser.parse(cf_def.key_validation_class);
        minCompactionThreshold = cf_def.min_compaction_threshold;
        maxCompactionThreshold = cf_def.max_compaction_threshold;
        keyAlias = cf_def.key_alias;
        columnAliases = cf_def.column_aliases;
        valueAlias = cf_def.value_alias;
        if (cf_def.isSetBloom_filter_fp_chance())
            bloomFilterFpChance = cf_def.bloom_filter_fp_chance;
        caching = Caching.fromString(cf_def.caching);

        if (!cf_def.isSetColumn_metadata())
            cf_def.setColumn_metadata(new ArrayList<ColumnDef>());

        // adjust column definitions. figure out who is coming and going.
        Set<ByteBuffer> toRemove = new HashSet<ByteBuffer>();
        Set<ByteBuffer> newColumns = new HashSet<ByteBuffer>();
        Set<ColumnDef> toAdd = new HashSet<ColumnDef>();
        for (ColumnDef def : cf_def.column_metadata)
        {
            newColumns.add(def.name);
            if (!column_metadata.containsKey(def.name))
                toAdd.add(def);
        }
        for (ByteBuffer name : column_metadata.keySet())
            if (!newColumns.contains(name))
                toRemove.add(name);
        
        // remove the ones leaving.
        for (ByteBuffer indexName : toRemove)
        {
            column_metadata.remove(indexName);
        }
        // update the ones staying
        for (ColumnDef def : cf_def.column_metadata)
        {
            ColumnDefinition oldDef = column_metadata.get(def.name);
            if (oldDef == null)
                continue;
            oldDef.setValidator(TypeParser.parse(def.validation_class));
            oldDef.setIndexType(def.index_type == null ? null : IndexType.valueOf(def.index_type.name()),
                                def.index_options);
            oldDef.setIndexName(def.index_name == null ? null : def.index_name);
        }
        // add the new ones coming in.
        for (ColumnDef def : toAdd)
        {
            AbstractType<?> dValidClass = TypeParser.parse(def.validation_class);
            ColumnDefinition cd = new ColumnDefinition(def.name, 
                                                       dValidClass,
                                                       def.index_type == null ? null : IndexType.valueOf(def.index_type.name()),
                                                       def.index_options,
                                                       def.index_name == null ? null : def.index_name);
            column_metadata.put(cd.name, cd);
        }

        if (cf_def.compaction_strategy != null)
            compactionStrategyClass = createCompactionStrategy(cf_def.compaction_strategy);

        if (null != cf_def.compaction_strategy_options)
        {
            compactionStrategyOptions = new HashMap<String, String>();
            for (Map.Entry<String, String> e : cf_def.compaction_strategy_options.entrySet())
                compactionStrategyOptions.put(e.getKey(), e.getValue());
        }

        compressionParameters = CompressionParameters.create(cf_def.compression_options);

        logger.debug("application result is {}", this);
    }

