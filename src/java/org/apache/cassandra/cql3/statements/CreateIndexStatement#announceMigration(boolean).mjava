    public boolean announceMigration(boolean isLocalOnly) throws RequestValidationException
    {
        CFMetaData cfm = Schema.instance.getCFMetaData(keyspace(), columnFamily()).copy();
        IndexTarget target = rawTarget.prepare(cfm);

        ColumnDefinition cd = cfm.getColumnDefinition(target.column);
        String acceptedName = indexName;
        if (Strings.isNullOrEmpty(acceptedName))
            acceptedName = Indexes.getAvailableIndexName(keyspace(), columnFamily(), cd.name);

        if (Schema.instance.getKSMetaData(keyspace()).existingIndexNames(null).contains(acceptedName))
        {
            if (ifNotExists)
                return false;
            else
                throw new InvalidRequestException(String.format("Index %s already exists", acceptedName));
        }

        IndexMetadata.IndexType indexType;
        Map<String, String> indexOptions;
        if (properties.isCustom)
        {
            indexType = IndexMetadata.IndexType.CUSTOM;
            indexOptions = properties.getOptions();
        }
        else if (cfm.isCompound())
        {
            Map<String, String> options = Collections.emptyMap();
            // For now, we only allow indexing values for collections, but we could later allow
            // to also index map keys, so we record that this is the values we index to make our
            // lives easier then.
            if (cd.type.isCollection() && cd.type.isMultiCell())
                options = ImmutableMap.of(target.type.indexOption(), "");
            indexType = IndexMetadata.IndexType.COMPOSITES;
            indexOptions = options;
        }
        else
        {
            indexType = IndexMetadata.IndexType.KEYS;
            indexOptions = Collections.emptyMap();
        }

        IndexMetadata index = IndexMetadata.singleColumnIndex(cd, acceptedName, indexType, indexOptions);

        // check to disallow creation of an index which duplicates an existing one in all but name
        Optional<IndexMetadata> existingIndex = Iterables.tryFind(cfm.getIndexes(), existing -> existing.equalsWithoutName(index));
        if (existingIndex.isPresent())
            throw new InvalidRequestException(String.format("Index %s is a duplicate of existing index %s",
                                                            index.name,
                                                            existingIndex.get().name));

        logger.debug("Updating index definition for {}", indexName);
        cfm.indexes(cfm.getIndexes().with(index));

        MigrationManager.announceColumnFamilyUpdate(cfm, false, isLocalOnly);
        return true;
    }

