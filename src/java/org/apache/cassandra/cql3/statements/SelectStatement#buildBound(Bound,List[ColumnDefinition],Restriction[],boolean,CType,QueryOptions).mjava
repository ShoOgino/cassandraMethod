    @VisibleForTesting
    static List<Composite> buildBound(Bound bound,
                                      List<ColumnDefinition> defs,
                                      Restriction[] restrictions,
                                      boolean isReversed,
                                      CType type,
                                      QueryOptions options) throws InvalidRequestException
    {
        CBuilder builder = type.builder();

        // The end-of-component of composite doesn't depend on whether the
        // component type is reversed or not (i.e. the ReversedType is applied
        // to the component comparator but not to the end-of-component itself),
        // it only depends on whether the slice is reversed
        Bound eocBound = isReversed ? Bound.reverse(bound) : bound;
        for (int i = 0, m = defs.size(); i < m; i++)
        {
            ColumnDefinition def = defs.get(i);

            // In a restriction, we always have Bound.START < Bound.END for the "base" comparator.
            // So if we're doing a reverse slice, we must inverse the bounds when giving them as start and end of the slice filter.
            // But if the actual comparator itself is reversed, we must inversed the bounds too.
            Bound b = isReversed == isReversedType(def) ? bound : Bound.reverse(bound);
            Restriction r = restrictions[def.position()];
            if (isNullRestriction(r, b) || !r.canEvaluateWithSlices())
            {
                // There wasn't any non EQ relation on that key, we select all records having the preceding component as prefix.
                // For composites, if there was preceding component and we're computing the end, we must change the last component
                // End-Of-Component, otherwise we would be selecting only one record.
                Composite prefix = builder.build();
                return Collections.singletonList(eocBound == Bound.END ? prefix.end() : prefix.start());
            }
            if (r.isSlice())
            {
                if (r.isMultiColumn())
                {
                    MultiColumnRestriction.Slice slice = (MultiColumnRestriction.Slice) r;

                    if (!slice.hasBound(b))
                    {
                        Composite prefix = builder.build();
                        return Collections.singletonList(builder.remainingCount() > 0 && eocBound == Bound.END
                                ? prefix.end()
                                : prefix);
                    }

                    List<ByteBuffer> vals = slice.componentBounds(b, options);

                    for (int j = 0, n = vals.size(); j < n; j++)
                        addValue(builder, defs.get(i + j), vals.get(j)) ;
                }
                else
                {
                    builder.add(getSliceValue(r, b, options));
                }
                Operator relType = ((Restriction.Slice)r).getRelation(eocBound, b);
                return Collections.singletonList(builder.build().withEOC(eocForRelation(relType)));
            }

            if (r.isIN())
            {
                // The IN query might not have listed the values in comparator order, so we need to re-sort
                // the bounds lists to make sure the slices works correctly (also, to avoid duplicates).
                TreeSet<Composite> inValues = new TreeSet<>(isReversed ? type.reverseComparator() : type);

                if (r.isMultiColumn())
                {
                    List<List<ByteBuffer>> splitInValues = ((MultiColumnRestriction.IN) r).splitValues(options);

                    for (List<ByteBuffer> components : splitInValues)
                    {
                        for (int j = 0; j < components.size(); j++)
                            if (components.get(j) == null)
                                throw new InvalidRequestException("Invalid null value in condition for column " + defs.get(i + j).name);

                        Composite prefix = builder.buildWith(components);
                        inValues.add(builder.remainingCount() == 0 ? prefix : addEOC(prefix, eocBound));
                    }
                    return new ArrayList<>(inValues);
                }

                List<ByteBuffer> values = r.values(options);
                if (values.size() != 1)
                {
                    // IN query, we only support it on the clustering columns
                    assert def.position() == defs.size() - 1;
                    for (ByteBuffer val : values)
                    {
                        if (val == null)
                            throw new InvalidRequestException(String.format("Invalid null value in condition for column %s",
                                                                            def.name));
                        Composite prefix = builder.buildWith(val);
                        // See below for why this
                        inValues.add(builder.remainingCount() == 0 ? prefix : addEOC(prefix, eocBound));
                    }
                    return new ArrayList<>(inValues);
                }
            }

            List<ByteBuffer> values = r.values(options);

            if (r.isMultiColumn())
            {
                for (int j = 0; j < values.size(); j++)
                    addValue(builder, defs.get(i + j), values.get(j));
                i += values.size() - 1; // skips the processed columns
            }
            else
            {
                addValue(builder, def, values.get(0));
            }
        }
        // Means no relation at all or everything was an equal
        // Note: if the builder is "full", there is no need to use the end-of-component bit. For columns selection,
        // it would be harmless to do it. However, we use this method got the partition key too. And when a query
        // with 2ndary index is done, and with the the partition provided with an EQ, we'll end up here, and in that
        // case using the eoc would be bad, since for the random partitioner we have no guarantee that
        // prefix.end() will sort after prefix (see #5240).
        Composite prefix = builder.build();
        return Collections.singletonList(builder.remainingCount() == 0 ? prefix : addEOC(prefix, eocBound));
    }

