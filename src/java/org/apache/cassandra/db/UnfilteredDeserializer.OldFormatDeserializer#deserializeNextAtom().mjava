        private boolean deserializeNextAtom() throws IOException
        {
            if (staticFinished && savedAtom != null)
            {
                nextAtom = savedAtom;
                savedAtom = null;
                return true;
            }

            while (true)
            {
                nextAtom = LegacyLayout.readLegacyAtom(metadata, in, readAllAsDynamic);
                if (nextAtom == null)
                {
                    isDone = true;
                    return false;
                }
                else if (tombstoneTracker.isShadowed(nextAtom))
                {
                    // We don't want to return shadowed data because that would fail the contract
                    // of UnfilteredRowIterator. However the old format could have shadowed data, so filter it here.
                    nextAtom = null;
                    continue;
                }

                tombstoneTracker.update(nextAtom);

                // For static compact tables, the "column_metadata" columns are supposed to be static, but in the old
                // format they are intermingled with other columns. We deal with that with 2 different strategy:
                //  1) for thrift queries, we basically consider everything as a "dynamic" cell. This is ok because
                //     that's basically what we end up with on ThriftResultsMerger has done its thing.
                //  2) otherwise, we make sure to extract the "static" columns first (see AbstractSSTableIterator.readStaticRow
                //     and SSTableSimpleIterator.readStaticRow) as a first pass. So, when we do a 2nd pass for dynamic columns
                //     (which in practice we only do for compactions), we want to ignore those extracted static columns.
                if (skipStatic && metadata.isStaticCompactTable() && nextAtom.isCell())
                {
                    LegacyLayout.LegacyCell cell = nextAtom.asCell();
                    if (cell.name.column.isStatic())
                    {
                        nextAtom = null;
                        continue;
                    }
                }

                // We want to fetch the static row as the first thing this deserializer return.
                // However, in practice, it's possible to have range tombstone before the static row cells
                // if that tombstone has an empty start. So if we do, we save it initially so we can get
                // to the static parts (if there is any).
                if (isStart)
                {
                    isStart = false;
                    if (!nextAtom.isCell())
                    {
                        LegacyLayout.LegacyRangeTombstone tombstone = nextAtom.asRangeTombstone();
                        if (tombstone.start.bound.size() == 0)
                        {
                            savedAtom = tombstone;
                            nextAtom = LegacyLayout.readLegacyAtom(metadata, in, readAllAsDynamic);
                            if (nextAtom == null)
                            {
                                // That was actually the only atom so use it after all
                                nextAtom = savedAtom;
                                savedAtom = null;
                            }
                            else if (!nextAtom.isStatic())
                            {
                                // We don't have anything static. So we do want to send first
                                // the saved atom, so switch
                                LegacyLayout.LegacyAtom atom = nextAtom;
                                nextAtom = savedAtom;
                                savedAtom = atom;
                            }
                        }
                    }
                }

                return true;
            }
        }

