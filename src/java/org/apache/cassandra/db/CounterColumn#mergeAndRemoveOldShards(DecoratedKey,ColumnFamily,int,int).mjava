    /**
     * There is two phase to the removal of old shards.
     * First phase: we merge the old shard value to the current shard and
     * 'nulify' the old one. We then send the counter context with the old
     * shard nulified to all other replica.
     * Second phase: once an old shard has been nulified for longer than
     * gc_grace (to be sure all other replica had been aware of the merge), we
     * simply remove that old shard from the context (it's value is 0).
     * This method does both phases.
     */
    public static void mergeAndRemoveOldShards(DecoratedKey key, ColumnFamily cf, int gcBefore, int mergeBefore)
    {
        ColumnFamily remoteMerger = null;
        if (!cf.isSuper())
        {
            for (Map.Entry<ByteBuffer, IColumn> entry : cf.getColumnsMap().entrySet())
            {
                ByteBuffer cname = entry.getKey();
                IColumn c = entry.getValue();
                if (!(c instanceof CounterColumn))
                    continue;
                CounterColumn cc = (CounterColumn) c;
                CounterColumn shardMerger = cc.computeOldShardMerger(mergeBefore);
                CounterColumn merged = cc;
                if (shardMerger != null)
                {
                    merged = (CounterColumn) cc.reconcile(shardMerger);
                    if (remoteMerger == null)
                        remoteMerger = cf.cloneMeShallow();
                    remoteMerger.addColumn(merged);
                }
                CounterColumn cleaned = merged.removeOldShards(gcBefore);
                if (cleaned != cc)
                {
                    cf.remove(cname);
                    cf.addColumn(cleaned);
                }
            }
        }
        else
        {
            for (Map.Entry<ByteBuffer, IColumn> entry : cf.getColumnsMap().entrySet())
            {
                SuperColumn c = (SuperColumn) entry.getValue();
                for (IColumn subColumn : c.getSubColumns())
                {
                    if (!(subColumn instanceof CounterColumn))
                        continue;
                    CounterColumn cc = (CounterColumn) subColumn;
                    CounterColumn shardMerger = cc.computeOldShardMerger(mergeBefore);
                    CounterColumn merged = cc;
                    if (shardMerger != null)
                    {
                        merged = (CounterColumn) cc.reconcile(shardMerger);
                        if (remoteMerger == null)
                            remoteMerger = cf.cloneMeShallow();
                        remoteMerger.addColumn(c.name(), merged);
                    }
                    CounterColumn cleaned = merged.removeOldShards(gcBefore);
                    if (cleaned != subColumn)
                    {
                        c.remove(subColumn.name());
                        c.addColumn(cleaned);
                    }
                }
            }
        }

        if (remoteMerger != null)
        {
            try
            {
                sendToOtherReplica(key, remoteMerger);
            }
            catch (Exception e)
            {
                logger.error("Error while sending shard merger mutation to remote endpoints", e);
            }
        }
    }

