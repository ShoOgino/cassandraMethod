    /**
     *  This method performs the read from the replicas.
     *  param @ key - key for which the data is required.
     *  param @ readMessage - the read message to get the actual data
     *  param @ readMessageDigest - the read message to get the digest.
    */
    private static Row doStrongReadProtocol(String key, ReadMessage readMessage, ReadMessage readMessageDigest) throws IOException, TimeoutException
    {
        Row row = null;
        Message message = ReadMessage.makeReadMessage(readMessage);
        Message messageDigestOnly = ReadMessage.makeReadMessage(readMessageDigest);
        
        IResponseResolver<Row> readResponseResolver = new ReadResponseResolver();
        QuorumResponseHandler<Row> quorumResponseHandler = new QuorumResponseHandler<Row>(
                DatabaseDescriptor.getReplicationFactor(),
                readResponseResolver);
        EndPoint dataPoint = StorageService.instance().findSuitableEndPoint(key);
        List<EndPoint> endpointList = new ArrayList<EndPoint>( Arrays.asList( StorageService.instance().getNStorageEndPoint(key) ) );
        /* Remove the local storage endpoint from the list. */ 
        endpointList.remove( dataPoint );
        EndPoint[] endPoints = new EndPoint[endpointList.size() + 1];
        Message messages[] = new Message[endpointList.size() + 1];
        
        /* 
         * First message is sent to the node that will actually get
         * the data for us. The other two replicas are only sent a 
         * digest query.
        */
        endPoints[0] = dataPoint;
        messages[0] = message;        
        for (int i=1; i < endPoints.length ; i++)
        {
            endPoints[i] = endpointList.get(i-1);
            messages[i] = messageDigestOnly;
        }
        
        try
        {
            MessagingService.getMessagingInstance().sendRR(messages, endPoints, quorumResponseHandler);            
            long startTime2 = System.currentTimeMillis();
            row = quorumResponseHandler.get();
            logger_.debug("quorumResponseHandler: " + (System.currentTimeMillis() - startTime2)
                    + " ms.");
            if (row == null)
            {
                logger_.info("ERROR No row for this key .....: " + key);
                // TODO: throw a thrift exception 
                return row;
            }
        }
        catch (DigestMismatchException ex)
        {
            if ( DatabaseDescriptor.getConsistencyCheck())
            {
	            IResponseResolver<Row> readResponseResolverRepair = new ReadResponseResolver();
	            QuorumResponseHandler<Row> quorumResponseHandlerRepair = new QuorumResponseHandler<Row>(
	                    DatabaseDescriptor.getReplicationFactor(),
	                    readResponseResolverRepair);
	            readMessage.setIsDigestQuery(false);
	            logger_.info("DigestMismatchException: " + key);            
	            Message messageRepair = ReadMessage.makeReadMessage(readMessage);
	            MessagingService.getMessagingInstance().sendRR(messageRepair, endPoints, quorumResponseHandlerRepair);
	            try
	            {
	                row = quorumResponseHandlerRepair.get();
	            }
	            catch(DigestMismatchException dex)
	            {
	                logger_.warn(LogUtil.throwableToString(dex));
	            }
	            if (row == null)
	            {
	                logger_.info("ERROR No row for this key .....: " + key);                
	            }
            }
        }        
        return row;
    }

