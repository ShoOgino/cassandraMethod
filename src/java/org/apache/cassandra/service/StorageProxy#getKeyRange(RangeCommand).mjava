    static List<String> getKeyRange(RangeCommand rawCommand) throws IOException, UnavailableException
    {
        long startTime = System.currentTimeMillis();
        TokenMetadata tokenMetadata = StorageService.instance().getTokenMetadata();
        List<String> allKeys = new ArrayList<String>();
        RangeCommand command = rawCommand;

        InetAddress endPoint = StorageService.instance().findSuitableEndPoint(command.startWith);
        InetAddress startEndpoint = endPoint;
        InetAddress wrapEndpoint = tokenMetadata.getFirstEndpoint();

        do
        {
            Message message = command.getMessage();
            if (logger.isDebugEnabled())
                logger.debug("reading " + command + " from " + message.getMessageId() + "@" + endPoint);
            IAsyncResult iar = MessagingService.instance().sendRR(message, endPoint);

            // read response
            byte[] responseBody;
            try
            {
                responseBody = iar.get(DatabaseDescriptor.getRpcTimeout(), TimeUnit.MILLISECONDS);
            }
            catch (TimeoutException e)
            {
                throw new RuntimeException(e);
            }
            RangeReply rangeReply = RangeReply.read(responseBody);
            List<String> rangeKeys = rangeReply.keys;

            // combine keys from most recent response with the others seen so far
            if (rangeKeys.size() > 0)
            {
                if (allKeys.size() > 0)
                {
                    Comparator<String> comparator = new Comparator<String>()
                    {
                        public int compare(String o1, String o2)
                        {
                            IPartitioner p = StorageService.getPartitioner();
                            return p.getDecoratedKeyComparator().compare(p.decorateKey(o1), p.decorateKey(o2));
                        }
                    };

                    if (comparator.compare(rangeKeys.get(rangeKeys.size() - 1), allKeys.get(0)) <= 0)
                    {
                        // unlikely, but possible
                        if (rangeKeys.get(rangeKeys.size() - 1).equals(allKeys.get(0)))
                        {
                            rangeKeys.remove(rangeKeys.size() - 1);
                        }
                        rangeKeys.addAll(allKeys);
                        allKeys = rangeKeys;
                    }
                    else if (comparator.compare(allKeys.get(allKeys.size() - 1), rangeKeys.get(0)) <= 0)
                    {
                        // common case. deal with simple start/end key overlaps
                        if (allKeys.get(allKeys.size() - 1).equals(rangeKeys.get(0)))
                        {
                            allKeys.remove(allKeys.size() - 1);
                        }
                        allKeys.addAll(rangeKeys);
                    }
                    else
                    {
                        // deal with potential large overlap from scanning the first endpoint, which contains
                        // both the smallest and largest keys
                        HashSet<String> keys = new HashSet<String>(allKeys);
                        keys.addAll(rangeKeys);
                        allKeys = new ArrayList<String>(keys);
                        Collections.sort(allKeys);
                    }
                }
                else
                {
                    allKeys = rangeKeys;
                }
            }

            if (allKeys.size() >= rawCommand.maxResults || rangeReply.rangeCompletedLocally)
            {
                break;
            }

            // set up the next query --
            // it's tempting to try to optimize this by starting with the last key seen for the next node,
            // but that won't work when you have a replication factor of more than one--any node, not just
            // the one holding the keys where the range wraps, could include both the smallest keys, and the largest,
            // so starting with the largest in our scan of the next node means we'd never see keys from the middle.
            do
            {
                endPoint = tokenMetadata.getSuccessor(endPoint); // TODO move this into the Strategies & modify for RackAwareStrategy
            } while (!FailureDetector.instance().isAlive(endPoint));
            int maxResults = endPoint.equals(wrapEndpoint) ? rawCommand.maxResults : rawCommand.maxResults - allKeys.size();
            command = new RangeCommand(command.table, command.columnFamily, command.startWith, command.stopAt, maxResults);
        } while (!endPoint.equals(startEndpoint));

        rangeStats.add(System.currentTimeMillis() - startTime);
        return (allKeys.size() > rawCommand.maxResults)
               ? allKeys.subList(0, rawCommand.maxResults)
               : allKeys;
    }

