    private ResultSet process(List<Row> rows, List<ByteBuffer> variables, int limit) throws InvalidRequestException
    {
        Selection.ResultSetBuilder result = selection.resultSetBuilder();
        for (org.apache.cassandra.db.Row row : rows)
        {
            // Not columns match the query, skip
            if (row.cf == null)
                continue;

            ByteBuffer[] keyComponents = cfDef.hasCompositeKey
                                       ? ((CompositeType)cfDef.cfm.getKeyValidator()).split(row.key.key)
                                       : new ByteBuffer[]{ row.key.key };

            if (cfDef.isCompact)
            {
                // One cqlRow per column
                for (Column c : columnsInOrder(row.cf, variables))
                {
                    if (c.isMarkedForDelete())
                        continue;

                    ByteBuffer[] components = null;
                    if (cfDef.isComposite)
                    {
                        components = ((CompositeType)cfDef.cfm.comparator).split(c.name());
                    }
                    else if (sliceRestriction != null)
                    {
                        // For dynamic CF, the column could be out of the requested bounds, filter here
                        if (!sliceRestriction.isInclusive(Bound.START) && c.name().equals(sliceRestriction.bound(Bound.START).bindAndGet(variables)))
                            continue;
                        if (!sliceRestriction.isInclusive(Bound.END) && c.name().equals(sliceRestriction.bound(Bound.END).bindAndGet(variables)))
                            continue;
                    }

                    result.newRow();
                    // Respect selection order
                    for (CFDefinition.Name name : selection.getColumnsList())
                    {
                        switch (name.kind)
                        {
                            case KEY_ALIAS:
                                result.add(keyComponents[name.position]);
                                break;
                            case COLUMN_ALIAS:
                                ByteBuffer val = cfDef.isComposite
                                               ? (name.position < components.length ? components[name.position] : null)
                                               : c.name();
                                result.add(val);
                                break;
                            case VALUE_ALIAS:
                                result.add(c);
                                break;
                            case COLUMN_METADATA:
                                // This should not happen for compact CF
                                throw new AssertionError();
                            default:
                                throw new AssertionError();
                        }
                    }
                }
            }
            else if (cfDef.isComposite)
            {
                // Sparse case: group column in cqlRow when composite prefix is equal
                CompositeType composite = (CompositeType)cfDef.cfm.comparator;

                ColumnGroupMap.Builder builder = new ColumnGroupMap.Builder(composite, cfDef.hasCollections);

                for (Column c : row.cf)
                {
                    if (c.isMarkedForDelete())
                        continue;

                    builder.add(c);
                }

                for (ColumnGroupMap group : builder.groups())
                    handleGroup(selection, result, keyComponents, group);
            }
            else
            {
                if (row.cf.hasOnlyTombstones())
                    continue;

                // Static case: One cqlRow for all columns
                result.newRow();
                for (CFDefinition.Name name : selection.getColumnsList())
                {
                    if (name.kind == CFDefinition.Name.Kind.KEY_ALIAS)
                        result.add(keyComponents[name.position]);
                    else
                        result.add(row.cf.getColumn(name.name.key));
                }
            }
        }

        ResultSet cqlRows = result.build();

        orderResults(cqlRows);

        // Internal calls always return columns in the comparator order, even when reverse was set
        if (isReversed)
            cqlRows.reverse();

        // Trim result if needed to respect the limit
        cqlRows.trim(limit);
        return cqlRows;
    }

