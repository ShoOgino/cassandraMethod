    private static void applyCounterMutation(final IMutation mutation, final Multimap<InetAddress, InetAddress> hintedEndpoints, final IWriteResponseHandler responseHandler, final String localDataCenter, final ConsistencyLevel consistency_level, boolean executeOnMutationStage)
    {
        // we apply locally first, then send it to other replica
        if (logger.isDebugEnabled())
            logger.debug("insert writing local & replicate " + mutation.toString(true));

        Runnable runnable = new DroppableRunnable(StorageService.Verb.MUTATION)
        {
            public void runMayThrow() throws IOException
            {
                assert mutation instanceof CounterMutation;
                final CounterMutation cm = (CounterMutation) mutation;

                // apply mutation
                cm.apply();

                responseHandler.response(null);

                if (cm.shouldReplicateOnWrite())
                {
                    // We do the replication on another stage because it involves a read (see CM.makeReplicationMutation)
                    // and we want to avoid blocking too much the MUTATION stage
                    StageManager.getStage(Stage.REPLICATE_ON_WRITE).execute(new DroppableRunnable(StorageService.Verb.READ)
                    {
                        public void runMayThrow() throws IOException
                        {
                            // send mutation to other replica
                            sendToHintedEndpoints(cm.makeReplicationMutation(), hintedEndpoints, responseHandler, localDataCenter, false, consistency_level);
                        }
                    });
                }
            }
        };
        if (executeOnMutationStage)
            StageManager.getStage(Stage.MUTATION).execute(runnable);
        else
            runnable.run();
    }

