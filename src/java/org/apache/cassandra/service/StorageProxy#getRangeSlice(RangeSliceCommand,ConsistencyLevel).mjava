    public static List<Pair<String, ColumnFamily>> getRangeSlice(RangeSliceCommand command, ConsistencyLevel consistency_level)
    throws IOException, UnavailableException, TimeoutException
    {
        long startTime = System.currentTimeMillis();
        TokenMetadata tokenMetadata = StorageService.instance.getTokenMetadata();

        InetAddress endPoint = StorageService.instance.getPrimary(command.startKey.token);
        InetAddress startEndpoint = endPoint;
        int responseCount = determineBlockFor(DatabaseDescriptor.getReplicationFactor(), DatabaseDescriptor.getReplicationFactor(), consistency_level);

        Map<String, ColumnFamily> rows = new HashMap<String, ColumnFamily>(command.max_keys);
        do
        {
            Range primaryRange = StorageService.instance.getPrimaryRangeForEndPoint(endPoint);
            List<InetAddress> endpoints = StorageService.instance.getLiveNaturalEndpoints(primaryRange.right);
            if (endpoints.size() < responseCount)
                throw new UnavailableException();

            // to make comparing the results from each node easy, we restrict each command to the data in the primary range for this iteration
            DecoratedKey<?> startKey;
            DecoratedKey<?> finishKey;
            if (primaryRange.left.equals(primaryRange.right))
            {
                startKey = command.startKey;
                finishKey = command.finishKey;
            }
            else
            {
                startKey = (DecoratedKey<?>) ObjectUtils.max(command.startKey, new DecoratedKey<Token<?>>(primaryRange.left, null));
                finishKey = command.finishKey.isEmpty()
                          ? new DecoratedKey<Token<?>>(primaryRange.right, null)
                          : (DecoratedKey<?>) ObjectUtils.min(command.finishKey, new DecoratedKey<Token<?>>(primaryRange.right, null));
            }
            RangeSliceCommand c2 = new RangeSliceCommand(command.keyspace, command.column_family, command.super_column, command.predicate, startKey, finishKey, command.max_keys, command.includeStartKey);
            Message message = c2.getMessage();

            // collect replies and resolve according to consistency level
            RangeSliceResponseResolver resolver = new RangeSliceResponseResolver(command.keyspace, primaryRange, endpoints);
            QuorumResponseHandler<Map<String, ColumnFamily>> handler = new QuorumResponseHandler<Map<String, ColumnFamily>>(responseCount, resolver);
            if (logger.isDebugEnabled())
                logger.debug("reading " + command + " for " + primaryRange + " from " + message.getMessageId() + "@" + endPoint);
            for (InetAddress replicaEndpoint : endpoints)
            {
                MessagingService.instance.sendRR(message, replicaEndpoint, handler);
            }

            // if we're done, great, otherwise, move to the next range
            try
            {
                rows.putAll(handler.get());
            }
            catch (DigestMismatchException e)
            {
                throw new AssertionError(e); // no digests in range slices yet
            }
            if (rows.size() >= command.max_keys || resolver.completed())
                break;

            endPoint = tokenMetadata.getSuccessor(endPoint);
        }
        while (!endPoint.equals(startEndpoint));

        List<Pair<String, ColumnFamily>> results = new ArrayList<Pair<String, ColumnFamily>>(rows.size());
        for (Map.Entry<String, ColumnFamily> entry : rows.entrySet())
        {
            ColumnFamily cf = entry.getValue();
            results.add(new Pair<String, ColumnFamily>(entry.getKey(), cf));
        }
        Collections.sort(results, new Comparator<Pair<String, ColumnFamily>>()
        {
            public int compare(Pair<String, ColumnFamily> o1, Pair<String, ColumnFamily> o2)
            {
                return keyComparator.compare(o1.left, o2.left);                
            }
        });
        rangeStats.add(System.currentTimeMillis() - startTime);
        return results;
    }

