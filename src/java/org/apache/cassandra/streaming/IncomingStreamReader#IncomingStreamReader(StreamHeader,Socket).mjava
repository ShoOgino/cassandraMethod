    public IncomingStreamReader(StreamHeader header, Socket socket) throws IOException
    {
        socket.setSoTimeout(DatabaseDescriptor.getStreamingSocketTimeout());
        InetAddress host = ((InetSocketAddress)socket.getRemoteSocketAddress()).getAddress();
        if (header.pendingFiles.isEmpty() && header.file != null)
        {
            // StreamInSession should be created already when receiving 2nd and after files
            if (!StreamInSession.hasSession(header.sessionId))
            {
                StreamReply reply = new StreamReply("", header.sessionId, StreamReply.Status.SESSION_FAILURE);
                FileStreamTask.sendReply(reply.createMessage(), new DataOutputStream(socket.getOutputStream()));
                throw new IOException("Session " + header.sessionId + " already closed.");
            }
        }
        session = StreamInSession.get(host, header.sessionId);
        session.setSocket(socket);

        session.addFiles(header.pendingFiles);
        // set the current file we are streaming so progress shows up in jmx
        session.setCurrentFile(header.file);
        session.setTable(header.table);
        // pendingFile gets the new context for the local node.
        remoteFile = header.file;
        localFile = remoteFile != null ? StreamIn.getContextMapping(remoteFile) : null;

        if (remoteFile != null)
        {
            if (remoteFile.compressionInfo == null)
                underliningStream = new LZFInputStream(socket.getInputStream());
            else
                underliningStream = new CompressedInputStream(socket.getInputStream(), remoteFile.compressionInfo);
        }
        else
        {
            underliningStream = null;
        }
        metrics = StreamingMetrics.get(host);
    }

