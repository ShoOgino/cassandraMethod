    private SerializationHeader(AbstractType<?> keyType,
                                List<AbstractType<?>> clusteringTypes,
                                PartitionColumns columns,
                                EncodingStats stats,
                                Map<ByteBuffer, AbstractType<?>> typeMap)
    {
        this.keyType = keyType;
        this.clusteringTypes = clusteringTypes;
        this.columns = columns;
        this.stats = stats;
        this.typeMap = typeMap;

        // For the dense layout, we have a 1 byte overhead for absent columns. For the sparse layout, it's a 1
        // overhead for present columns (in fact we use a 2 byte id, but assuming vint encoding, we'll pay 2 bytes
        // only for the columns after the 128th one and for simplicity we assume that once you have that many column,
        // you'll tend towards a clearly dense or clearly sparse case so that the heurstic above shouldn't still be
        // too inapropriate). So if on average more than half of our columns are set per row, we better go for sparse.
        this.useSparseColumnLayout = stats.avgColumnSetPerRow <= (columns.regulars.columnCount()/ 2);
    }

