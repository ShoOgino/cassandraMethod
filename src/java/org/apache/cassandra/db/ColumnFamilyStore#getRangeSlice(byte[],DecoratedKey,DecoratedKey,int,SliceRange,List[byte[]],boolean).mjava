    /**
     *
     * @param super_column
     * @param startKey key to start at (inclusive). empty string = start at the beginning.
     * @param finishKey key to stop at (inclusive). empty string = stop at the end.
     * @param keyMax maximum number of keys to process, regardless of startKey/finishKey
     * @param sliceRange may be null if columnNames is specified. specifies contiguous columns to return in what order.
     * @param columnNames may be null if sliceRange is specified. specifies which columns to return in what order.      @return list of key->list<column> tuples.
     * @param includeStartKey
     * @throws IOException
     * @throws ExecutionException
     * @throws InterruptedException
     */
    public RangeSliceReply getRangeSlice(byte[] super_column, final DecoratedKey startKey, final DecoratedKey finishKey, int keyMax, SliceRange sliceRange, List<byte[]> columnNames, boolean includeStartKey)
    throws IOException, ExecutionException, InterruptedException
    {
        List<String> keys = new ArrayList<String>();
        boolean completed;
        if (finishKey.isEmpty() || startKey.compareTo(finishKey) <= 0)
        {
            completed = getKeyRange(keys, startKey, finishKey, keyMax, includeStartKey);
        }
        else
        {
            // wrapped range
            DecoratedKey emptyKey = new DecoratedKey(StorageService.getPartitioner().getMinimumToken(), null);
            completed = getKeyRange(keys, startKey, emptyKey, keyMax, includeStartKey);
            if (!completed)
            {
                completed = getKeyRange(keys, emptyKey, finishKey, keyMax, true);
            }
        }
        List<Row> rows = new ArrayList<Row>(keys.size());
        final QueryPath queryPath =  new QueryPath(columnFamily_, super_column, null);
        final SortedSet<byte[]> columnNameSet = new TreeSet<byte[]>(getComparator());
        if (columnNames != null)
            columnNameSet.addAll(columnNames);
        for (String key : keys)
        {
            QueryFilter filter = sliceRange == null ? new NamesQueryFilter(key, queryPath, columnNameSet) : new SliceQueryFilter(key, queryPath, sliceRange.start, sliceRange.finish, sliceRange.reversed, sliceRange.count);
            rows.add(new Row(key, getColumnFamily(filter)));
        }

        return new RangeSliceReply(rows, completed);
    }

