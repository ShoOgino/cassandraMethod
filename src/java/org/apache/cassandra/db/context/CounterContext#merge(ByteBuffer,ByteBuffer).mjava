    /**
     * Return a context w/ an aggregated count for each node id.
     *
     * @param left
     *            counter context.
     * @param right
     *            counter context.
     */
    public ByteBuffer merge(ByteBuffer left, ByteBuffer right)
    {
        // Compute size of result
        int size = 0;
        int leftOffset  = left.position();
        int rightOffset = right.position();
        while ((leftOffset < left.limit()) && (rightOffset < right.limit()))
        {
            int cmp = ByteBufferUtil.compareSubArrays(left, leftOffset, right, rightOffset, idLength);
            if (cmp == 0)
            {
                ++size;
                rightOffset += stepLength;
                leftOffset += stepLength;
            }
            else if (cmp > 0)
            {
                ++size;
                rightOffset += stepLength;
            }
            else // cmp < 0
            {
                ++size;
                leftOffset += stepLength;
            }
        }
        size += (left.limit() - leftOffset)  / stepLength;
        size += (right.limit() - rightOffset) / stepLength;

        ByteBuffer merged = ByteBuffer.allocate(size * stepLength);

        // Do the actual merge:
        //   a) local id:  sum clocks, counts
        //   b) remote id: keep highest clock, count (reconcile)
        int mergedOffset = merged.position();
        leftOffset = left.position();
        rightOffset = right.position();
        while ((leftOffset < left.limit()) && (rightOffset < right.limit()))
        {
            int cmp = ByteBufferUtil.compareSubArrays(left, leftOffset, right, rightOffset, idLength);
            if (cmp == 0)
            {
                // sum for local id, keep highest othewise
                long leftClock = left.getLong(leftOffset + idLength);
                long rightClock = right.getLong(rightOffset + idLength);
                if (ByteBufferUtil.compareSubArrays(left, leftOffset, wrappedLocalId, 0, idLength) == 0)
                {
                    long leftCount = left.getLong(leftOffset + idLength + clockLength);
                    long rightCount = right.getLong(rightOffset + idLength + clockLength);
                    writeElementAtOffset(merged, mergedOffset, localId, leftClock + rightClock, leftCount + rightCount);
                }
                else
                {
                    if (leftClock >= rightClock)
                        ByteBufferUtil.arrayCopy(left, leftOffset, merged, mergedOffset, stepLength);
                    else
                        ByteBufferUtil.arrayCopy(right, rightOffset, merged, mergedOffset, stepLength);
                }
                mergedOffset += stepLength;
                rightOffset += stepLength;
                leftOffset += stepLength;
            }
            else if (cmp > 0)
            {
                ByteBufferUtil.arrayCopy(right, rightOffset, merged, mergedOffset, stepLength);
                mergedOffset += stepLength;
                rightOffset += stepLength;
            }
            else // cmp < 0
            {
                ByteBufferUtil.arrayCopy(left, leftOffset, merged, mergedOffset, stepLength);
                mergedOffset += stepLength;
                leftOffset += stepLength;
            }
        }
        if (leftOffset < left.limit())
            ByteBufferUtil.arrayCopy(
                left,
                leftOffset,
                merged,
                mergedOffset,
                left.limit() - leftOffset);
        if (rightOffset < right.limit())
            ByteBufferUtil.arrayCopy(
                right,
                rightOffset,
                merged,
                mergedOffset,
                right.limit() - rightOffset);

        return merged;
    }

