    public ArrayList<InetAddress> getNaturalEndpoints(Token searchToken, TokenMetadata metadata, String table)
    {
        ArrayList<InetAddress> endpoints = new ArrayList<InetAddress>();

        if (metadata.sortedTokens().isEmpty())
            return endpoints;

        for (String dc : dcTokens.keySet())
        {
            List<Token> tokens = dcTokens.get(dc);
            Set<String> racks = new HashSet<String>();
            // Add the node at the index by default
            Iterator<Token> iter = TokenMetadata.ringIterator(tokens, searchToken);
            InetAddress initialDCHost = metadata.getEndpoint(iter.next());
            assert initialDCHost != null;
            endpoints.add(initialDCHost);
            racks.add(snitch.getRack(initialDCHost));

            // find replicas on unique racks
            int replicas = getReplicationFactor(dc, table);
            int localEndpoints = 1;
            while (localEndpoints < replicas && iter.hasNext())
            {
                Token t = iter.next();
                InetAddress endpoint = metadata.getEndpoint(t);
                if (!racks.contains(snitch.getRack(endpoint)))
                {
                    endpoints.add(endpoint);
                    localEndpoints++;
                }
            }

            if (localEndpoints == replicas)
                continue;

            // if not enough unique racks were found, re-loop and add other endpoints
            iter = TokenMetadata.ringIterator(tokens, searchToken);
            iter.next(); // skip the first one since we already know it's used
            while (localEndpoints < replicas && iter.hasNext())
            {
                Token t = iter.next();
                if (!endpoints.contains(metadata.getEndpoint(t)))
                {
                    localEndpoints++;
                    endpoints.add(metadata.getEndpoint(t));
                }
            }
        }

        return endpoints;
    }

