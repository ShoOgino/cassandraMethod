        /**
         * Queries the provided sub-range.
         *
         * @param replicaLayout the subRange to query.
         * @param isFirst in the case where multiple queries are sent in parallel, whether that's the first query on
         * that batch or not. The reason it matters is that whe paging queries, the command (more specifically the
         * {@code DataLimits}) may have "state" information and that state may only be valid for the first query (in
         * that it's the query that "continues" whatever we're previously queried).
         */
        private SingleRangeResponse query(ReplicaLayout.ForRange replicaLayout, boolean isFirst)
        {
            PartitionRangeReadCommand rangeCommand = command.forSubRange(replicaLayout.range, isFirst);
            ReadRepair<EndpointsForRange, ReplicaLayout.ForRange> readRepair = ReadRepair.create(command, replicaLayout, queryStartNanoTime);
            DataResolver<EndpointsForRange, ReplicaLayout.ForRange> resolver = new DataResolver<>(rangeCommand, replicaLayout, readRepair, queryStartNanoTime);
            Keyspace keyspace = Keyspace.open(command.metadata().keyspace);

            ReadCallback<EndpointsForRange, ReplicaLayout.ForRange> handler = new ReadCallback<>(resolver,
                                                                                                 replicaLayout.consistencyLevel().blockFor(keyspace),
                                                                                                 rangeCommand,
                                                                                                 replicaLayout,
                                                                                                 queryStartNanoTime);

            handler.assureSufficientLiveNodes();

            // If enabled, request repaired data tracking info from full replicas but
            // only if there are multiple full replicas to compare results from
            if (DatabaseDescriptor.getRepairedDataTrackingForPartitionReadsEnabled()
                && replicaLayout.selected().filter(Replica::isFull).size() > 1)
            {
                command.trackRepairedStatus();
            }

            if (replicaLayout.selected().size() == 1 && replicaLayout.selected().get(0).isLocal())
            {
                StageManager.getStage(Stage.READ).execute(new LocalReadRunnable(rangeCommand, handler));
            }
            else
            {
                for (Replica replica : replicaLayout.selected())
                {
                    Tracing.trace("Enqueuing request to {}", replica);
                    MessageOut<ReadCommand> message = rangeCommand.createMessage();
                    if (command.isTrackingRepairedStatus() && replica.isFull())
                        message =  message.withParameter(ParameterType.TRACK_REPAIRED_DATA, MessagingService.ONE_BYTE);
                    MessagingService.instance().sendRRWithFailure(message, replica.endpoint(), handler);
                }
            }

            return new SingleRangeResponse(resolver, handler, readRepair);
        }

