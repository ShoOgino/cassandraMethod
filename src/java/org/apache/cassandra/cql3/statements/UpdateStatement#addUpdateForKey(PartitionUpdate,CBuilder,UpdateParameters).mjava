    public void addUpdateForKey(PartitionUpdate update, CBuilder cbuilder, UpdateParameters params)
    throws InvalidRequestException
    {
        if (updatesRegularRows())
        {
            params.newRow(cbuilder.build());

            // We update the row timestamp (ex-row marker) only on INSERT (#6782)
            // Further, COMPACT tables semantic differs from "CQL3" ones in that a row exists only if it has
            // a non-null column, so we don't want to set the row timestamp for them.
            if (type == StatementType.INSERT && cfm.isCQLTable())
                params.addPrimaryKeyLivenessInfo();

            List<Operation> updates = getRegularOperations();

            // For compact tablw, when we translate it to thrift, we don't have a row marker. So we don't accept an insert/update
            // that only sets the PK unless the is no declared non-PK columns (in the latter we just set the value empty).

            // For a dense layout, when we translate it to thrift, we don't have a row marker. So we don't accept an insert/update
            // that only sets the PK unless the is no declared non-PK columns (which we recognize because in that case the compact
            // value is of type "EmptyType").
            if (cfm.isCompactTable() && updates.isEmpty())
            {
                if (CompactTables.hasEmptyCompactValue(cfm))
                    updates = Collections.<Operation>singletonList(new Constants.Setter(cfm.compactValueColumn(), EMPTY));
                else
                    throw new InvalidRequestException(String.format("Column %s is mandatory for this COMPACT STORAGE table", cfm.compactValueColumn().name));
            }

            for (Operation op : updates)
                op.execute(update.partitionKey(), params);

            update.add(params.buildRow());
        }

        if (updatesStaticRow())
        {
            params.newRow(Clustering.STATIC_CLUSTERING);
            for (Operation op : getStaticOperations())
                op.execute(update.partitionKey(), params);
            update.add(params.buildRow());
        }

        params.validateIndexedColumns(update);
    }

