    public void serialize(ReadCommand command, DataOutput out, int version) throws IOException
    {
        // For super columns, when talking to an older node, we need to translate the filter used.
        // That translation can change the filter type (names -> slice), and so change the command type.
        // Hence we need to detect that early on, before we've written the command type.
        ReadCommand newCommand = command;
        ByteBuffer superColumn = null;
        if (version < MessagingService.VERSION_20)
        {
            CFMetaData metadata = Schema.instance.getCFMetaData(command.table, command.cfName);
            if (metadata.cfType == ColumnFamilyType.Super)
            {
                SuperColumns.SCFilter scFilter = SuperColumns.filterToSC((CompositeType)metadata.comparator, command.filter());
                newCommand = ReadCommand.create(command.table, command.key, command.cfName, command.timestamp, scFilter.updatedFilter);
                newCommand.setDigestQuery(command.isDigestQuery());
                superColumn = scFilter.scName;
            }
        }

        out.writeByte(newCommand.commandType.serializedValue);
        switch (command.commandType)
        {
            case GET_BY_NAMES:
                SliceByNamesReadCommand.serializer.serialize(newCommand, superColumn, out, version);
                break;
            case GET_SLICES:
                SliceFromReadCommand.serializer.serialize(newCommand, superColumn, out, version);
                break;
            default:
                throw new AssertionError();
        }
    }

