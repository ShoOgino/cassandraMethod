    private synchronized Future closeSession(State finalState)
    {
        Future abortedTasksFuture = null;
        if (isAborted.compareAndSet(false, true))
        {
            state(finalState);

            // ensure aborting the tasks do not happen on the network IO thread (read: netty event loop)
            // as we don't want any blocking disk IO to stop the network thread
            if (finalState == State.FAILED)
                abortedTasksFuture = ScheduledExecutors.nonPeriodicTasks.submit(this::abortTasks);

            incomingChannels.values().stream().map(channel -> channel.close());
            messageSender.close();

            streamResult.handleSessionComplete(this);
        }
        return abortedTasksFuture != null ? abortedTasksFuture : Futures.immediateFuture(null);
    }

