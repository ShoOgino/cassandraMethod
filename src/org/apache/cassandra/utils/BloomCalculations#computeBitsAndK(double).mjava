    /**
     * Given a maximum tolerable false positive probability, compute a Bloom
     * specification which will give less than the specified false positive rate,
     * but minimize the number of bits per element and the number of hash
     * functions used.  Because bandwidth (and therefore total bitvector size)
     * is considered more expensive than computing power, preference is given
     * to minimizing bits per element rather than number of hash funtions.
     *
     * @param maxFalsePosProb The maximum tolerable false positive rate.
     * @return A Bloom Specification which would result in a false positive rate
     * less than specified by the function call.
     */
    public static BloomSpecification computeBitsAndK(double maxFalsePosProb){
        BloomSpecification spec = new BloomSpecification();
        spec.bitsPerElement = 2;
        spec.K = optKPerBits[spec.bitsPerElement];

        // Handle the trivial cases:
        if(maxFalsePosProb >= probs[minBits][minK]) return spec;
        if(maxFalsePosProb < probs[maxBits][maxK]) {
            spec.bitsPerElement = maxBits;
            spec.K = maxK;
            return spec;
        }

        // First find the minimal required number of bits:
        while(probs[spec.bitsPerElement][spec.K] > maxFalsePosProb){
            spec.bitsPerElement++;
            spec.K = optKPerBits[spec.bitsPerElement];
        }
        // Now that the number of bits is sufficient, see if we can relax K
        // without losing too much precision.
        while(probs[spec.bitsPerElement][spec.K-1] <= maxFalsePosProb){
            spec.K--;
        }
        return spec;
    }

