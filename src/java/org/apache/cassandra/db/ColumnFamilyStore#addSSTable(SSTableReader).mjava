    /*
     * Called after the Memtable flushes its in-memory data, or we add a file
     * via bootstrap. This information is
     * cached in the ColumnFamilyStore. This is useful for reads because the
     * ColumnFamilyStore first looks in the in-memory store and the into the
     * disk to find the key. If invoked during recoveryMode the
     * onMemtableFlush() need not be invoked.
     *
     * param @ filename - filename just flushed to disk
     * param @ bf - bloom filter which indicates the keys that are in this file.
    */
    void addSSTable(SSTableReader sstable)
    {
        int ssTableCount;
        sstableLock_.writeLock().lock();
        try
        {
            ssTables_.put(sstable.getFilename(), sstable);
            ssTableCount = ssTables_.size();
        }
        finally
        {
            sstableLock_.writeLock().unlock();
        }

        /* it's ok if compaction gets submitted multiple times while one is already in process.
           worst that happens is, compactor will count the sstable files and decide there are
           not enough to bother with. */
        if (ssTableCount >= MinorCompactionManager.MINCOMPACTION_THRESHOLD)
        {
            if (logger_.isDebugEnabled())
              logger_.debug("Added " + sstable.getFilename() + ".  Submitting " + columnFamily_ + " for compaction");
            MinorCompactionManager.instance().submit(this);
        }
    }

