    @Test
    public void testOverwritesToDeletedColumns() throws Exception
    {
        Keyspace table = Keyspace.open(KSNAME);
        ColumnFamilyStore cfs = table.getColumnFamilyStore(CFNAME);
        ByteBuffer key = ByteBufferUtil.bytes("k6");
        ByteBuffer indexedColumnName = ByteBufferUtil.bytes(1);

        cfs.truncateBlocking();
        cfs.disableAutoCompaction();
        cfs.setCompactionStrategyClass(SizeTieredCompactionStrategy.class.getCanonicalName());
        if (cfs.indexManager.getIndexForColumn(indexedColumnName) == null)
        {
            ColumnDefinition cd = new ColumnDefinition(cfs.metadata, indexedColumnName, Int32Type.instance, null, ColumnDefinition.Kind.REGULAR);
            cd.setIndex("test_index", IndexType.CUSTOM, ImmutableMap.of(SecondaryIndex.CUSTOM_INDEX_OPTION_NAME, TestIndex.class.getName()));
            Future<?> rebuild = cfs.indexManager.addIndexedColumn(cd);
            // If rebuild there is, wait for the rebuild to finish so it doesn't race with the following insertions
            if (rebuild != null)
                rebuild.get();
        }

        TestIndex index = ((TestIndex)cfs.indexManager.getIndexForColumn(indexedColumnName));
        index.resetCounts();

        Mutation rm = new Mutation(KSNAME, key);
        add(rm, 1, 0);
        rm.applyUnsafe();

        // add a RT which hides the column we just inserted
        rm = new Mutation(KSNAME, key);
        ColumnFamily cf = rm.addOrGet(CFNAME);
        delete(cf, 0, 1, 1);
        rm.applyUnsafe();

        // now re-insert that column
        rm = new Mutation(KSNAME, key);
        add(rm, 1, 2);
        rm.applyUnsafe();

        cfs.forceBlockingFlush();

        // We should have 1 insert and 1 update to the indexed "1" column
        // CASSANDRA-6640 changed index update to just update, not insert then delete
        assertEquals(1, index.inserts.size());
        assertEquals(1, index.updates.size());
    }

