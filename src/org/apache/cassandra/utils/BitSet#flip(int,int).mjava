    /**
     * Sets each bit from the specified <tt>fromIndex</tt> (inclusive) to the
     * specified <tt>toIndex</tt> (exclusive) to the complement of its current
     * value.
     * 
     * @param fromIndex
     *            index of the first bit to flip.
     * @param toIndex
     *            index after the last bit to flip.
     * @exception IndexOutOfBoundsException
     *                if <tt>fromIndex</tt> is negative, or <tt>toIndex</tt>
     *                is negative, or <tt>fromIndex</tt> is larger than
     *                <tt>toIndex</tt>.
     * @since 1.4
     */
    public void flip(int fromIndex, int toIndex)
    {
        checkRange(fromIndex, toIndex);
        
        if (fromIndex == toIndex)
            return;
        
        int startWordIndex = wordIndex(fromIndex);
        int endWordIndex = wordIndex(toIndex - 1);
        expandTo(endWordIndex);
        
        long firstWordMask = WORD_MASK << fromIndex;
        long lastWordMask = WORD_MASK >>> -toIndex;
        if (startWordIndex == endWordIndex)
        {
            // Case 1: One word
            words[startWordIndex] ^= (firstWordMask & lastWordMask);
        }
        else
        {
            // Case 2: Multiple words
            // Handle first word
            words[startWordIndex] ^= firstWordMask;
            
            // Handle intermediate words, if any
            for (int i = startWordIndex + 1; i < endWordIndex; i++)
                words[i] ^= WORD_MASK;
            
            // Handle last word
            words[endWordIndex] ^= lastWordMask;
        }
        
        recalculateWordsInUse();
        checkInvariants();
    }

