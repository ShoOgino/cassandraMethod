    private void readFile() throws IOException
    {
        if (logger.isDebugEnabled())
        {
            logger.debug("Receiving stream");
            logger.debug("Creating file for {}", localFile.getFilename());
        }
        FileOutputStream fos = new FileOutputStream(localFile.getFilename(), true);
        FileChannel fc = fos.getChannel();

        long offset = 0;
        try
        {
            for (Pair<Long, Long> section : localFile.sections)
            {
                long length = section.right - section.left;
                long bytesRead = 0;
                while (bytesRead < length)
                {
                    long toRead = Math.min(FileStreamTask.CHUNK_SIZE, length - bytesRead);
                    long lastRead = fc.transferFrom(socketChannel, offset + bytesRead, toRead);
                    // if the other side fails, we will not get an exception, but instead transferFrom will constantly return 0 byte read
                    // and we would thus enter an infinite loop. So intead, if no bytes are tranferred we assume the other side is dead and 
                    // raise an exception (that will be catch belove and 'the right thing' will be done).
                    if (lastRead == 0)
                        throw new IOException("Transfer failed for remote file " + remoteFile);
                    bytesRead += lastRead;
                    remoteFile.progress += lastRead;
                }
                offset += length;
            }
        }
        catch (IOException ex)
        {
            /* Ask the source node to re-stream this file. */
            session.retry(remoteFile);

            /* Delete the orphaned file. */
            FileUtils.deleteWithConfirm(new File(localFile.getFilename()));
            throw ex;
        }
        finally
        {
            fc.close();
        }

        session.finished(remoteFile, localFile);
    }

