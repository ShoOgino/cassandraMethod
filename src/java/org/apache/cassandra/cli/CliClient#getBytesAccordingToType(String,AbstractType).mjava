    /**
     * Converts object represented as string into byte[] according to comparator
     * @param object - object to covert into byte array
     * @param comparator - comparator used to convert object
     * @return byte[] - object in the byte array representation
     */
    private ByteBuffer getBytesAccordingToType(String object, AbstractType comparator)
    {
        // TODO there is tension here between using this function to generate default values,
        // and using it to parse input.  For instance, normally we want to convert empty string
        // to empty byte array for any type -- all types special case empty byte[] to mean
        // "minimum value" -- but we also want timeuuid() to create a valid uuid for us.
        // For now, this function takes the create-valid-values approach, and we leave
        // other use cases to special case "" -> byte[0] before calling this.
        if (comparator instanceof LongType)
        {
            long longType;
            try
            {
                longType = Long.valueOf(object);
            }
            catch (Exception e)
            {
                throw new RuntimeException("'" + object + "' could not be translated into a LongType.");
            }

            return FBUtilities.toByteBuffer(longType);
        }
        else if (comparator instanceof LexicalUUIDType || comparator instanceof TimeUUIDType)
        {
            // generate new time based UUID if object is empty
            // this means that we have timeuuid() call
            if (comparator instanceof TimeUUIDType && object.isEmpty())
                return ByteBuffer.wrap(UUIDGenerator.getInstance().generateTimeBasedUUID().asByteArray());

            UUID uuid = (object.isEmpty()) ? UUID.randomUUID() : UUID.fromString(object);

            if (comparator instanceof TimeUUIDType && uuid.version() != 1)
                throw new IllegalArgumentException("TimeUUID supports only version 1 UUIDs");    

            return ByteBuffer.wrap(UUIDGen.decompose(uuid));    
        }
        else if (comparator instanceof IntegerType)
        {
            BigInteger integerType;

            try
            {
                integerType =  new BigInteger(object);
            }
            catch (Exception e)
            {
                throw new RuntimeException("'" + object + "' could not be translated into an IntegerType.");
            }

            return ByteBuffer.wrap(integerType.toByteArray());
        }
        else if (comparator instanceof AsciiType)
        {
            return ByteBuffer.wrap(object.getBytes(Charsets.US_ASCII));
        }
        else
        {
            return ByteBuffer.wrap(object.getBytes(Charsets.UTF_8));
        }
    }

