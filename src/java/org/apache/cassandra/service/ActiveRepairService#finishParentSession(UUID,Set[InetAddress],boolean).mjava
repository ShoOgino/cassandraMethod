    /**
     * Run final process of repair.
     * This removes all resources held by parent repair session, after performing anti compaction if necessary.
     *
     * @param parentSession Parent session ID
     * @param neighbors Repair participants (not including self)
     * @param doAntiCompaction true if repair session needs anti compaction
     * @throws InterruptedException
     * @throws ExecutionException
     */
    public synchronized ListenableFuture<?> finishParentSession(UUID parentSession, Set<InetAddress> neighbors, boolean doAntiCompaction) throws InterruptedException, ExecutionException
    {
        if (doAntiCompaction)
        {
            List<ListenableFuture<?>> tasks = new ArrayList<>(neighbors.size() + 1);
            for (InetAddress neighbor : neighbors)
            {
                AnticompactionTask task = new AnticompactionTask(parentSession, neighbor);
                tasks.add(task);
                task.run(); // 'run' is just sending message
            }
            tasks.add(doAntiCompaction(parentSession));
            return Futures.successfulAsList(tasks);
        }
        else
        {
            removeParentRepairSession(parentSession);
            return Futures.immediateFuture(null);
        }
    }

