    private static void doPivot(Sortable data, int lo, int hi, int[] result)
    {
        int m = lo + (hi-lo)/2; // Written like this to avoid integer overflow.
        if (hi-lo > 40) {
            // Tukey's ``Ninther,'' median of three medians of three.
            int s = (hi - lo) / 8;
            medianOfThree(data, lo, lo+s, lo+2*s);
            medianOfThree(data, m, m-s, m+s);
            medianOfThree(data, hi-1, hi-1-s, hi-1-2*s);
        }
        medianOfThree(data, lo, m, hi-1);

        // Invariants are:
        //    data[lo] = pivot (set up by ChoosePivot)
        //    data[lo <= i < a] = pivot
        //    data[a <= i < b] < pivot
        //    data[b <= i < c] is unexamined
        //    data[c <= i < d] > pivot
        //    data[d <= i < hi] = pivot
        //
        // Once b meets c, can swap the "= pivot" sections
        // into the middle of the slice.
        int pivot = lo;
        int a = lo+1, b = lo+1, c = hi, d =hi;
        while (true)
        {
            while (b < c)
            {
                int cmp = data.compare(b, pivot);
                if (cmp < 0)  // data[b] < pivot
                {
                    b++;
                }
                else if (cmp == 0) // data[b] = pivot
                {
                    data.swap(a, b);
                    a++;
                    b++;
                }
                else
                {
                    break;
                }
            }

            while (b < c)
            {
                int cmp = data.compare(pivot, c-1);
                if (cmp < 0) // data[c-1] > pivot
                {
                    c--;
                }
                else if (cmp == 0) // data[c-1] = pivot
                {
                    data.swap(c-1, d-1);
                    c--;
                    d--;
                }
                else
                {
                    break;
                }
            }

            if (b >= c)
                break;

            // data[b] > pivot; data[c-1] < pivot
            data.swap(b, c-1);
            b++;
            c--;
        }

        int n = Math.min(b-a, a-lo);
        swapRange(data, lo, b-n, n);

        n = Math.min(hi-d, d-c);
        swapRange(data, c, hi-n, n);

        result[0] = lo + b - a;
        result[1] = hi - (d - c);
    }

