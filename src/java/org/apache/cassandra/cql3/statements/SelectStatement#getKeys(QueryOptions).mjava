    private NavigableSet<ByteBuffer> getKeys(final QueryOptions options) throws InvalidRequestException
    {
        TreeSet<ByteBuffer> sortedKeys = new TreeSet<>(cfm.getKeyValidator());
        CBuilder builder = cfm.getKeyValidatorAsCType().builder();
        for (ColumnDefinition def : cfm.partitionKeyColumns())
        {
            Restriction r = keyRestrictions[def.position()];
            assert r != null && !r.isSlice();

            List<ByteBuffer> values = r.values(options);

            if (builder.remainingCount() == 1)
            {
                for (ByteBuffer val : values)
                {
                    if (val == null)
                        throw new InvalidRequestException(String.format("Invalid null value for partition key part %s", def.name));

                    ByteBuffer keyBuffer = builder.buildWith(val).toByteBuffer();
                    validateKey(keyBuffer);
                    sortedKeys.add(keyBuffer);
                }
            }
            else
            {
                // Note: for backward compatibility reasons, we let INs with 1 value slide
                if (values.size() != 1)
                    throw new InvalidRequestException("IN is only supported on the last column of the partition key");
                ByteBuffer val = values.get(0);
                if (val == null)
                    throw new InvalidRequestException(String.format("Invalid null value for partition key part %s", def.name));
                builder.add(val);
            }
        }
        return sortedKeys;
    }

