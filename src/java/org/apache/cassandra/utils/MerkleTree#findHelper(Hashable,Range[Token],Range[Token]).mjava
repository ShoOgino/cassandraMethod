    /**
     * @throws StopRecursion If no match could be found for the range.
     */
    private Hashable findHelper(Hashable current, Range<Token> activeRange, Range<Token> find) throws StopRecursion
    {
        if (current instanceof Leaf)
        {
            if (!find.contains(activeRange))
                // we are not fully contained in this range!
                throw new StopRecursion.BadRange();
            return current;
        }
        // else: node.

        Inner node = (Inner)current;
        Range<Token> leftRange = new Range<Token>(activeRange.left, node.token);
        Range<Token> rightRange = new Range<Token>(node.token, activeRange.right);

        if (find.contains(activeRange))
            // this node is fully contained in the range
            return node.calc();

        // else: one of our children contains the range

        if (leftRange.contains(find))
            // left child contains/matches the range
            return findHelper(node.lchild, leftRange, find);
        else if (rightRange.contains(find))
            // right child contains/matches the range
            return findHelper(node.rchild, rightRange, find);
        else
            throw new StopRecursion.BadRange();
    }

