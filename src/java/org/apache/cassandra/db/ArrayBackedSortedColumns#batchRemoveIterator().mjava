    @Override
    public BatchRemoveIterator<Column> batchRemoveIterator()
    {
        return new BatchRemoveIterator<Column>()
        {
            private Iterator<Column> iter = iterator();
            private BitSet removedIndexes = new BitSet(columns.size());
            private int idx = -1;
            private boolean shouldCallNext = true;
            private boolean isCommitted = false;
            private boolean removedAnything = false;

            public void commit()
            {
                if (isCommitted)
                    throw new IllegalStateException();
                isCommitted = true;

                if (!removedAnything)
                    return;

                // the lowest index both not visited and known to be not removed
                int keepIdx = removedIndexes.nextClearBit(0);
                // the running total of kept items
                int resultLength = 0;
                // start from the first not-removed cell, and shift left.
                int removeIdx = removedIndexes.nextSetBit(keepIdx + 1);
                while (removeIdx >= 0)
                {
                    int length = removeIdx - keepIdx;
                    if (length > 0)
                    {
                        copy(keepIdx, resultLength, length);
                        resultLength += length;
                    }
                    keepIdx = removedIndexes.nextClearBit(removeIdx + 1);
                    if (keepIdx < 0)
                        keepIdx = columns.size();
                    removeIdx = removedIndexes.nextSetBit(keepIdx + 1);
                }
                // Copy everything after the last deleted column
                int length = columns.size() - keepIdx;
                if (length > 0)
                {
                    copy(keepIdx, resultLength, length);
                    resultLength += length;
                }

                columns.subList(resultLength, columns.size()).clear();
            }

            private void copy(int src, int dst, int len)
            {
                // [src, src+len) and [dst, dst+len) might overlap, but it's okay because we're going from left to right
                assert dst <= src : "dst must not be greater than src";

                if (dst < src)
                    Collections.copy(columns.subList(dst, dst + len), columns.subList(src, src + len));
            }

            public boolean hasNext()
            {
                return iter.hasNext();
            }

            public Column next()
            {
                idx++;
                shouldCallNext = false;
                return iter.next();
            }

            public void remove()
            {
                if (shouldCallNext)
                    throw new IllegalStateException();

                removedIndexes.set(reversed ? columns.size() - idx - 1 : idx);
                removedAnything = true;
                shouldCallNext = true;
            }
        };
    }

