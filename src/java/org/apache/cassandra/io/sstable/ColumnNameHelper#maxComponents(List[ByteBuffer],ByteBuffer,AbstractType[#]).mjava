    /**
     * finds the max column name(s)
     *
     * if comparator is of CompositeType, candidate will be split into its components, and each
     * component is compared to the component on the same place in maxSeen, and then returning the list
     * with the max columns.
     *
     * if comparator is not CompositeType, maxSeen is assumed to be of size 1 and the item there is
     * compared to the candidate.
     *
     * @param maxSeen the max columns seen so far
     * @param candidate the candidate column(s)
     * @param comparator the comparator to use
     * @return a list with the max column(s)
     */
    public static List<ByteBuffer> maxComponents(List<ByteBuffer> maxSeen, ByteBuffer candidate, AbstractType<?> comparator)
    {
        if (comparator instanceof AbstractCompositeType)
        {
            if (maxSeen.size() == 0)
                return Arrays.asList(((AbstractCompositeType)comparator).split(candidate));

            List<AbstractCompositeType.CompositeComponent> components = ((AbstractCompositeType)comparator).deconstruct(candidate);
            List<ByteBuffer> retList = new ArrayList<ByteBuffer>(components.size());
            for (int i = 0; i < maxSeen.size(); i++)
            {
                AbstractCompositeType.CompositeComponent component = components.get(i);
                retList.add(ColumnNameHelper.max(maxSeen.get(i), component.value, component.comparator));
            }
            return retList;
        }
        else
        {
            if (maxSeen.size() == 0)
                return Collections.singletonList(candidate);
            return Collections.singletonList(ColumnNameHelper.max(maxSeen.get(0), candidate, comparator));

        }
    }

