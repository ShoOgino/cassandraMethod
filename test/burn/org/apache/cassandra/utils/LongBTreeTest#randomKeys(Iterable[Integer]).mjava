    // select a random subset of the keys, with an optional random population of keys inbetween those that are present
    // return a value with the search position
    private static List<Integer> randomKeys(Iterable<Integer> canonical)
    {
        ThreadLocalRandom rnd = ThreadLocalRandom.current();
        boolean useFake = rnd.nextBoolean();
        final float fakeRatio = rnd.nextFloat();
        List<Integer> results = new ArrayList<>();
        Long fakeLb = null, fakeUb = null;
        for (Integer v : canonical)
        {
            if (    !useFake
                ||  fakeLb == null
                || (fakeUb == null ? v - 1 : fakeUb) <= fakeLb + 1
                ||  rnd.nextFloat() < fakeRatio)
            {
                // if we cannot safely construct a fake value, or our randomizer says not to, we emit the next real value
                results.add(v);
                fakeLb = v.longValue();
                fakeUb = null;
            }
            else
            {
                // otherwise we emit a fake value in the range immediately proceeding the last real value, and not
                // exceeding the real value that would have proceeded (ignoring any other suppressed real values since)
                if (fakeUb == null)
                    fakeUb = v.longValue() - 1;
                long mid = (fakeLb + fakeUb) / 2;
                assert mid < fakeUb;
                results.add((int) mid);
                fakeLb = mid;
            }
        }
        final float useChance = rnd.nextFloat();
        return Lists.newArrayList(filter(results, (x) -> rnd.nextFloat() < useChance));
    }

