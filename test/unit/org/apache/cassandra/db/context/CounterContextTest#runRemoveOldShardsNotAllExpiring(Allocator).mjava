    private void runRemoveOldShardsNotAllExpiring(Allocator allocator)
    {
        CounterId id1 = CounterId.fromInt(1);
        CounterId id3 = CounterId.fromInt(3);
        CounterId id6 = CounterId.fromInt(6);
        List<CounterId.CounterIdRecord> records = new ArrayList<CounterId.CounterIdRecord>();
        records.add(new CounterId.CounterIdRecord(id1, 2L));
        records.add(new CounterId.CounterIdRecord(id3, 4L));
        records.add(new CounterId.CounterIdRecord(id6, 10L));

        ContextState ctx = ContextState.allocate(6, 3, allocator);
        ctx.writeElement(id1, 0L, 1L, true);
        ctx.writeElement(CounterId.fromInt(2), 0L, 2L);
        ctx.writeElement(id3, 0L, 3L, true);
        ctx.writeElement(CounterId.fromInt(4), 0L, 3L);
        ctx.writeElement(CounterId.fromInt(5), 0L, 3L, true);
        ctx.writeElement(id6, 0L, 6L);

        int timeFirstMerge = (int)(System.currentTimeMillis() / 1000);

        // First, only merge the first id
        ByteBuffer merger = cc.computeOldShardMerger(ctx.context, records, 3L);
        ByteBuffer merged = cc.merge(ctx.context, merger, allocator);
        assert cc.total(ctx.context) == cc.total(merged);

        try
        {
            Thread.sleep(2000);
        }
        catch (InterruptedException e)
        {
            throw new AssertionError();
        }

        // merge the second one
        ByteBuffer merger2 = cc.computeOldShardMerger(merged, records, 7L);
        ByteBuffer merged2 = cc.merge(merged, merger2, allocator);
        assert cc.total(ctx.context) == cc.total(merged2);

        ByteBuffer cleaned = cc.removeOldShards(merged2, timeFirstMerge + 1);
        assert cc.total(ctx.context) == cc.total(cleaned);
        assert cleaned.remaining() == ctx.context.remaining();

        // We should have cleaned id1 but not id3
        ContextState m = new ContextState(cleaned);
        m.moveToNext();
        assert m.getCounterId().equals(id3);

    }

