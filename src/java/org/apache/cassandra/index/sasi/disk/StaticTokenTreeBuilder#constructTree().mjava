    protected void constructTree()
    {
        RangeIterator<Long, Token> tokens = combinedTerm.getTokenIterator();

        tokenCount = tokens.getCount();
        treeMinToken = tokens.getMinimum();
        treeMaxToken = tokens.getMaximum();
        numBlocks = 1;

        if (tokenCount <= TOKENS_PER_BLOCK)
        {
            leftmostLeaf = new StaticLeaf(tokens, tokens.getMinimum(), tokens.getMaximum(), tokens.getCount(), true);
            rightmostLeaf = leftmostLeaf;
            root = leftmostLeaf;
        }
        else
        {
            root = new InteriorNode();
            rightmostParent = (InteriorNode) root;

            // build all the leaves except for maybe
            // the last leaf which is not completely full .
            // This loop relies on the fact that multiple index segments
            // will never have token intersection for a single term,
            // because it's impossible to encounter the same value for
            // the same column multiple times in a single key/sstable.
            Leaf lastLeaf = null;
            long numFullLeaves = tokenCount / TOKENS_PER_BLOCK;
            for (long i = 0; i < numFullLeaves; i++)
            {
                Long firstToken = tokens.next().get();
                for (int j = 1; j < (TOKENS_PER_BLOCK - 1); j++)
                    tokens.next();

                Long lastToken = tokens.next().get();
                Leaf leaf = new PartialLeaf(firstToken, lastToken, TOKENS_PER_BLOCK);

                if (lastLeaf == null)
                    leftmostLeaf = leaf;
                else
                    lastLeaf.next = leaf;

                rightmostParent.add(leaf);
                lastLeaf = rightmostLeaf = leaf;
                numBlocks++;
            }

            // build the last leaf out of any remaining tokens if necessary
            // safe downcast since TOKENS_PER_BLOCK is an int
            int remainingTokens = (int) (tokenCount % TOKENS_PER_BLOCK);
            if (remainingTokens != 0)
            {
                Long firstToken = tokens.next().get();
                Long lastToken = firstToken;
                while (tokens.hasNext())
                    lastToken = tokens.next().get();

                Leaf leaf = new PartialLeaf(firstToken, lastToken, remainingTokens);
                rightmostParent.add(leaf);
                lastLeaf.next = rightmostLeaf = leaf;
                numBlocks++;
            }
        }
    }

