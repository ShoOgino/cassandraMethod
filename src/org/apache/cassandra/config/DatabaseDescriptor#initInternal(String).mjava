    public static Map<String, Map<String, CFMetaData>> initInternal(String file) throws Throwable
    {
        String os = System.getProperty("os.name");
        XMLUtils xmlUtils = new XMLUtils(file);        

        /* Cluster Name */
        clusterName_ = xmlUtils.getNodeValue("/Storage/ClusterName");

        /* Ganglia servers contact list */
        gangliaServers_ = xmlUtils.getNodeValues("/Storage/GangliaServers/GangliaServer");
        
        /* ZooKeeper's address */
        zkAddress_ = xmlUtils.getNodeValue("/Storage/ZookeeperAddress");
        
        /* Hashing strategy */
        hashingStrategy_ = xmlUtils.getNodeValue("/Storage/HashingStrategy");
        /* Callout location */
        calloutLocation_ = xmlUtils.getNodeValue("/Storage/CalloutLocation");
        
        /* JobTracker address */
        jobTrackerHost_ = xmlUtils.getNodeValue("/Storage/JobTrackerHost");
        
        /* Job Jar file location */
        jobJarFileLocation_ = xmlUtils.getNodeValue("/Storage/JobJarFileLocation");       
        
        /* Zookeeper's session timeout */
        String zkSessionTimeout = xmlUtils.getNodeValue("/Storage/ZookeeperSessionTimeout");
        if ( zkSessionTimeout != null )
            zkSessionTimeout_ = Integer.parseInt(zkSessionTimeout);

        /* Data replication factor */
        String replicationFactor = xmlUtils.getNodeValue("/Storage/ReplicationFactor");
        if ( replicationFactor != null )
        	replicationFactor_ = Integer.parseInt(replicationFactor);

        /* RPC Timeout */
        String rpcTimeoutInMillis = xmlUtils.getNodeValue("/Storage/RpcTimeoutInMillis");
        if ( rpcTimeoutInMillis != null )
        	rpcTimeoutInMillis_ = Integer.parseInt(rpcTimeoutInMillis);

        /* Thread per pool */
        String threadsPerPool = xmlUtils.getNodeValue("/Storage/ThreadsPerPool");
        if ( threadsPerPool != null )
            threadsPerPool_ = Integer.parseInt(threadsPerPool);

        /* TCP port on which the storage system listens */
        String port = xmlUtils.getNodeValue("/Storage/StoragePort");
        if ( port != null )
            storagePort_ = Integer.parseInt(port);

        /* UDP port for control messages */
        port = xmlUtils.getNodeValue("/Storage/ControlPort");
        if ( port != null )
            controlPort_ = Integer.parseInt(port);

        /* HTTP port for HTTP messages */
        port = xmlUtils.getNodeValue("/Storage/HttpPort");
        if ( port != null )
            httpPort_ = Integer.parseInt(port);

        /* Touch Key Cache Size */
        String touchKeyCacheSize = xmlUtils.getNodeValue("/Storage/TouchKeyCacheSize");
        if ( touchKeyCacheSize != null )
            touchKeyCacheSize_ = Integer.parseInt(touchKeyCacheSize);

        /* Number of days to keep the memtable around w/o flushing */
        String lifetime = xmlUtils.getNodeValue("/Storage/MemtableLifetimeInDays");
        if ( lifetime != null )
            memtableLifetime_ = Integer.parseInt(lifetime);
        
        /* Size of the memtable in memory in MB before it is dumped */
        String memtableSize = xmlUtils.getNodeValue("/Storage/MemtableSizeInMB");
        if ( memtableSize != null )
        	memtableSize_ = Integer.parseInt(memtableSize);
        /* Number of objects in millions in the memtable before it is dumped */
        String memtableObjectCount = xmlUtils.getNodeValue("/Storage/MemtableObjectCountInMillions");
        if ( memtableObjectCount != null )
        	memtableObjectCount_ = Integer.parseInt(memtableObjectCount);
        
        /* This parameter enables or disables consistency checks. 
         * If set to false the read repairs are disable for very
         * high throughput on reads but at the cost of consistency.*/
        String doConsistencyCheck = xmlUtils.getNodeValue("/Storage/DoConsistencyChecksBoolean");
        if ( doConsistencyCheck != null )
        	doConsistencyCheck_ = Boolean.parseBoolean(doConsistencyCheck);
        
        
        /* read the size at which we should do column indexes */
        String columnIndexSizeInKB = xmlUtils.getNodeValue("/Storage/ColumnIndexSizeInKB");
        if(columnIndexSizeInKB == null)
        {
        	columnIndexSizeInKB_ = 64;
        }
        else
        {
        	columnIndexSizeInKB_ = Integer.parseInt(columnIndexSizeInKB);
        }

        /* metadata directory */
        metadataDirectory_ = xmlUtils.getNodeValue("/Storage/MetadataDirectory");
        if ( metadataDirectory_ != null )
            FileUtils.createDirectory(metadataDirectory_);
        else
        {
            if ( os.equals("Linux") )
            {
                metadataDirectory_ = "/var/storage/system";
            }
        }

        /* snapshot directory */
        snapshotDirectory_ = xmlUtils.getNodeValue("/Storage/SnapshotDirectory");
        if ( snapshotDirectory_ != null )
            FileUtils.createDirectory(snapshotDirectory_);
        else
        {
            	snapshotDirectory_ = metadataDirectory_ + System.getProperty("file.separator") + "snapshot";
        }
        
        /* map output directory */
        mapOutputDirectories_ = xmlUtils.getNodeValues("/Storage/MapOutputDirectories/MapOutputDirectory");
        if ( mapOutputDirectories_.length > 0 )
        {
            for ( String mapOutputDirectory : mapOutputDirectories_ )
                FileUtils.createDirectory(mapOutputDirectory);
        }
        
        /* data file directory */
        dataFileDirectories_ = xmlUtils.getNodeValues("/Storage/DataFileDirectories/DataFileDirectory");
        if ( dataFileDirectories_.length > 0 )
        {
        	for ( String dataFileDirectory : dataFileDirectories_ )
        		FileUtils.createDirectory(dataFileDirectory);
        }
        else
        {
            if ( os.equals("Linux") )
            {
                dataFileDirectories_ = new String[]{"/var/storage/data"};
            }
        }

        /* bootstrap file directory */
        bootstrapFileDirectory_ = xmlUtils.getNodeValue("/Storage/BootstrapFileDirectory");
        if ( bootstrapFileDirectory_ != null )
            FileUtils.createDirectory(bootstrapFileDirectory_);
        else
        {
            if ( os.equals("Linux") )
            {
                bootstrapFileDirectory_ = "/var/storage/bootstrap";
            }
        }

        /* commit log directory */
        logFileDirectory_ = xmlUtils.getNodeValue("/Storage/CommitLogDirectory");
        if ( logFileDirectory_ != null )
            FileUtils.createDirectory(logFileDirectory_);
        else
        {
            if ( os.equals("Linux") )
            {
                logFileDirectory_ = "/var/storage/commitlog";
            }
        }

        /* threshold after which commit log should be rotated. */
        String value = xmlUtils.getNodeValue("/Storage/CommitLogRotationThresholdInMB");
        if ( value != null)
            logRotationThreshold_ = Integer.parseInt(value) * 1024 * 1024;

        /* fast sync option */
        value = xmlUtils.getNodeValue("/Storage/CommitLogFastSync");
        if ( value != null )
            fastSync_ = Boolean.parseBoolean(value);

        tableToCFMetaDataMap_ = new HashMap<String, Map<String, CFMetaData>>();

        /* Rack Aware option */
        value = xmlUtils.getNodeValue("/Storage/RackAware");
        if ( value != null )
            rackAware_ = Boolean.parseBoolean(value);

        /* Read the table related stuff from config */
        NodeList tables = xmlUtils.getRequestedNodeList("/Storage/Tables/Table");
        int size = tables.getLength();
        for ( int i = 0; i < size; ++i )
        {
            Node table = tables.item(i);

            /* parsing out the table name */
            String tName = XMLUtils.getAttributeValue(table, "Name");
            tables_.add(tName);
            tableToCFMetaDataMap_.put(tName, new HashMap<String, CFMetaData>());

            String xqlTable = "/Storage/Tables/Table[@Name='" + tName + "']/";
            NodeList columnFamilies = xmlUtils.getRequestedNodeList(xqlTable + "ColumnFamily");

            // get name of the rowKey for this table
            String n_rowKey = xmlUtils.getNodeValue(xqlTable + "RowKey");
            if (n_rowKey == null)
                n_rowKey = d_rowKey_;

            //NodeList columnFamilies = xmlUtils.getRequestedNodeList(table, "ColumnFamily");            
            int size2 = columnFamilies.getLength();

            for ( int j = 0; j < size2; ++j )
            {
                Node columnFamily = columnFamilies.item(j);
                String cName = XMLUtils.getAttributeValue(columnFamily, "Name");
                String xqlCF = xqlTable + "ColumnFamily[@Name='" + cName + "']/";

                /* squirrel away the application column families */
                applicationColumnFamilies_.add(cName);

                // Parse out the column type
                String columnType = xmlUtils.getAttributeValue(columnFamily, "ColumnType");
                columnType = ColumnFamily.getColumnType(columnType);

                // Parse out the column family sorting property for columns
                String columnIndexProperty = XMLUtils.getAttributeValue(columnFamily, "ColumnSort");
                String columnIndexType = ColumnFamily.getColumnSortProperty(columnIndexProperty);

                // Parse out user-specified logical names for the various dimensions
                // of a the column family from the config.
                String n_superColumnMap = xmlUtils.getNodeValue(xqlCF + "SuperColumnMap");
                if (n_superColumnMap == null)
                    n_superColumnMap = d_superColumnMap_;
                
                String n_superColumnKey = xmlUtils.getNodeValue(xqlCF + "SuperColumnKey");
                if (n_superColumnKey == null)
                    n_superColumnKey = d_superColumnKey_;
                
                String n_columnMap = xmlUtils.getNodeValue(xqlCF + "ColumnMap");
                if (n_columnMap == null)
                    n_columnMap = d_columnMap_;
                
                String n_columnKey = xmlUtils.getNodeValue(xqlCF + "ColumnKey");
                if (n_columnKey == null)
                    n_columnKey = d_columnKey_;

                String n_columnValue = xmlUtils.getNodeValue(xqlCF + "ColumnValue");
                if (n_columnValue == null)
                    n_columnValue = d_columnValue_;

                String n_columnTimestamp = xmlUtils.getNodeValue(xqlCF + "ColumnTimestamp");
                if (n_columnTimestamp == null)
                    n_columnTimestamp = d_columnTimestamp_;

                // now populate the column family meta data and
                // insert it into the table dictionary. 
                CFMetaData cfMetaData = new CFMetaData();
                
                cfMetaData.tableName = tName;
                cfMetaData.cfName = cName;
                
                cfMetaData.columnType = columnType;
                cfMetaData.indexProperty_ = columnIndexType;

                cfMetaData.n_rowKey = n_rowKey;
                cfMetaData.n_columnMap = n_columnMap;
                cfMetaData.n_columnKey = n_columnKey;
                cfMetaData.n_columnValue = n_columnValue;
                cfMetaData.n_columnTimestamp = n_columnTimestamp;
                if ("Super".equals(columnType))
                {
                    cfMetaData.n_superColumnKey = n_superColumnKey;
                    cfMetaData.n_superColumnMap = n_superColumnMap;
                }

                tableToCFMetaDataMap_.get(tName).put(cName, cfMetaData);
            }
        }

        /* Load the seeds for node contact points */
        String[] seeds = xmlUtils.getNodeValues("/Storage/Seeds/Seed");
        for( int i = 0; i < seeds.length; ++i )
        {            
            seeds_.add( seeds[i] );
        }
        return tableToCFMetaDataMap_;
    }

