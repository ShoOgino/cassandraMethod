    public static void mutateBlocking(List<RowMutation> mutations, ConsistencyLevel consistency_level) throws UnavailableException, TimeoutException
    {
        long startTime = System.currentTimeMillis();
        ArrayList<WriteResponseHandler> responseHandlers = new ArrayList<WriteResponseHandler>();

        RowMutation mostRecentRowMutation = null;
        try
        {
            for (RowMutation rm: mutations)
            {
                mostRecentRowMutation = rm;
                List<InetAddress> naturalEndpoints = StorageService.instance.getNaturalEndpoints(rm.key());
                Map<InetAddress, InetAddress> endpointMap = StorageService.instance.getHintedEndpointMap(rm.key(), naturalEndpoints);
                int blockFor = determineBlockFor(naturalEndpoints.size(), endpointMap.size(), consistency_level);
    
                // avoid starting a write we know can't achieve the required consistency
                assureSufficientLiveNodes(endpointMap, blockFor);
                
                // send out the writes, as in insert() above, but this time with a callback that tracks responses
                final WriteResponseHandler responseHandler = StorageService.instance.getWriteResponseHandler(blockFor, consistency_level);
                responseHandlers.add(responseHandler);
                Message unhintedMessage = null;
                for (Map.Entry<InetAddress, InetAddress> entry : endpointMap.entrySet())
                {
                    InetAddress naturalTarget = entry.getKey();
                    InetAddress maybeHintedTarget = entry.getValue();
    
                    if (naturalTarget.equals(maybeHintedTarget))
                    {
                        // not hinted
                        if (naturalTarget.equals(FBUtilities.getLocalAddress()))
                        {
                            insertLocalMessage(rm, responseHandler);
                        }
                        else
                        {
                            // belongs on a different server.  send it there.
                            if (unhintedMessage == null)
                            {
                                unhintedMessage = rm.makeRowMutationMessage();
                                MessagingService.instance().addCallback(responseHandler, unhintedMessage.getMessageId());
                            }
                            if (logger.isDebugEnabled())
                                logger.debug("insert writing key " + rm.key() + " to " + unhintedMessage.getMessageId() + "@" + naturalTarget);
                            MessagingService.instance().sendOneWay(unhintedMessage, naturalTarget);
                        }
                    }
                    else
                    {
                        // (hints aren't part of the callback since they don't count towards consistency until they are on the final destination node)
                        Message hintedMessage = rm.makeRowMutationMessage();
                        hintedMessage.addHeader(RowMutation.HINT, naturalTarget.getAddress());
                        if (logger.isDebugEnabled())
                            logger.debug("insert writing key " + rm.key() + " to " + hintedMessage.getMessageId() + "@" + maybeHintedTarget + " for " + naturalTarget);
                        MessagingService.instance().sendOneWay(hintedMessage, maybeHintedTarget);
                    }
                }
            }
            // wait for writes.  throws timeoutexception if necessary
            for( WriteResponseHandler responseHandler : responseHandlers )
            {
                responseHandler.get();
            }
        }
        catch (IOException e)
        {
            if (mostRecentRowMutation == null)
                throw new RuntimeException("no mutations were seen but found an error during write anyway", e);
            else
                throw new RuntimeException("error writing key " + mostRecentRowMutation.key(), e);
        }
        finally
        {
            writeStats.add(System.currentTimeMillis() - startTime);
        }

    }

