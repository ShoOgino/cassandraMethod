    /**
     * lockInteral does the actual locking.
     *
     * @param same as in lock
     */
    private String lockInternal(String lockName) throws KeeperException, InterruptedException
    {
        String lockZNode = null;
        String lockPath = root + "/" + lockName;

	lockZNode = createLockZNode(lockPath);

        if (logger.isTraceEnabled())
            logger.trace("lockZNode created " + lockZNode);

        while (true)
        {
	    // check what is our ID (sequence number at the end of file name added by ZK)
	    int mySeqNum = Integer.parseInt(lockZNode.substring(lockZNode.lastIndexOf('-') + 1));
	    int previousSeqNum = -1;
	    String predessor = null;

            // get all children of lock znode and find the one that is just before us, if
            // any. This must be inside loop, as children might get deleted out of order because
            // of client disconnects. We cannot assume that the file that is in front of us this
            // time, is there next time. It might have been deleted even though earlier files
            // are still there.
            List<String> children = zk.getChildren(lockPath, false);
	    if (children.isEmpty())
	    {
		logger.warn("No children in " + lockPath + " although one was just created. Going to try again");
		lockZNode = createLockZNode(lockPath);
		continue;
	    }
            for (String child : children)
            {
                if (logger.isTraceEnabled())
                    logger.trace("child: " + child);
                int otherSeqNum = Integer.parseInt(child.substring(child.lastIndexOf('-') + 1));
                if (otherSeqNum < mySeqNum && otherSeqNum > previousSeqNum)
                {
                    previousSeqNum = otherSeqNum;
                    predessor = child;
                }
            }

            // our sequence number is smallest, we have the lock
            if (previousSeqNum == -1)
            {
                if (logger.isTraceEnabled())
                    logger.trace("No smaller znode sequences, " + lockZNode + " acquired lock");
                return lockZNode;
            }

            // there is at least one znode before us. wait for it to be deleted.
            synchronized (mutex)
            {
                if (zk.exists(lockPath + "/" + predessor, true) == null)
                {
                    if (logger.isTraceEnabled())
                        logger.trace(predessor + " does not exists, " + lockZNode + " acquired lock");
                    break;
                }
                else if (logger.isTraceEnabled())
                    logger.trace(predessor + " is still here, " + lockZNode + " must wait");

                mutex.wait();

                if (isConnected() == false)
                {
                    logger.info("ZooKeeper disconnected while waiting for lock");
                    throw new KeeperException.ConnectionLossException();
                }
            }
        }

        return lockZNode;
    }

