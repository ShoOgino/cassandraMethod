    private CellName makeExclusiveSliceBound(Bound bound, CellNameType type, QueryOptions options) throws InvalidRequestException
    {
        // clusteringColumnBounds may reverse bound if clustering order is reversed
        // but areRequestedBoundsInclusive checks for Restriction::isInclusive and never
        // reverses the order. In order to avoid inconsistencies and check inclusive
        // bounds correctly, we need to check for column order and reverse it. See CASSANDRA-10988
        if (restrictions.areRequestedBoundsInclusive(reverseBoundIfNeeded(bound)))
            return null;

        // We can only reach that if the table is dense non-compound tables.
        // By consequence, we know that the table is a COMPACT table with only one clustering column.
        ByteBuffer value = restrictions.getClusteringColumnsBounds(bound, options).get(0);

        // Dense non-compound tables do not accept empty ByteBuffers. By consequence, if the slice value is empty
        // we know that we can treat the slice as inclusive.
        return value.hasRemaining() ? type.makeCellName(value) : null;
    }

