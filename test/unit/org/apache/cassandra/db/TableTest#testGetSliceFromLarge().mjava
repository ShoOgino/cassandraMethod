    @Test
    public void testGetSliceFromLarge() throws Throwable
    {
        // tests slicing against 1000 columns in an sstable
        Table table = Table.open("Keyspace1");
        ColumnFamilyStore cfStore = table.getColumnFamilyStore("Standard1");
        DecoratedKey key = Util.dk("row3");
        RowMutation rm = new RowMutation("Keyspace1", key.key);
        ColumnFamily cf = ColumnFamily.create("Keyspace1", "Standard1");
        for (int i = 1000; i < 2000; i++)
            cf.addColumn(column("col" + i, ("v" + i), new TimestampClock(1L)));
        rm.add(cf);
        rm.apply();
        cfStore.forceBlockingFlush();

        validateSliceLarge(cfStore);
        // compact so we have a big row with more than the minimum index count
        if (cfStore.getSSTables().size() > 1)
        {
            CompactionManager.instance.submitMajor(cfStore).get();
        }
        SSTableReader sstable = cfStore.getSSTables().iterator().next();
        long position = sstable.getPosition(key);
        BufferedRandomAccessFile file = new BufferedRandomAccessFile(sstable.getFilename(), "r");
        file.seek(position);
        assert Arrays.equals(FBUtilities.readShortByteArray(file), key.key);
        file.readInt();
        IndexHelper.skipBloomFilter(file);
        ArrayList<IndexHelper.IndexInfo> indexes = IndexHelper.deserializeIndex(file);
        assert indexes.size() > 2;
        validateSliceLarge(cfStore);
    }

