    /**
     * if columnNameComparator is CompositeType the columns are compared by components using the subcomparator
     * on the same position.
     *
     * if comparator is not CompositeType, the lists are assumed to be of max size 1 and compared using the comparator
     * directly.
     *
     * @param maxColumnNames lhs
     * @param candidates rhs
     * @param columnNameComparator comparator to use
     * @return a list with biggest column names according to (sub)comparator
     */
    public static List<ByteBuffer> mergeMax(List<ByteBuffer> maxColumnNames, List<ByteBuffer> candidates, AbstractType<?> columnNameComparator)
    {
        if (maxColumnNames.size() == 0)
            return candidates;

        if (candidates.size() == 0)
            return maxColumnNames;

        if (columnNameComparator instanceof CompositeType)
        {
            CompositeType ct = (CompositeType)columnNameComparator;
            List<ByteBuffer> retList = new ArrayList<ByteBuffer>(ct.types.size());
            for (int i = 0; i < maxColumnNames.size(); i++)
            {
                retList.add(max(maxColumnNames.get(i), candidates.get(i), ct.types.get(i)));
            }
            return retList;
        }
        else
        {
            return Collections.singletonList(max(maxColumnNames.get(0), candidates.get(0), columnNameComparator));
        }

    }

