        protected boolean fetchMoreData()
        {
            if (!hasMoreSlice())
                return false;

            // If we read blocks in reversed disk order, we may have columns from the previous block to handle.
            // Note that prefetched keeps columns in reversed disk order.
            // Also note that Range Tombstone handling is a bit tricky, because we may run into range tombstones
            // that cover a slice *after* we've move to the previous slice. To keep it simple, we simply include
            // every RT in prefetched: it's only slightly inefficient to do so and there is only so much RT that
            // can be mistakenly added this way.
            if (reversed && !prefetched.isEmpty())
            {
                // Avoids some comparison when we know it's not useful
                boolean inSlice = false;

                OnDiskAtom prefetchedCol;
                while ((prefetchedCol = prefetched.peek() ) != null)
                {
                    // col is before slice, we update the slice
                    if (isColumnBeforeSliceStart(prefetchedCol))
                    {
                        inSlice = false;

                        // As explained above, we add RT unconditionally
                        if (prefetchedCol instanceof RangeTombstone)
                        {
                            blockColumns.addLast(prefetched.poll());
                            continue;
                        }

                        // Otherwise, we either move to the next slice or, if we have none (which can happen
                        // because we unwind prefetched no matter what due to RT), we skip the cell
                        if (hasMoreSlice())
                            setNextSlice();
                        else
                            prefetched.poll();

                    }
                    // col is within slice, all columns
                    // (we go in reverse, so as soon as we are in a slice, no need to check
                    // we're after the slice until we change slice)
                    else if (inSlice || isColumnBeforeSliceFinish(prefetchedCol))
                    {
                        blockColumns.addLast(prefetched.poll());
                        inSlice = true;
                    }
                    // if col is after slice, ignore
                    else
                    {
                        prefetched.poll();
                    }
                }
                if (!blockColumns.isEmpty())
                    return true;
            }
            try
            {
                return getNextBlock();
            }
            catch (IOException e)
            {
                throw new CorruptSSTableException(e, file.getPath());
            }
        }

