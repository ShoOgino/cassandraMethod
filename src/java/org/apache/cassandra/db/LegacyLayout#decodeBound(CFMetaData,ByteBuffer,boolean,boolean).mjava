    private static LegacyBound decodeBound(CFMetaData metadata, ByteBuffer bound, boolean isStart, boolean isDeletion)
    {
        if (!bound.hasRemaining())
            return isStart ? LegacyBound.BOTTOM : LegacyBound.TOP;

        if (!metadata.isCompound())
        {
            // The non compound case is a lot easier, in that there is no EOC nor collection to worry about, so dealing
            // with that first.
            return new LegacyBound(isStart ? Slice.Bound.inclusiveStartOf(bound) : Slice.Bound.inclusiveEndOf(bound), false, null);
        }

        int clusteringSize = metadata.comparator.size();

        boolean isStatic = metadata.isCompound() && CompositeType.isStaticName(bound);
        List<ByteBuffer> components = CompositeType.splitName(bound);
        byte eoc = CompositeType.lastEOC(bound);

        // if the bound we have decoded is static, 2.2 format requires there to be N empty clusterings
        assert !isStatic ||
                (components.size() >= clusteringSize
                        && all(components.subList(0, clusteringSize), ByteBufferUtil.EMPTY_BYTE_BUFFER::equals));
        ColumnDefinition collectionName = null;
        if (components.size() > clusteringSize)
        {
            // For a deletion, there can be more components than the clustering size only in the case this is the
            // bound of a collection range tombstone. In such a case, there is exactly one more component, and that
            // component is the name of the collection being selected/deleted.
            // If the bound is not part of a deletion, it is from slice query filter. In this scnario, the column name
            // may be a valid, non-collection column or it may be an empty buffer, representing a row marker. In either
            // case, this needn't be included in the returned bound, so we pop the last element from the components
            // list but ensure that the collection name remains null.

            assert clusteringSize + 1 == components.size() && !metadata.isCompactTable();
            // pop the final element from the back of the list of clusterings
            ByteBuffer columnNameBytes = components.remove(clusteringSize);
            if (isDeletion)
            {
                collectionName = metadata.getColumnDefinition(columnNameBytes);
                if (collectionName == null || !collectionName.isComplex())
                {
                    collectionName = metadata.getDroppedColumnDefinition(columnNameBytes, isStatic);
                    // if no record of the column having ever existed is found, something is badly wrong
                    if (collectionName == null)
                        throw new RuntimeException("Unknown collection column " + UTF8Type.instance.getString(columnNameBytes) + " during deserialization");

                    // if we do have a record of dropping this column but it wasn't previously complex, use a fake
                    // column definition for safety (see the comment on the constant declaration for details)
                    if (!collectionName.isComplex())
                        collectionName = INVALID_DROPPED_COMPLEX_SUBSTITUTE_COLUMN;
                }
            }
        }

        boolean isInclusive;
        if (isStart)
        {
            isInclusive = eoc <= 0;
        }
        else
        {
            isInclusive = eoc >= 0;

            // for an end bound, if we only have a prefix of all the components and the final EOC is zero,
            // then it should only match up to the prefix but no further, that is, it is an inclusive bound
            // of the exact prefix but an exclusive bound of anything beyond it, so adding an empty
            // composite value ensures this behavior, see CASSANDRA-12423 for more details
            if (eoc == 0 && components.size() < clusteringSize)
            {
                components.add(ByteBufferUtil.EMPTY_BYTE_BUFFER);
                isInclusive = false;
            }
        }

        Slice.Bound.Kind boundKind = Slice.Bound.boundKind(isStart, isInclusive);
        Slice.Bound sb = Slice.Bound.create(boundKind, components.toArray(new ByteBuffer[components.size()]));
        return new LegacyBound(sb, isStatic, collectionName);
    }

