    public RowMutation mutationForKey(CFDefinition cfDef, ClientState clientState, ByteBuffer key, ColumnNameBuilder builder, CFDefinition.Name firstEmpty, List<ByteBuffer> variables)
    throws InvalidRequestException
    {
        QueryProcessor.validateKey(key);
        RowMutation rm = new RowMutation(cfDef.cfm.ksName, key);
        ColumnFamily cf = rm.addOrGet(columnFamily());
        int localDeleteTime = (int) (System.currentTimeMillis() / 1000);

        if (columns.isEmpty() && builder.componentCount() == 0)
        {
            // No columns, delete the row
            cf.delete(new DeletionInfo(getTimestamp(clientState), localDeleteTime));
        }
        else
        {
            boolean fullKey = builder.componentCount() == cfDef.columns.size();
            boolean isRange = cfDef.isCompact ? !fullKey : (!fullKey || columns.isEmpty());

            if (!columns.isEmpty())
            {
                if (isRange)
                    throw new InvalidRequestException(String.format("Missing mandatory PRIMARY KEY part %s since %s specified", firstEmpty, columns.iterator().next()));

                for (ColumnIdentifier column : columns)
                {
                    CFDefinition.Name name = cfDef.get(column);
                    if (name == null)
                        throw new InvalidRequestException(String.format("Unknown identifier %s", column));

                    // For compact, we only have one value except the key, so the only form of DELETE that make sense is without a column
                    // list. However, we support having the value name for coherence with the static/sparse case
                    if (name.kind != CFDefinition.Name.Kind.COLUMN_METADATA && name.kind != CFDefinition.Name.Kind.VALUE_ALIAS)
                        throw new InvalidRequestException(String.format("Invalid identifier %s for deletion (should not be a PRIMARY KEY part)", column));
                }
            }

            if (isRange)
            {
                ByteBuffer start = builder.copy().build();
                ByteBuffer end = builder.buildAsEndOfRange();
                QueryProcessor.validateColumnName(start); // If start is good, end is too
                cf.delete(new DeletionInfo(start, end, cfDef.cfm.comparator, getTimestamp(clientState), localDeleteTime));
            }
            else
            {
                // Delete specific columns
                if (cfDef.isCompact)
                {
                        ByteBuffer columnName = builder.build();
                        QueryProcessor.validateColumnName(columnName);
                        cf.addTombstone(columnName, localDeleteTime, getTimestamp(clientState));
                }
                else
                {
                    Iterator<ColumnIdentifier> iter = columns.iterator();
                    while (iter.hasNext())
                    {
                        ColumnIdentifier column = iter.next();
                        ColumnNameBuilder b = iter.hasNext() ? builder.copy() : builder;
                        ByteBuffer columnName = b.add(column.key).build();
                        QueryProcessor.validateColumnName(columnName);
                        cf.addTombstone(columnName, localDeleteTime, getTimestamp(clientState));
                    }
                }
            }
        }

        return rm;
    }

