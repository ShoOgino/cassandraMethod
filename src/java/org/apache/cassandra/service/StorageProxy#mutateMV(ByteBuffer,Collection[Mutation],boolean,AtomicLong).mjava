    /**
     * Use this method to have these Mutations applied
     * across all replicas.
     *
     * @param mutations the mutations to be applied across the replicas
     * @param writeCommitLog if commitlog should be written
     * @param baseComplete time from epoch in ms that the local base mutation was(or will be) completed
     */
    public static void mutateMV(ByteBuffer dataKey, Collection<Mutation> mutations, boolean writeCommitLog, AtomicLong baseComplete)
    throws UnavailableException, OverloadedException, WriteTimeoutException
    {
        Tracing.trace("Determining replicas for mutation");
        final String localDataCenter = DatabaseDescriptor.getEndpointSnitch().getDatacenter(FBUtilities.getBroadcastAddress());

        long startTime = System.nanoTime();
        List<WriteResponseHandlerWrapper> wrappers = new ArrayList<>(mutations.size());

        try
        {
            Token baseToken = StorageService.instance.getTokenMetadata().partitioner.getToken(dataKey);

            ConsistencyLevel consistencyLevel = ConsistencyLevel.ONE;

            //Since the base -> view replication is 1:1 we only need to store the BL locally
            final Collection<InetAddress> batchlogEndpoints = Collections.singleton(FBUtilities.getBroadcastAddress());
            final UUID batchUUID = UUIDGen.getTimeUUID();
            BatchlogResponseHandler.BatchlogCleanup cleanup = new BatchlogResponseHandler.BatchlogCleanup(mutations.size(),
                                                                                                          () -> asyncRemoveFromBatchlog(batchlogEndpoints, batchUUID));

            // add a handler for each mutation - includes checking availability, but doesn't initiate any writes, yet
            for (Mutation mutation : mutations)
            {
                String keyspaceName = mutation.getKeyspaceName();
                Token tk = mutation.key().getToken();
                InetAddress pairedEndpoint = ViewUtils.getViewNaturalEndpoint(keyspaceName, baseToken, tk);
                List<InetAddress> naturalEndpoints = Lists.newArrayList(pairedEndpoint);

                WriteResponseHandlerWrapper wrapper = wrapViewBatchResponseHandler(mutation,
                                                                                   consistencyLevel,
                                                                                   consistencyLevel,
                                                                                   naturalEndpoints,
                                                                                   baseComplete,
                                                                                   WriteType.BATCH,
                                                                                   cleanup);

                // When local node is the endpoint and there are no pending nodes we can
                // Just apply the mutation locally.
                if (pairedEndpoint.equals(FBUtilities.getBroadcastAddress()) && wrapper.handler.pendingEndpoints.isEmpty())
                {
                    mutation.apply(writeCommitLog);
                    viewWriteMetrics.viewReplicasSuccess.inc();
                }
                else
                    wrappers.add(wrapper);
            }

            if (!wrappers.isEmpty())
            {
                // Apply to local batchlog memtable in this thread
                BatchlogManager.store(Batch.createLocal(batchUUID, FBUtilities.timestampMicros(), Lists.transform(wrappers, w -> w.mutation)),
                                      writeCommitLog);

                // now actually perform the writes and wait for them to complete
                asyncWriteBatchedMutations(wrappers, localDataCenter, Stage.VIEW_MUTATION);
            }
        }
        finally
        {
            viewWriteMetrics.addNano(System.nanoTime() - startTime);
        }
    }

