    /**
     * Applies the counter mutation, returns the result Mutation (for replication to other nodes).
     *
     * 1. Grabs the striped cell-level locks in the proper order
     * 2. Gets the current values of the counters-to-be-modified from the counter cache
     * 3. Reads the rest of the current values (cache misses) from the CF
     * 4. Writes the updated counter values
     * 5. Updates the counter cache
     * 6. Releases the lock(s)
     *
     * See CASSANDRA-4775 and CASSANDRA-6504 for further details.
     *
     * @return the applied resulting Mutation
     */
    public Mutation apply() throws WriteTimeoutException
    {
        Mutation result = new Mutation(getKeyspaceName(), key());
        Keyspace keyspace = Keyspace.open(getKeyspaceName());

        int count = 0;
        for (ColumnFamily cf : getColumnFamilies())
            count += cf.getColumnCount();

        List<Lock> locks = new ArrayList<>(count);
        Tracing.trace("Acquiring {} counter locks", count);
        try
        {
            grabCounterLocks(keyspace, locks);
            for (ColumnFamily cf : getColumnFamilies())
                result.add(processModifications(cf));
            result.apply();
            updateCounterCache(result, keyspace);
            return result;
        }
        finally
        {
            for (Lock lock : locks)
                lock.unlock();
        }
    }

