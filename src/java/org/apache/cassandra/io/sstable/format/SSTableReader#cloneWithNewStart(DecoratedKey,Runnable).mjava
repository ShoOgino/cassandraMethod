    public SSTableReader cloneWithNewStart(DecoratedKey newStart, final Runnable runOnClose)
    {
        synchronized (tidy.global)
        {
            assert openReason != OpenReason.EARLY;
            SSTableReader replacement = internalOpen(descriptor, components, metadata, partitioner, ifile.sharedCopy(),
                                                          dfile.sharedCopy(), indexSummary.sharedCopy(), bf.sharedCopy(),
                                                          maxDataAge, sstableMetadata, OpenReason.MOVED_START);
            // TODO: make data/index start accurate for compressed files
            // TODO: merge with caller's firstKeyBeyond() work,to save time
            if (newStart.compareTo(first) > 0)
            {
                final long dataStart = getPosition(newStart, Operator.EQ).position;
                final long indexStart = getIndexScanPosition(newStart);
                this.tidy.runOnClose = new Runnable()
                {
                    public void run()
                    {
                        CLibrary.trySkipCache(dfile.path, 0, dataStart);
                        CLibrary.trySkipCache(ifile.path, 0, indexStart);
                        if (runOnClose != null)
                            runOnClose.run();
                    }
                };
            }

            replacement.first = newStart;
            replacement.last = this.last;
            setReplacedBy(replacement);
            return replacement;
        }
    }

