    // Used by ModificationStatement for CAS operations
    void processColumnFamily(CFDefinition cfDef,
                             ByteBuffer key,
                             ColumnFamily cf,
                             List<ByteBuffer> variables,
                             long now,
                             Selection.ResultSetBuilder result) throws InvalidRequestException
    {
        ByteBuffer[] keyComponents = cfDef.hasCompositeKey
                                   ? ((CompositeType) cfm.getKeyValidator()).split(key)
                                   : new ByteBuffer[]{ key };

        if (parameters.isDistinct && !selectsStaticColumns)
        {
            if (!cf.hasOnlyTombstones(now))
            {
                result.newRow();
                // selection.getColumns() will contain only the partition key components - all of them.
                for (CFDefinition.Name name : selection.getColumns())
                    result.add(keyComponents[name.position]);
            }
        }
        else if (cfDef.isCompact)
        {
            // One cqlRow per column
            for (Column c : cf)
            {
                if (c.isMarkedForDelete(now))
                    continue;

                ByteBuffer[] components = null;
                if (cfDef.isComposite)
                {
                    components = ((CompositeType) cfm.comparator).split(c.name());
                }
                else if (sliceRestriction != null)
                {
                    Comparator<ByteBuffer> comp = cfm.comparator;
                    // For dynamic CF, the column could be out of the requested bounds, filter here

                    if (!sliceRestriction.isInclusive(Bound.START))
                    {
                        // even though it's a multi-column restriction, we know it can only contain a bound for one
                        // column because we've already checked that the comparator is not composite
                        ByteBuffer bounds = sliceRestriction.isMultiColumn()
                                            ? ((MultiColumnRestriction.Slice) sliceRestriction).componentBounds(Bound.START, variables).get(0)
                                            : sliceRestriction.bound(Bound.START, variables);
                        if (comp.compare(c.name(), bounds) == 0)
                            continue;
                    }

                    if (!sliceRestriction.isInclusive(Bound.END))
                    {
                        // see the above comment on using the first bound from the multi-column restriction
                        ByteBuffer bounds = sliceRestriction.isMultiColumn()
                                            ? ((MultiColumnRestriction.Slice) sliceRestriction).componentBounds(Bound.END, variables).get(0)
                                            : sliceRestriction.bound(Bound.END, variables);
                        if (comp.compare(c.name(), bounds) == 0)
                            continue;
                    }
                }

                result.newRow();
                // Respect selection order
                for (CFDefinition.Name name : selection.getColumns())
                {
                    switch (name.kind)
                    {
                        case KEY_ALIAS:
                            result.add(keyComponents[name.position]);
                            break;
                        case COLUMN_ALIAS:
                            ByteBuffer val = cfDef.isComposite
                                           ? (name.position < components.length ? components[name.position] : null)
                                           : c.name();
                            result.add(val);
                            break;
                        case VALUE_ALIAS:
                            result.add(c);
                            break;
                        case COLUMN_METADATA:
                        case STATIC:
                            // This should not happen for compact CF
                            throw new AssertionError();
                        default:
                            throw new AssertionError();
                    }
                }
            }
        }
        else if (cfDef.isComposite)
        {
            // Sparse case: group column in cqlRow when composite prefix is equal
            CompositeType composite = (CompositeType) cfm.comparator;

            ColumnGroupMap.Builder builder = new ColumnGroupMap.Builder(composite, cfDef.hasCollections, now);

            for (Column c : cf)
            {
                if (c.isMarkedForDelete(now))
                    continue;

                builder.add(c);
            }

            ColumnGroupMap staticGroup = null;
            // Gather up static values first
            if (!builder.isEmpty() && builder.firstGroup().isStatic)
            {
                staticGroup = builder.firstGroup();
                builder.discardFirst();

                // If there was static columns but there is no actual row, then provided the select was a full
                // partition selection (i.e. not a 2ndary index search and there was no condition on clustering columns)
                // then we want to include the static columns in the result set.
                if (builder.isEmpty() && !usesSecondaryIndexing && hasNoClusteringColumnsRestriction() && hasValueForQuery(staticGroup))
                {
                    handleGroup(result, keyComponents, ColumnGroupMap.EMPTY, staticGroup);
                    return;
                }
            }

            for (ColumnGroupMap group : builder.groups())
                handleGroup(result, keyComponents, group, staticGroup);
        }
        else
        {
            if (cf.hasOnlyTombstones(now))
                return;

            // Static case: One cqlRow for all columns
            result.newRow();
            for (CFDefinition.Name name : selection.getColumns())
            {
                if (name.kind == CFDefinition.Name.Kind.KEY_ALIAS)
                    result.add(keyComponents[name.position]);
                else
                    result.add(cf.getColumn(name.name.key));
            }
        }
    }

