    /**
     * Calculates ownership. If there are multiple DC's and the replication strategy is DC aware then ownership will be
     * calculated per dc, i.e. each DC will have total ring ownership divided amongst its nodes. Without replication
     * total ownership will be a multiple of the number of DC's and this value will then go up within each DC depending
     * on the number of replicas within itself. For DC unaware replication strategies, ownership without replication
     * will be 100%.
     * 
     * @throws ConfigurationException
     */
    public LinkedHashMap<InetAddress, Float> effectiveOwnership(String keyspace) throws ConfigurationException
    {
        if (Schema.instance.getNonSystemTables().size() <= 0)
            throw new ConfigurationException("Couldn't find any Non System Keyspaces to infer replication topology");
        if (keyspace == null && !hasSameReplication(Schema.instance.getNonSystemTables()))
            throw new ConfigurationException("Non System keyspaces doesnt have the same topology");

        TokenMetadata metadata = tokenMetadata.cloneOnlyTokenMap();
        
        if (keyspace == null)
            keyspace = Schema.instance.getNonSystemTables().get(0);

        Collection<Collection<InetAddress>> endpointsGroupedByDc = new ArrayList<Collection<InetAddress>>();
        // mapping of dc's to nodes, use sorted map so that we get dcs sorted
        SortedMap<String, Collection<InetAddress>> sortedDcsToEndpoints = new TreeMap<String, Collection<InetAddress>>();
        sortedDcsToEndpoints.putAll(metadata.getTopology().getDatacenterEndpoints().asMap());
        for (Collection<InetAddress> endpoints : sortedDcsToEndpoints.values())
            endpointsGroupedByDc.add(endpoints);

        Map<Token, Float> tokenOwnership = getPartitioner().describeOwnership(tokenMetadata.sortedTokens());
        LinkedHashMap<InetAddress, Float> finalOwnership = Maps.newLinkedHashMap();

        // calculate ownership per dc
        for (Collection<InetAddress> endpoints : endpointsGroupedByDc)
        {
            // sort the endpoints by their tokens
            List<InetAddress> sortedEndpoints = Lists.newArrayListWithExpectedSize(endpoints.size());
            sortedEndpoints.addAll(endpoints);

            Collections.sort(sortedEndpoints, new Comparator<InetAddress>()
            {
                public int compare(InetAddress o1, InetAddress o2)
                {
                    byte[] b1 = o1.getAddress();
                    byte[] b2 = o2.getAddress();

                    if(b1.length < b2.length) return -1;
                    if(b1.length > b2.length) return 1;

                    for(int i = 0; i < b1.length; i++)
                    {
                        int left = (int)b1[i] & 0xFF;
                        int right = (int)b2[i] & 0xFF;
                        if (left < right)       return -1;
                        else if (left > right)  return 1;
                    }
                    return 0;
                }
            });

            // calculate the ownership with replication and add the endpoint to the final ownership map
            for (InetAddress endpoint : endpoints)
            {
                float ownership = 0.0f;
                for (Range<Token> range : getRangesForEndpoint(keyspace, endpoint))
                {
                    if (tokenOwnership.containsKey(range.left))
                        ownership += tokenOwnership.get(range.left);
                }
                finalOwnership.put(endpoint, ownership);
            }
        }
        return finalOwnership;
    }

