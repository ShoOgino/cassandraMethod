    public synchronized void promote(Iterable<SSTableReader> removed, Iterable<SSTableReader> added)
    {
        assert !Iterables.isEmpty(removed); // use add() instead of promote when adding new sstables
        logDistribution();
        if (logger.isDebugEnabled())
            logger.debug("Replacing [" + toString(removed) + "]");

        // the level for the added sstables is the max of the removed ones,
        // plus one if the removed were all on the same level
        int minimumLevel = Integer.MAX_VALUE;
        int maximumLevel = 0;
        for (SSTableReader sstable : removed)
        {
            int thisLevel = levelOf(sstable);
            assert thisLevel >= 0;
            maximumLevel = Math.max(maximumLevel, thisLevel);
            minimumLevel = Math.min(minimumLevel, thisLevel);
            remove(sstable);
        }

        // it's valid to do a remove w/o an add (e.g. on truncate)
        if (!added.iterator().hasNext())
            return;

        // avoid increasing the level if we had a single source sstable involved.  This prevents
        // cleanup, scrub, and upgradesstables from blowing through the level cap.
        // See CASSANDRA-3989
        int newLevel = Iterables.size(removed) == 1
                     ? maximumLevel
                     : minimumLevel == maximumLevel ? maximumLevel + 1 : maximumLevel;

        newLevel = skipLevels(newLevel, added);
        assert newLevel > 0;
        if (logger.isDebugEnabled())
            logger.debug("Adding [{}] at L{}", toString(added), newLevel);

        lastCompactedKeys[minimumLevel] = SSTable.sstableOrdering.max(added).last;
        for (SSTableReader ssTableReader : added)
            add(ssTableReader, newLevel);

        serialize();
    }

