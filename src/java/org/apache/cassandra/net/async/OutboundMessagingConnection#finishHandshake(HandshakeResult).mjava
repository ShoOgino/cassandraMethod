    /**
     * Process the results of the handshake negotiation.
     * <p>
     * Note: this method will be invoked from the netty event loop,
     * so there's an inherent race with {@link #connectionTimeout(ChannelFuture)}.
     */
    void finishHandshake(HandshakeResult result)
    {
        // clean up the connector instances before changing the state
        if (connectionTimeoutFuture != null)
        {
            connectionTimeoutFuture.cancel(false);
            connectionTimeoutFuture = null;
        }
        if (connectionRetryFuture != null)
        {
            connectionRetryFuture.cancel(false);
            connectionRetryFuture = null;
        }
        connectAttemptCount = 0;

        if (result.negotiatedMessagingVersion != HandshakeResult.UNKNOWN_PROTOCOL_VERSION)
        {
            targetVersion = result.negotiatedMessagingVersion;
            MessagingService.instance().setVersion(connectionId.remote(), targetVersion);
        }

        switch (result.outcome)
        {
            case SUCCESS:
                assert result.channelWriter != null;
                logger.debug("successfully connected to {}, conmpress = {}, coalescing = {}", connectionId,
                             shouldCompressConnection(connectionId.local(), connectionId.remote()),
                             coalescingStrategy.isPresent() ? coalescingStrategy.get() : CoalescingStrategies.Strategy.DISABLED);
                if (state.get() == State.CLOSED)
                {
                    result.channelWriter.close();
                    backlog.clear();
                    break;
                }
                channelWriter = result.channelWriter;
                // drain the backlog to the channel
                channelWriter.writeBacklog(backlog, true);
                // change the state so newly incoming messages can be sent to the channel (without adding to the backlog)
                setStateIfNotClosed(state, State.READY);
                // ship out any stragglers that got added to the backlog
                channelWriter.writeBacklog(backlog, true);
                break;
            case DISCONNECT:
                reconnect();
                break;
            case NEGOTIATION_FAILURE:
                setStateIfNotClosed(state, State.NOT_READY);
                backlog.clear();
                break;
            default:
                throw new IllegalArgumentException("unhandled result type: " + result.outcome);
        }
    }

