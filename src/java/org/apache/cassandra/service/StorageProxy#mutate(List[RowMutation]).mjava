    /**
     * Use this method to have these RowMutations applied
     * across all replicas. This method will take care
     * of the possibility of a replica being down and hint
     * the data across to some other replica.
     *
     * This is the ZERO consistency level. We do not wait for replies.
     *
     * @param mutations the mutations to be applied across the replicas
    */
    public static void mutate(List<RowMutation> mutations)
    {
        long startTime = System.currentTimeMillis();
        try
        {
            for (final RowMutation rm: mutations)
            {
                try
                {
                    List<InetAddress> naturalEndpoints = StorageService.instance.getNaturalEndpoints(rm.key());
                    Map<InetAddress, InetAddress> endpointMap = StorageService.instance.getHintedEndpointMap(rm.key(), naturalEndpoints);
                    Message unhintedMessage = null; // lazy initialize for non-local, unhinted writes

                    // 3 cases:
                    // 1. local, unhinted write: run directly on write stage
                    // 2. non-local, unhinted write: send row mutation message
                    // 3. hinted write: add hint header, and send message
                    for (Map.Entry<InetAddress, InetAddress> entry : endpointMap.entrySet())
                    {
                        InetAddress target = entry.getKey();
                        InetAddress hintedTarget = entry.getValue();
                        if (target.equals(hintedTarget))
                        {
                            if (target.equals(FBUtilities.getLocalAddress()))
                            {
                                if (logger.isDebugEnabled())
                                    logger.debug("insert writing local key " + rm.key());
                                Runnable runnable = new WrappedRunnable()
                                {
                                    public void runMayThrow() throws IOException
                                    {
                                        rm.apply();
                                    }
                                };
                                StageManager.getStage(StageManager.MUTATION_STAGE).execute(runnable);
                            }
                            else
                            {
                                if (unhintedMessage == null)
                                    unhintedMessage = rm.makeRowMutationMessage();
                                if (logger.isDebugEnabled())
                                    logger.debug("insert writing key " + rm.key() + " to " + unhintedMessage.getMessageId() + "@" + target);
                                MessagingService.instance().sendOneWay(unhintedMessage, target);
                            }
                        }
                        else
                        {
                            Message hintedMessage = rm.makeRowMutationMessage();
                            hintedMessage.addHeader(RowMutation.HINT, target.getAddress());
                            if (logger.isDebugEnabled())
                                logger.debug("insert writing key " + rm.key() + " to " + hintedMessage.getMessageId() + "@" + hintedTarget + " for " + target);
                            MessagingService.instance().sendOneWay(hintedMessage, hintedTarget);
                        }
                    }
                }
                catch (IOException e)
                {
                    throw new RuntimeException("error inserting key " + rm.key(), e);
                }
            }
        }
        finally
        {
            writeStats.add(System.currentTimeMillis() - startTime);
        }
    }

