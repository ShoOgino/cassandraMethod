    /**
     * There is two phase to the removal of old shards.
     * First phase: we merge the old shard value to the current shard and
     * 'nulify' the old one. We then send the counter context with the old
     * shard nulified to all other replica.
     * Second phase: once an old shard has been nulified for longer than
     * gc_grace (to be sure all other replica had been aware of the merge), we
     * simply remove that old shard from the context (it's value is 0).
     * This method does both phases.
     * (Note that the sendToOtherReplica flag is here only to facilitate
     * testing. It should be true in real code so use the method above
     * preferably)
     */
    public static void mergeAndRemoveOldShards(DecoratedKey key, ColumnFamily cf, int gcBefore, int mergeBefore, boolean sendToOtherReplica)
    {
        ColumnFamily remoteMerger = null;

        for (Cell c : cf)
        {
            if (!(c instanceof CounterCell))
                continue;
            CounterCell cc = (CounterCell) c;
            CounterCell shardMerger = cc.computeOldShardMerger(mergeBefore);
            CounterCell merged = cc;
            if (shardMerger != null)
            {
                merged = (CounterCell) cc.reconcile(shardMerger);
                if (remoteMerger == null)
                    remoteMerger = cf.cloneMeShallow();
                remoteMerger.addColumn(merged);
            }
            CounterCell cleaned = merged.removeOldShards(gcBefore);
            if (cleaned != cc)
            {
                cf.replace(cc, cleaned);
            }
        }

        if (remoteMerger != null && sendToOtherReplica)
        {
            try
            {
                sendToOtherReplica(key, remoteMerger);
            }
            catch (Exception e)
            {
                logger.error("Error while sending shard merger mutation to remote endpoints", e);
            }
        }
    }

