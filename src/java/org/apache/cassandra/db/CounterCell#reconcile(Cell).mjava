    @Override
    public Cell reconcile(Cell cell)
    {
        // live + tombstone: track last tombstone
        if (cell.isMarkedForDelete(Long.MIN_VALUE)) // cannot be an expired cell, so the current time is irrelevant
        {
            // live < tombstone
            if (timestamp() < cell.timestamp())
            {
                return cell;
            }
            // live last delete >= tombstone
            if (timestampOfLastDelete() >= cell.timestamp())
            {
                return this;
            }
            // live last delete < tombstone
            return new CounterCell(name(), value(), timestamp(), cell.timestamp());
        }

        assert cell instanceof CounterCell : "Wrong class type: " + cell.getClass();

        // live < live last delete
        if (timestamp() < ((CounterCell) cell).timestampOfLastDelete())
            return cell;
        // live last delete > live
        if (timestampOfLastDelete() > cell.timestamp())
            return this;

        // live + live. return one of the cells if its context is a superset of the other's, or merge them otherwise
        ByteBuffer context = contextManager.merge(value(), cell.value());
        if (context == value() && timestamp() >= cell.timestamp() && timestampOfLastDelete() >= ((CounterCell) cell).timestampOfLastDelete())
            return this;
        else if (context == cell.value() && cell.timestamp() >= timestamp() && ((CounterCell) cell).timestampOfLastDelete() >= timestampOfLastDelete())
            return cell;
        else // merge clocks and timsestamps.
            return new CounterCell(name(),
                                   context,
                                   Math.max(timestamp(), cell.timestamp()),
                                   Math.max(timestampOfLastDelete(), ((CounterCell) cell).timestampOfLastDelete()));
    }

