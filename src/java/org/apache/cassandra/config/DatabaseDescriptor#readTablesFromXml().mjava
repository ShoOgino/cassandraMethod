    /** reads xml. doesn't populate any internal structures. */
    public static Collection<KSMetaData> readTablesFromXml() throws ConfigurationException
    {
        List<KSMetaData> defs = new ArrayList<KSMetaData>();
        XMLUtils xmlUtils = null;
        try
        {
            xmlUtils = new XMLUtils(configFileName);
        }
        catch (ParserConfigurationException e)
        {
            ConfigurationException ex = new ConfigurationException(e.getMessage());
            ex.initCause(e);
            throw ex;
        }
        catch (SAXException e)
        {
            ConfigurationException ex = new ConfigurationException(e.getMessage());
            ex.initCause(e);
            throw ex;
        }
        catch (IOException e)
        {
            ConfigurationException ex = new ConfigurationException(e.getMessage());
            ex.initCause(e);
            throw ex;
        }

        /* Read the table related stuff from config */
        try
        {
            NodeList tablesxml = xmlUtils.getRequestedNodeList("/Storage/Keyspaces/Keyspace");
            int size = tablesxml.getLength();
            for ( int i = 0; i < size; ++i )
            {
                String value = null;
                Node table = tablesxml.item(i);

                /* parsing out the table ksName */
                String ksName = XMLUtils.getAttributeValue(table, "Name");
                if (ksName == null)
                {
                    throw new ConfigurationException("Table name attribute is required");
                }
                if (ksName.equalsIgnoreCase(Table.SYSTEM_TABLE))
                {
                    throw new ConfigurationException("'system' is a reserved table name for Cassandra internals");
                }

                /* See which replica placement strategy to use */
                value = xmlUtils.getNodeValue("/Storage/Keyspaces/Keyspace[@Name='" + ksName + "']/ReplicaPlacementStrategy");
                if (value == null)
                {
                    throw new ConfigurationException("Missing replicaplacementstrategy directive for " + ksName);
                }
                Class<? extends AbstractReplicationStrategy> strategyClass = null;
                try
                {
                    strategyClass = (Class<? extends AbstractReplicationStrategy>) Class.forName(value);
                }
                catch (ClassNotFoundException e)
                {
                    throw new ConfigurationException("Invalid replicaplacementstrategy class " + value);
                }

                /* Data replication factor */
                value = xmlUtils.getNodeValue("/Storage/Keyspaces/Keyspace[@Name='" + ksName + "']/ReplicationFactor");
                int replicationFactor = -1;
                if (value == null)
                    throw new ConfigurationException("Missing replicationfactor directory for keyspace " + ksName);
                else
                {
                    replicationFactor = Integer.parseInt(value);
                }

                /* end point snitch */
                String endPointSnitchClassName = xmlUtils.getNodeValue("/Storage/Keyspaces/Keyspace[@Name='" + ksName + "']/EndPointSnitch");
                if (endPointSnitchClassName == null)
                {
                    throw new ConfigurationException("Missing endpointsnitch directive for keyspace " + ksName);
                }
                IEndPointSnitch snitch = null;
                try
                {
                    Class cls = Class.forName(endPointSnitchClassName);
                    snitch = (IEndPointSnitch)cls.getConstructor().newInstance();
                }
                catch (ClassNotFoundException e)
                {
                    throw new ConfigurationException("Invalid endpointsnitch class " + endPointSnitchClassName);
                }
                catch (NoSuchMethodException e)
                {
                    throw new ConfigurationException("Invalid endpointsnitch class " + endPointSnitchClassName + " " + e.getMessage());
                }
                catch (InstantiationException e)
                {
                    throw new ConfigurationException("Invalid endpointsnitch class " + endPointSnitchClassName + " " + e.getMessage());
                }
                catch (IllegalAccessException e)
                {
                    throw new ConfigurationException("Invalid endpointsnitch class " + endPointSnitchClassName + " " + e.getMessage());
                }
                catch (InvocationTargetException e)
                {
                    throw new ConfigurationException("Invalid endpointsnitch class " + endPointSnitchClassName + " " + e.getMessage());
                }

                String xqlTable = "/Storage/Keyspaces/Keyspace[@Name='" + ksName + "']/";
                NodeList columnFamilies = xmlUtils.getRequestedNodeList(xqlTable + "ColumnFamily");

                //NodeList columnFamilies = xmlUtils.getRequestedNodeList(table, "ColumnFamily");
                int size2 = columnFamilies.getLength();
                CFMetaData[] cfDefs = new CFMetaData[size2];
                for ( int j = 0; j < size2; ++j )
                {
                    Node columnFamily = columnFamilies.item(j);
                    String tableName = ksName;
                    String cfName = XMLUtils.getAttributeValue(columnFamily, "Name");
                    if (cfName == null)
                    {
                        throw new ConfigurationException("ColumnFamily name attribute is required");
                    }
                    if (cfName.contains("-"))
                    {
                        throw new ConfigurationException("ColumnFamily names cannot contain hyphens");
                    }
                    String xqlCF = xqlTable + "ColumnFamily[@Name='" + cfName + "']/";

                    // Parse out the column type
                    String rawColumnType = XMLUtils.getAttributeValue(columnFamily, "ColumnType");
                    String columnType = ColumnFamily.getColumnType(rawColumnType);
                    if (columnType == null)
                    {
                        throw new ConfigurationException("ColumnFamily " + cfName + " has invalid type " + rawColumnType);
                    }

                    if (XMLUtils.getAttributeValue(columnFamily, "ColumnSort") != null)
                    {
                        throw new ConfigurationException("ColumnSort is no longer an accepted attribute.  Use CompareWith instead.");
                    }

                    // Parse out the column comparator
                    AbstractType comparator = getComparator(XMLUtils.getAttributeValue(columnFamily, "CompareWith"));
                    AbstractType subcolumnComparator = null;
                    if (columnType.equals("Super"))
                    {
                        subcolumnComparator = getComparator(XMLUtils.getAttributeValue(columnFamily, "CompareSubcolumnsWith"));
                    }
                    else if (XMLUtils.getAttributeValue(columnFamily, "CompareSubcolumnsWith") != null)
                    {
                        throw new ConfigurationException("CompareSubcolumnsWith is only a valid attribute on super columnfamilies (not regular columnfamily " + cfName + ")");
                    }

                    double keyCacheSize = CFMetaData.DEFAULT_KEY_CACHE_SIZE;
                    if ((value = XMLUtils.getAttributeValue(columnFamily, "KeysCachedFraction")) != null)
                    {
                        keyCacheSize = Double.valueOf(value);
                        // TODO: KeysCachedFraction deprecated: remove in 1.0
                        logger.warn("KeysCachedFraction is deprecated: use KeysCached instead.");
                    }
                    if ((value = XMLUtils.getAttributeValue(columnFamily, "KeysCached")) != null)
                    {
                        keyCacheSize = FBUtilities.parseDoubleOrPercent(value);
                    }

                    double rowCacheSize = CFMetaData.DEFAULT_ROW_CACHE_SIZE;
                    if ((value = XMLUtils.getAttributeValue(columnFamily, "RowsCached")) != null)
                    {
                        rowCacheSize = FBUtilities.parseDoubleOrPercent(value);
                    }

                    double readRepairChance = CFMetaData.DEFAULT_READ_REPAIR_CHANCE;
                    if ((value = XMLUtils.getAttributeValue(columnFamily, "ReadRepairChance")) != null)
                    {
                        readRepairChance = FBUtilities.parseDoubleOrPercent(value);
                        if (readRepairChance < 0.0 || readRepairChance > 1.0)
                        {                        
                            throw new ConfigurationException("ReadRepairChance must be between 0.0 and 1.0");
                        }
                    }

                    // Parse out user-specified logical names for the various dimensions
                    // of a the column family from the config.
                    String comment = xmlUtils.getNodeValue(xqlCF + "Comment");

                    // insert it into the table dictionary.
                    cfDefs[j] = new CFMetaData(tableName, cfName, columnType, comparator, subcolumnComparator, comment, rowCacheSize, keyCacheSize, readRepairChance);
                }
                defs.add(new KSMetaData(ksName, strategyClass, replicationFactor, snitch, cfDefs));
            }
        }
        catch (XPathExpressionException e)
        {
            ConfigurationException ex = new ConfigurationException(e.getMessage());
            ex.initCause(e);
            throw ex;
        }
        catch (TransformerException e)
        {
            ConfigurationException ex = new ConfigurationException(e.getMessage());
            ex.initCause(e);
            throw ex;
        }
        return defs;
    }

