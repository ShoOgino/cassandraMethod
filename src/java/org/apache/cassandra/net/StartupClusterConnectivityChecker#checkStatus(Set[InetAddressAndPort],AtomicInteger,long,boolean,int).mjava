    State checkStatus(Set<InetAddressAndPort> peers, AtomicInteger connectedCount, final long startNanos, boolean beyondExpiration, final int completedRounds)
    {
        long currentAlive = peers.stream().filter(gossipStatus).count();
        float currentAlivePercent = ((float) currentAlive / (float) peers.size()) * 100;

        // assume two connections to remote host that we care to track here (small msg & large msg)
        final int totalConnectionsSize = peers.size() * 2;
        final int connectionsCount = connectedCount.get();
        float currentConnectedPercent = ((float) connectionsCount / (float) totalConnectionsSize) * 100;

        if (currentAlivePercent >= targetPercent && currentConnectedPercent >= targetPercent)
        {
            logger.info("after {} milliseconds, found {}% ({} / {}) of peers as marked alive, " +
                        "and {}% ({} / {}) of peers as connected, " +
                        "both of which are above the desired threshold of {}%",
                        TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanos),
                        currentAlivePercent, currentAlive, peers.size(),
                        currentConnectedPercent, connectionsCount, totalConnectionsSize,
                        targetPercent);
            return State.FINISH_SUCCESS;
        }

        // perform at least two rounds of checking, else this is kinda useless (and the operator set the aliveTimeoutSecs too low)
        if (completedRounds >= 2 && beyondExpiration)
        {
            logger.info("after {} milliseconds, found {}% ({} / {}) of peers as marked alive, " +
                        "and {}% ({} / {}) of peers as connected, " +
                        "one or both of which is below the desired threshold of {}%",
                        TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanos),
                        currentAlivePercent, currentAlive, peers.size(),
                        currentConnectedPercent, connectionsCount, totalConnectionsSize,
                        targetPercent);
            return State.FINISH_TIMEOUT;
        }
        return State.CONTINUE;
    }

