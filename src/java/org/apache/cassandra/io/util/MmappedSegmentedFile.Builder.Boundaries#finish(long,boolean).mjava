            // returns the finished boundaries for the provided length, truncated to a correctly sized long[]
            public long[] finish(long length, boolean isFinal)
            {
                assert length > 0;
                // ensure there's room for the length to be added
                boundaries = ensureCapacity(boundaries, fixedCount);

                // clone our current contents, so we don't corrupt them
                int fixedCount = this.fixedCount;
                long[] boundaries = this.boundaries.clone();

                // if we're finishing early, our length may be before some of our boundaries,
                // so walk backwards until our boundaries are <= length
                while (boundaries[fixedCount - 1] >= length)
                    boundaries[fixedCount--] = 0;
                if (boundaries[fixedCount] >= length)
                    boundaries[fixedCount] = 0;

                // add our length as a boundary
                fixedCount = addCandidate(boundaries, fixedCount, length);

                // if we have any unfixed boundary at the end, it's now fixed, since we're done
                if (boundaries[fixedCount] != 0)
                    fixedCount++;

                boundaries = Arrays.copyOf(boundaries, fixedCount);
                if (isFinal)
                {
                    // if this is the final one, save it
                    this.boundaries = boundaries;
                    this.fixedCount = fixedCount;
                }
                return boundaries;
            }

