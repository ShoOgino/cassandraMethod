    /**
     * Force a flush on all dirty CFs represented in the oldest commitlog segment
     */
    private void flushOldestTables()
    {
        CommitLogSegment oldestSegment = activeSegments.peek();

        if (oldestSegment != null)
        {
            for (UUID dirtyCFId : oldestSegment.getDirtyCFIDs())
            {
                Pair<String,String> pair = Schema.instance.getCF(dirtyCFId);
                if (pair == null)
                {
                    // even though we remove the schema entry before a final flush when dropping a CF,
                    // it's still possible for a writer to race and finish his append after the flush.
                    logger.debug("Marking clean CF {} that doesn't exist anymore", dirtyCFId);
                    oldestSegment.markClean(dirtyCFId, oldestSegment.getContext());
                }
                else
                {
                    String keypace = pair.left;
                    final ColumnFamilyStore cfs = Table.open(keypace).getColumnFamilyStore(dirtyCFId);
                    // flush shouldn't run on the commitlog executor, since it acquires Table.switchLock,
                    // which may already be held by a thread waiting for the CL executor (via getContext),
                    // causing deadlock
                    Runnable runnable = new Runnable()
                    {
                        public void run()
                        {
                            cfs.forceFlush();
                        }
                    };
                    StorageService.optionalTasks.execute(runnable);
                }
            }
        }
    }

