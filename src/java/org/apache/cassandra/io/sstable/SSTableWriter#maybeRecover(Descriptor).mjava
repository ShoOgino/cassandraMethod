    /**
     * If either of the index or filter files are missing, rebuilds both.
     * TODO: Builds most of the in-memory state of the sstable, but doesn't actually open it.
     */
    private static void maybeRecover(Descriptor desc) throws IOException
    {
        logger.debug("In maybeRecover with Descriptor {}", desc);
        File ifile = new File(desc.filenameFor(SSTable.COMPONENT_INDEX));
        File ffile = new File(desc.filenameFor(SSTable.COMPONENT_FILTER));
        if (ifile.exists() && ffile.exists())
            // nothing to do
            return;

        ColumnFamilyStore cfs = Table.open(desc.ksname).getColumnFamilyStore(desc.cfname);

        // remove existing files
        ifile.delete();
        ffile.delete();

        // open the data file for input, and an IndexWriter for output
        BufferedRandomAccessFile dfile = new BufferedRandomAccessFile(desc.filenameFor(SSTable.COMPONENT_DATA), "r", 8 * 1024 * 1024);
        IndexWriter iwriter;
        long estimatedRows;
        try
        {            
            estimatedRows = estimateRows(desc, dfile);            
            iwriter = new IndexWriter(desc, StorageService.getPartitioner(), estimatedRows);
        }
        catch(IOException e)
        {
            dfile.close();
            throw e;
        }

        // build the index and filter
        long rows = 0;
        try
        {
            DecoratedKey key;
            long dataPosition = 0;
            while (dataPosition < dfile.length())
            {
                key = SSTableReader.decodeKey(StorageService.getPartitioner(), desc, FBUtilities.readShortByteArray(dfile));
                long dataSize = SSTableReader.readRowSize(dfile, desc);
                iwriter.afterAppend(key, dataPosition);
                dataPosition = dfile.getFilePointer() + dataSize;
                dfile.seek(dataPosition);
                rows++;
            }
        }
        finally
        {
            try
            {
                dfile.close();
                iwriter.close();
            }
            catch (IOException e)
            {
                throw new IOError(e);
            }
        }

        if (!cfs.getIndexedColumns().isEmpty())
        {
            Future future = CompactionManager.instance.submitIndexBuild(cfs, new KeyIterator(desc));
            try
            {
                future.get();
                for (byte[] column : cfs.getIndexedColumns())
                    cfs.getIndexedColumnFamilyStore(column).forceBlockingFlush();
            }
            catch (InterruptedException e)
            {
                throw new AssertionError(e);
            }
            catch (ExecutionException e)
            {
                throw new RuntimeException(e);
            }
        }

        logger.debug("estimated row count was %s of real count", ((double)estimatedRows) / rows);
    }

