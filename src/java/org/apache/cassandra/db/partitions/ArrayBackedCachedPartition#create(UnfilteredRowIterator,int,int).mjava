    /**
     * Creates an {@code ArrayBackedCachedPartition} holding all the data of the provided iterator.
     *
     * Warning: Note that this method does not close the provided iterator and it is
     * up to the caller to do so.
     *
     * @param iterator the iterator got gather in memory.
     * @param initialRowCapacity sizing hint (in rows) to use for the created partition. It should ideally
     * correspond or be a good estimation of the number or rows in {@code iterator}.
     * @param nowInSec the time of the creation in seconds. This is the time at which {@link #cachedLiveRows} applies.
     * @return the created partition.
     */
    public static ArrayBackedCachedPartition create(UnfilteredRowIterator iterator, int initialRowCapacity, int nowInSec)
    {
        ArrayBackedCachedPartition partition = new ArrayBackedCachedPartition(iterator.metadata(),
                                                                              iterator.partitionKey(),
                                                                              iterator.partitionLevelDeletion(),
                                                                              iterator.columns(),
                                                                              initialRowCapacity,
                                                                              iterator.isReverseOrder(),
                                                                              nowInSec);

        partition.staticRow = iterator.staticRow().takeAlias();

        Writer writer = partition.new Writer(nowInSec);
        RangeTombstoneCollector markerCollector = partition.new RangeTombstoneCollector(iterator.isReverseOrder());

        copyAll(iterator, writer, markerCollector, partition);

        return partition;
    }

