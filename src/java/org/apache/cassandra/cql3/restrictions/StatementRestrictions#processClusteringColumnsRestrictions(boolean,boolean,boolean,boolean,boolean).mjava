    /**
     * Processes the clustering column restrictions.
     *
     * @param hasQueriableIndex <code>true</code> if some of the queried data are indexed, <code>false</code> otherwise
     * @param selectsOnlyStaticColumns <code>true</code> if the selected or modified columns are all statics,
     * <code>false</code> otherwise.
     * @param selectsComplexColumn <code>true</code> if the query should return a collection column
     */
    private void processClusteringColumnsRestrictions(boolean hasQueriableIndex,
                                                      boolean selectsOnlyStaticColumns,
                                                      boolean selectsComplexColumn,
                                                      boolean forView,
                                                      boolean allowFiltering)
    {
        checkFalse(!type.allowClusteringColumnSlices() && clusteringColumnsRestrictions.hasSlice(),
                   "Slice restrictions are not supported on the clustering columns in %s statements", type);

        if (!type.allowClusteringColumnSlices()
               && (!cfm.isCompactTable() || (cfm.isCompactTable() && !hasClusteringColumnsRestriction())))
        {
            if (!selectsOnlyStaticColumns && hasUnrestrictedClusteringColumns())
                throw invalidRequest("Some clustering keys are missing: %s",
                                     Joiner.on(", ").join(getUnrestrictedClusteringColumns()));
        }
        else
        {
            checkFalse(clusteringColumnsRestrictions.hasIN() && selectsComplexColumn,
                       "Cannot restrict clustering columns by IN relations when a collection is selected by the query");
            checkFalse(clusteringColumnsRestrictions.hasContains() && !hasQueriableIndex && !allowFiltering,
                       "Cannot restrict clustering columns by a CONTAINS relation without a secondary index");


            if (hasClusteringColumnsRestriction())
            {
                List<ColumnDefinition> clusteringColumns = cfm.clusteringColumns();
                List<ColumnDefinition> restrictedColumns = new LinkedList<>(clusteringColumnsRestrictions.getColumnDefs());

                for (int i = 0, m = restrictedColumns.size(); i < m; i++)
                {
                    ColumnDefinition clusteringColumn = clusteringColumns.get(i);
                    ColumnDefinition restrictedColumn = restrictedColumns.get(i);

                    if (!clusteringColumn.equals(restrictedColumn) && !allowFiltering)
                    {
                        checkTrue(hasQueriableIndex || forView,
                                  "PRIMARY KEY column \"%s\" cannot be restricted as preceding column \"%s\" is not restricted",
                                  restrictedColumn.name,
                                  clusteringColumn.name);

                        usesSecondaryIndexing = true; // handle gaps and non-keyrange cases.
                        break;
                    }
                }
            }
        }

        if (clusteringColumnsRestrictions.hasContains())
            usesSecondaryIndexing = true;
    }

