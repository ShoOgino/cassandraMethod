    public DebuggableThreadPoolExecutor(int corePoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue, ThreadFactory threadFactory)
    {
        super(corePoolSize, corePoolSize, keepAliveTime, unit, workQueue, threadFactory);
        allowCoreThreadTimeOut(true);

        // block task submissions until queue has room.
        // this is fighting TPE's design a bit because TPE rejects if queue.offer reports a full queue.
        // we'll just override this with a handler that retries until it gets in.  ugly, but effective.
        // (there is an extensive analysis of the options here at
        //  http://today.java.net/pub/a/today/2008/10/23/creating-a-notifying-blocking-thread-pool-executor.html)
        this.setRejectedExecutionHandler(new RejectedExecutionHandler()
        {
            public void rejectedExecution(Runnable task, ThreadPoolExecutor executor)
            {
                ((DebuggableThreadPoolExecutor)executor).onInitialRejection(task);
                BlockingQueue<Runnable> queue = executor.getQueue();
                while (true)
                {
                    if (executor.isShutdown())
                    {
                        ((DebuggableThreadPoolExecutor)executor).onFinalRejection(task);
                        throw new RejectedExecutionException("ThreadPoolExecutor has shut down");
                    }
                    try
                    {
                        if (queue.offer(task, 1000, TimeUnit.MILLISECONDS))
                        {
                            ((DebuggableThreadPoolExecutor)executor).onFinalAccept(task);
                            break;
                        }
                    }
                    catch (InterruptedException e)
                    {
                        throw new AssertionError(e);
                    }
                }
            }
        });
    }

