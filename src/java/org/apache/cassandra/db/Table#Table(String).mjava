    private Table(String table)
    {
        name = table;
        indexLocks = new Object[DatabaseDescriptor.getConcurrentWriters() * 8];
        for (int i = 0; i < indexLocks.length; i++)
            indexLocks[i] = new Object();
        // create data directories.
        for (String dataDir : DatabaseDescriptor.getAllDataFileLocations())
        {
            try
            {
                String keyspaceDir = dataDir + File.separator + table;
                FileUtils.createDirectory(keyspaceDir);
    
                // remove the deprecated streaming directory.
                File streamingDir = new File(keyspaceDir, "stream");
                if (streamingDir.exists())
                    FileUtils.deleteRecursive(streamingDir);
            }
            catch (IOException ex)
            {
                throw new IOError(ex);
            }
        }

        MBeanServer mbs = ManagementFactory.getPlatformMBeanServer();
        for (CFMetaData cfm : new ArrayList<CFMetaData>(DatabaseDescriptor.getTableDefinition(table).cfMetaData().values()))
        {
            ColumnFamilyStore cfs = ColumnFamilyStore.createColumnFamilyStore(table, cfm.cfName);
            columnFamilyStores.put(cfm.cfId, cfs);
            try
            {
                ObjectName mbeanName = new ObjectName(cfs.getMBeanName());
                if (mbs.isRegistered(mbeanName))
                    mbs.unregisterMBean(mbeanName);
                mbs.registerMBean(cfs, mbeanName);
            }
            catch (Exception e)
            {
                throw new RuntimeException(e);
            }
        }

        // check 10x as often as the lifetime, so we can exceed lifetime by 10% at most
        int checkMs = DatabaseDescriptor.getMemtableLifetimeMS() / 10;
        flushTask = new TimerTask()
        {
            public void run()
            {
                for (ColumnFamilyStore cfs : columnFamilyStores.values())
                {
                    cfs.forceFlushIfExpired();
                }
            }
        };
        flushTimer.schedule(flushTask, checkMs, checkMs);
    }

