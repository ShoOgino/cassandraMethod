    /**
     * Create new repair session.
     *
     * @param parentRepairSession the parent sessions id
     * @param id this sessions id
     * @param ranges ranges to repair
     * @param keyspace name of keyspace
     * @param parallelismDegree specifies the degree of parallelism when calculating the merkle trees
     * @param endpoints the data centers that should be part of the repair; null for all DCs
     * @param pullRepair true if the repair should be one way (from remote host to this host and only applicable between two hosts--see RepairOption)
     * @param force true if the repair should ignore dead endpoints (instead of failing)
     * @param cfnames names of columnfamilies
     */
    public RepairSession(UUID parentRepairSession,
                         UUID id,
                         Collection<Range<Token>> ranges,
                         String keyspace,
                         RepairParallelism parallelismDegree,
                         Set<InetAddress> endpoints,
                         boolean isConsistent,
                         boolean pullRepair,
                         boolean force,
                         PreviewKind previewKind,
                         String... cfnames)
    {
        assert cfnames.length > 0 : "Repairing no column families seems pointless, doesn't it";

        this.parentRepairSession = parentRepairSession;
        this.id = id;
        this.parallelismDegree = parallelismDegree;
        this.keyspace = keyspace;
        this.cfnames = cfnames;
        this.ranges = ranges;

        //If force then filter out dead endpoints
        boolean forceSkippedReplicas = false;
        if (force)
        {
            logger.debug("force flag set, removing dead endpoints");
            final Set<InetAddress> removeCandidates = new HashSet<>();
            for (final InetAddress endpoint : endpoints)
            {
                if (!FailureDetector.instance.isAlive(endpoint))
                {
                    logger.info("Removing a dead node from Repair due to -force " + endpoint);
                    removeCandidates.add(endpoint);
                }
            }
            if (!removeCandidates.isEmpty())
            {
                // we shouldn't be promoting sstables to repaired if any replicas are excluded from the repair
                forceSkippedReplicas = true;
                endpoints = new HashSet<>(endpoints);
                endpoints.removeAll(removeCandidates);
            }
        }

        this.endpoints = endpoints;
        this.isConsistent = isConsistent;
        this.previewKind = previewKind;
        this.pullRepair = pullRepair;
        this.skippedReplicas = forceSkippedReplicas;
    }

