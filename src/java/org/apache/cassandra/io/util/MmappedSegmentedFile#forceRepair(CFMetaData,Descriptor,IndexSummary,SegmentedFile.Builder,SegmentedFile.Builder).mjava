    // if one of the index/data files have boundaries larger than we can mmap, and they were written by a version that did not guarantee correct boundaries were saved,
    // rebuild the boundaries and save them again
    private static void forceRepair(CFMetaData metadata, Descriptor descriptor, IndexSummary indexSummary, SegmentedFile.Builder ibuilder, SegmentedFile.Builder dbuilder)
    {
        if (ibuilder instanceof Builder)
            ((Builder) ibuilder).boundaries.clear();
        if (dbuilder instanceof Builder)
            ((Builder) dbuilder).boundaries.clear();

        try (RandomAccessFile raf = new RandomAccessFile(descriptor.filenameFor(Component.PRIMARY_INDEX), "r");)
        {
            long iprev = 0, dprev = 0;
            for (int i = 0; i < indexSummary.size(); i++)
            {
                // first read the position in the summary, and read the corresponding position in the data file
                long icur = indexSummary.getPosition(i);
                raf.seek(icur);
                ByteBufferUtil.readWithShortLength(raf);
                RowIndexEntry rie = metadata.comparator.rowIndexEntrySerializer().deserialize(raf, descriptor.version);
                long dcur = rie.position;

                // if these positions are small enough to map out a segment from the prior version (i.e. less than 2Gb),
                // just add these as a boundary and proceed to the next index summary record; most scenarios will be
                // served by this, keeping the cost of rebuild to a minimum.

                if (Math.max(icur - iprev , dcur - dprev) > MAX_SEGMENT_SIZE)
                {
                    // otherwise, loop over its index block, providing each RIE as a potential boundary for both files
                    raf.seek(iprev);
                    while (raf.getFilePointer() < icur)
                    {
                        // add the position of this record in the index file as an index file boundary
                        ibuilder.addPotentialBoundary(raf.getFilePointer());
                        // then read the RIE, and add its data file position as a boundary for the data file
                        ByteBufferUtil.readWithShortLength(raf);
                        rie = metadata.comparator.rowIndexEntrySerializer().deserialize(raf, descriptor.version);
                        dbuilder.addPotentialBoundary(rie.position);
                    }
                }

                ibuilder.addPotentialBoundary(icur);
                dbuilder.addPotentialBoundary(dcur);

                iprev = icur;
                dprev = dcur;
            }
        }
        catch (IOException e)
        {
            logger.error("Failed to recalculate boundaries for {}; mmap access may degrade to buffered for this file", descriptor);
        }
    }

