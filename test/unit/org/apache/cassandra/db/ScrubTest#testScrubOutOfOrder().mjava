    @Test
    public void testScrubOutOfOrder() throws Exception
    {
        CompactionManager.instance.disableAutoCompaction();
        Keyspace keyspace = Keyspace.open(KEYSPACE);
        String columnFamily = CF3;
        ColumnFamilyStore cfs = keyspace.getColumnFamilyStore(columnFamily);
        cfs.clearUnsafe();

        /*
         * Code used to generate an outOfOrder sstable. The test for out-of-order key in BigTableWriter must also be commented out.
         * The test also assumes an ordered partitioner.
        List<String> keys = Arrays.asList("t", "a", "b", "z", "c", "y", "d");
        String filename = cfs.getTempSSTablePath(new File(System.getProperty("corrupt-sstable-root")));
        SSTableWriter writer = SSTableWriter.create(cfs.metadata,
                                                    Descriptor.fromFilename(filename),
                                                    keys.size(),
                                                    0L,
                                                    0,
                                                    DatabaseDescriptor.getPartitioner(),
                                                    SerializationHeader.make(cfs.metadata, Collections.emptyList()));

        for (String k : keys)
        {
            RowUpdateBuilder builder = new RowUpdateBuilder(cfs.metadata, 0L, Util.dk(k));
            PartitionUpdate update = builder.clustering("someName")
                                            .add("val", "someValue")
                                            .buildUpdate();

            writer.append(update.unfilteredIterator());
        }
        writer.finish(false);
         */

        String root = System.getProperty("corrupt-sstable-root");
        assert root != null;

        File rootDir = new File(root);
        assert rootDir.isDirectory();
        Descriptor desc = new Descriptor("la", rootDir, KEYSPACE, columnFamily, 1, Descriptor.Type.FINAL, SSTableFormat.Type.BIG);
        CFMetaData metadata = Schema.instance.getCFMetaData(desc.ksname, desc.cfname);

        try
        {
            SSTableReader.open(desc, metadata);
            fail("SSTR validation should have caught the out-of-order rows");
        }
        catch (IllegalStateException ise) { /* this is expected */ }

        // open without validation for scrubbing
        Set<Component> components = new HashSet<>();
        //components.add(Component.COMPRESSION_INFO);
        components.add(Component.DATA);
        components.add(Component.PRIMARY_INDEX);
        components.add(Component.FILTER);
        components.add(Component.STATS);
        components.add(Component.SUMMARY);
        components.add(Component.TOC);

        SSTableReader sstable = SSTableReader.openNoValidation(desc, components, cfs);
        if (sstable.last.compareTo(sstable.first) < 0)
            sstable.last = sstable.first;

        try (LifecycleTransaction txn = LifecycleTransaction.offline(OperationType.SCRUB, sstable);
             Scrubber scrubber = new Scrubber(cfs, txn, false, true, true);)
        {
            scrubber.scrub();
        }
        cfs.loadNewSSTables();
        assertOrderedAll(cfs, 7);
        sstable.selfRef().release();
    }

