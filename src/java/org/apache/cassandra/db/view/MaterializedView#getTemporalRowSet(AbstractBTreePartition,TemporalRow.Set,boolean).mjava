    /**
     * Splits the partition update up and adds the existing state to each row.
     * This data can be reused for multiple MV updates on the same base table
     *
     * @param partition the mutation
     * @param isBuilding If the view is currently being built, we do not query the values which are already stored,
     *                   since all of the update will already be present in the base table.
     * @return The set of temoral rows contained in this update
     */
    public TemporalRow.Set getTemporalRowSet(AbstractBTreePartition partition, TemporalRow.Set existing, boolean isBuilding)
    {
        if (!updateAffectsView(partition))
            return null;

        Set<ColumnIdentifier> columns = new HashSet<>(this.columns.primaryKeyDefs.size());
        for (ColumnDefinition def : this.columns.primaryKeyDefs)
            columns.add(def.name);

        TemporalRow.Set rowSet = null;
        if (existing == null)
        {
            rowSet = separateRows(partition, columns);

            // If we are building the view, we do not want to add old values; they will always be the same
            if (!isBuilding)
                readLocalRows(rowSet);
        }
        else
        {
            rowSet = existing.withNewViewPrimaryKey(columns);
        }

        return rowSet;
    }

