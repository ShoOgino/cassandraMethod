        @Override
        protected void decode(ChannelHandlerContext ctx, ByteBuf buffer, List<Object> results)
        throws Exception
        {
            if (discardingTooLongFrame)
            {
                bytesToDiscard = discard(buffer, bytesToDiscard);
                // If we have discarded everything, throw the exception
                if (bytesToDiscard <= 0)
                    fail();
                return;
            }

            // Wait until we have read at least the short header
            if (buffer.readableBytes() < Header.LEGACY_LENGTH)
                return;

            int idx = buffer.readerIndex();

            int firstByte = buffer.getByte(idx++);
            Message.Direction direction = Message.Direction.extractFromVersion(firstByte);
            int version = firstByte & 0x7F;

            if (version > Server.CURRENT_VERSION)
                throw new ProtocolException("Invalid or unsupported protocol version: " + version);

            // Wait until we have the complete V3+ header
            if (version >= Server.VERSION_3 && buffer.readableBytes() < Header.MODERN_LENGTH)
                return;

            int flags = buffer.getByte(idx++);

            int streamId, headerLength;
            if (version >= Server.VERSION_3)
            {
                streamId = buffer.getShort(idx);
                idx += 2;
                headerLength = Header.MODERN_LENGTH;
            }
            else
            {
                streamId = buffer.getByte(idx);
                idx++;
                headerLength = Header.LEGACY_LENGTH;
            }

            // This throws a protocol exceptions if the opcode is unknown
            Message.Type type = Message.Type.fromOpcode(buffer.getByte(idx++), direction);

            long bodyLength = buffer.getUnsignedInt(idx);
            idx += Header.BODY_LENGTH_SIZE;

            if (bodyLength < 0)
            {
                buffer.skipBytes(headerLength);
                throw new ProtocolException("Invalid frame body length: " + bodyLength);
            }

            long frameLength = bodyLength + headerLength;
            if (frameLength > MAX_FRAME_LENGTH)
            {
                // Enter the discard mode and discard everything received so far.
                discardingTooLongFrame = true;
                tooLongStreamId = streamId;
                tooLongFrameLength = frameLength;
                bytesToDiscard = discard(buffer, frameLength);
                if (bytesToDiscard <= 0)
                    fail();
                return;
            }

            if (buffer.readableBytes() < frameLength)
                return;

            // extract body
            ByteBuf body = CBUtil.allocator.buffer((int) bodyLength).writeBytes(buffer.duplicate().slice(idx, (int) bodyLength));
            idx += bodyLength;
            buffer.readerIndex(idx);

            Connection connection = ctx.channel().attr(Connection.attributeKey).get();
            if (connection == null)
            {
                // First message seen on this channel, attach the connection object
                connection = factory.newConnection(ctx.channel(), version);
                ctx.channel().attr(Connection.attributeKey).set(connection);
            }
            else if (connection.getVersion() != version)
            {
                throw new ProtocolException(String.format("Invalid message version. Got %d but previous messages on this connection had version %d", version, connection.getVersion()));
            }

            results.add(new Frame(new Header(version, flags, streamId, type), body));
        }

