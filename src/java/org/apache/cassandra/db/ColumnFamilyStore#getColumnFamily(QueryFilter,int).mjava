    /**
     * get a list of columns starting from a given column, in a specified order.
     * only the latest version of a column is returned.
     * @return null if there is no data and no tombstones; otherwise a ColumnFamily
     */
    public ColumnFamily getColumnFamily(QueryFilter filter, int gcBefore)
    {
        assert columnFamily_.equals(filter.getColumnFamilyName());

        long start = System.nanoTime();
        try
        {
            if (ssTables_.getRowCache().getCapacity() == 0)
                return removeDeleted(getTopLevelColumns(filter, gcBefore), gcBefore);

            ColumnFamily cached = cacheRow(filter.key);
            if (cached == null)
                return null;
            IColumnIterator ci = filter.getMemtableColumnIterator(cached, null, getComparator());
            ColumnFamily returnCF = ci.getColumnFamily().cloneMeShallow();
            filter.collectCollatedColumns(returnCF, ci, gcBefore);
            // TODO this is necessary because when we collate supercolumns together, we don't check
            // their subcolumns for relevance, so we need to do a second prune post facto here.
            return removeDeleted(returnCF, gcBefore);
        }
        catch (IOException e)
        {
            throw new IOError(e);
        }
        finally
        {
            readStats_.addNano(System.nanoTime() - start);
        }
    }

