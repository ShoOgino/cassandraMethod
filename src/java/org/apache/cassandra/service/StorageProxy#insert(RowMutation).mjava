    /**
     * Use this method to have this RowMutation applied
     * across all replicas. This method will take care
     * of the possibility of a replica being down and hint
     * the data across to some other replica.
     *
     * This is the ZERO consistency level. We do not wait for replies.
     *
     * @param rm the mutation to be applied across the replicas
    */
    public static void insert(final RowMutation rm)
    {
        long startTime = System.currentTimeMillis();
        try
        {
            List<InetAddress> naturalEndpoints = StorageService.instance().getNaturalEndpoints(rm.key());
            Map<InetAddress, InetAddress> endpointMap = StorageService.instance().getHintedEndpointMap(rm.key(), naturalEndpoints);
            Message unhintedMessage = null; // lazy initialize for non-local, unhinted writes

            // 3 cases:
            // 1. local, unhinted write: run directly on write stage
            // 2. non-local, unhinted write: send row mutation message
            // 3. hinted write: add hint header, and send message
            for (Map.Entry<InetAddress, InetAddress> entry : endpointMap.entrySet())
            {
                InetAddress target = entry.getKey();
                InetAddress hintedTarget = entry.getValue();
                if (target.equals(hintedTarget))
                {
                    if (target.equals(FBUtilities.getLocalAddress()))
                    {
                        if (logger.isDebugEnabled())
                            logger.debug("insert writing local key " + rm.key());
                        Runnable runnable = new Runnable()
                        {
                            public void run()
                            {
                                try
                                {
                                    rm.apply();
                                }
                                catch (IOException e)
                                {
                                    throw new IOError(e);
                                }
                            }
                        };
                        StageManager.getStage(StageManager.mutationStage_).execute(runnable);
                    }
                    else
                    {
                        if (unhintedMessage == null)
                            unhintedMessage = rm.makeRowMutationMessage();
                        if (logger.isDebugEnabled())
                            logger.debug("insert writing key " + rm.key() + " to " + unhintedMessage.getMessageId() + "@" + target);
                        MessagingService.instance().sendOneWay(unhintedMessage, target);
                    }
                }
                else
                {
                    Message hintedMessage = rm.makeRowMutationMessage();
                    hintedMessage.addHeader(RowMutation.HINT, target.getAddress());
                    if (logger.isDebugEnabled())
                        logger.debug("insert writing key " + rm.key() + " to " + unhintedMessage.getMessageId() + "@" + hintedTarget + " for " + target);
                    MessagingService.instance().sendOneWay(hintedMessage, hintedTarget);
                }
            }
        }
        catch (IOException e)
        {
            throw new RuntimeException("error inserting key " + rm.key(), e);
        }
        finally
        {
            writeStats.add(System.currentTimeMillis() - startTime);
        }
    }

