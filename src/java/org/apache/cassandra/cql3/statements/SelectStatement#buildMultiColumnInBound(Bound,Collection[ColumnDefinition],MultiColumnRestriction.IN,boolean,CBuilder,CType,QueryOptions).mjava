    private static List<Composite> buildMultiColumnInBound(Bound bound,
                                                           Collection<ColumnDefinition> defs,
                                                           MultiColumnRestriction.IN restriction,
                                                           boolean isReversed,
                                                           CBuilder builder,
                                                           CType type,
                                                           QueryOptions options) throws InvalidRequestException
    {
        List<List<ByteBuffer>> splitInValues = restriction.splitValues(options);

        // The IN query might not have listed the values in comparator order, so we need to re-sort
        // the bounds lists to make sure the slices works correctly (also, to avoid duplicates).
        TreeSet<Composite> inValues = new TreeSet<>(isReversed ? type.reverseComparator() : type);
        Iterator<ColumnDefinition> iter = defs.iterator();
        for (List<ByteBuffer> components : splitInValues)
        {
            Composite prefix = builder.buildWith(components);
            Bound b = isReversed == isReversedType(iter.next()) ? bound : Bound.reverse(bound);
            inValues.add(b == Bound.END && builder.remainingCount() - components.size() > 0
                         ? prefix.end()
                         : prefix);
        }
        return new ArrayList<>(inValues);
    }

