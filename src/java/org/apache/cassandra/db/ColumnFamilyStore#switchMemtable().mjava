    /*
     * switchMemtable puts Memtable.getSortedContents on the writer executor.  When the write is complete,
     * we turn the writer into an SSTableReader and add it to ssTables where it is available for reads.
     * This method does not block except for synchronizing on Tracker, but the Future it returns will
     * not complete until the Memtable (and all prior Memtables) have been successfully flushed, and the CL
     * marked clean up to the position owned by the Memtable.
     */
    public ListenableFuture<ReplayPosition> switchMemtable()
    {
        synchronized (data)
        {
            if (previousFlushFailure != null)
                throw new IllegalStateException("A flush previously failed with the error below. To prevent data loss, "
                                              + "no flushes can be carried out until the node is restarted.",
                                                previousFlushFailure);
            logFlush();
            Flush flush = new Flush(false);
            ListenableFutureTask<?> flushTask = ListenableFutureTask.create(flush, null);
            flushExecutor.submit(flushTask);
            ListenableFutureTask<ReplayPosition> task = ListenableFutureTask.create(flush.postFlush);
            postFlushExecutor.submit(task);

            @SuppressWarnings("unchecked")
            ListenableFuture<ReplayPosition> future = 
                    // If either of the two tasks errors out, resulting future must also error out.
                    // Combine the two futures and only return post-flush result after both have completed.
                    Futures.transform(Futures.allAsList(flushTask, task),
                                      new Function<List<Object>, ReplayPosition>()
                                      {
                                          public ReplayPosition apply(List<Object> input)
                                          {
                                              return (ReplayPosition) input.get(1);
                                          }
                                      });
            return future;
        }
    }

