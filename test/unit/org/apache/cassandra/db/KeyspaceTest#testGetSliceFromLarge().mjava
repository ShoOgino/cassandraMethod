    @Test
    public void testGetSliceFromLarge() throws Throwable
    {
        // tests slicing against 1000 columns in an sstable
        Keyspace keyspace = Keyspace.open(KEYSPACE1);
        ColumnFamilyStore cfStore = keyspace.getColumnFamilyStore("Standard1");
        DecoratedKey key = Util.dk("row3");
        ColumnFamily cf = ArrayBackedSortedColumns.factory.create(KEYSPACE1, "Standard1");
        for (int i = 1000; i < 2000; i++)
            cf.addColumn(column("col" + i, ("v" + i), 1L));
        Mutation rm = new Mutation(KEYSPACE1, key.getKey(), cf);
        rm.apply();
        cfStore.forceBlockingFlush();

        validateSliceLarge(cfStore);

        // compact so we have a big row with more than the minimum index count
        if (cfStore.getSSTables().size() > 1)
        {
            CompactionManager.instance.performMaximal(cfStore);
        }
        // verify that we do indeed have multiple index entries
        SSTableReader sstable = cfStore.getSSTables().iterator().next();
        RowIndexEntry indexEntry = sstable.getPosition(key, SSTableReader.Operator.EQ);
        assert indexEntry.columnsIndex().size() > 2;

        validateSliceLarge(cfStore);
    }

