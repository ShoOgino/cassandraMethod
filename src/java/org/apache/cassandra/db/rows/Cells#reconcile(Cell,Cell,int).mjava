    /**
     * Reconciles/merge two cells.
     * <p>
     * Note that this method assumes that the provided cells can meaningfully
     * be reconciled together, that is that cell are for the same row and same
     * column (and same cell path if the column is complex).
     * <p>
     * This method is commutative over it's cells arguments: {@code reconcile(a, b, n) == reconcile(b, a, n)}.
     *
     * @param c1 the first cell participating in the reconciliation.
     * @param c2 the second cell participating in the reconciliation.
     * @param nowInSec the current time in seconds (which plays a role during reconciliation
     * because deleted cells always have precedence on timestamp equality and deciding if a
     * cell is a live or not depends on the current time due to expiring cells).
     *
     * @return a cell corresponding to the reconciliation of {@code c1} and {@code c2}.
     * For non-counter cells, this will always be either {@code c1} or {@code c2}, but for
     * counter cells this can be a newly allocated cell.
     */
    public static Cell reconcile(Cell c1, Cell c2, int nowInSec)
    {
        if (c1 == null)
            return c2 == null ? null : c2;
        if (c2 == null)
            return c1;

        if (c1.isCounterCell() || c2.isCounterCell())
        {
            Conflicts.Resolution res = Conflicts.resolveCounter(c1.livenessInfo().timestamp(),
                                                                c1.isLive(nowInSec),
                                                                c1.value(),
                                                                c2.livenessInfo().timestamp(),
                                                                c2.isLive(nowInSec),
                                                                c2.value());

            switch (res)
            {
                case LEFT_WINS: return c1;
                case RIGHT_WINS: return c2;
                default:
                    ByteBuffer merged = Conflicts.mergeCounterValues(c1.value(), c2.value());
                    LivenessInfo mergedInfo = c1.livenessInfo().mergeWith(c2.livenessInfo());

                    // We save allocating a new cell object if it turns out that one cell was
                    // a complete superset of the other
                    if (merged == c1.value() && mergedInfo == c1.livenessInfo())
                        return c1;
                    else if (merged == c2.value() && mergedInfo == c2.livenessInfo())
                        return c2;
                    else // merge clocks and timestamps.
                        return create(c1.column(), true, merged, mergedInfo, null);
            }
        }

        Conflicts.Resolution res = Conflicts.resolveRegular(c1.livenessInfo().timestamp(),
                                                            c1.isLive(nowInSec),
                                                            c1.livenessInfo().localDeletionTime(),
                                                            c1.value(),
                                                            c2.livenessInfo().timestamp(),
                                                            c2.isLive(nowInSec),
                                                            c2.livenessInfo().localDeletionTime(),
                                                            c2.value());
        assert res != Conflicts.Resolution.MERGE;
        return res == Conflicts.Resolution.LEFT_WINS ? c1 : c2;
    }

