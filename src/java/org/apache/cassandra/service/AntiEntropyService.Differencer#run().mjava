        /**
         * Compares our trees, and triggers repairs for any ranges that mismatch.
         */
        public void run()
        {
            InetAddress local = FBUtilities.getLocalAddress();
            StorageService ss = StorageService.instance;

            // restore partitioners (in case we were serialized)
            if (ltree.partitioner() == null)
                ltree.partitioner(StorageService.getPartitioner());
            if (rtree.partitioner() == null)
                rtree.partitioner(StorageService.getPartitioner());

            // determine the ranges where responsibility overlaps
            Set<Range> interesting = new HashSet(ss.getRangesForEndpoint(request.cf.left, local));
            interesting.retainAll(ss.getRangesForEndpoint(request.cf.left, request.endpoint));

            // compare trees, and collect interesting differences
            for (MerkleTree.TreeRange diff : MerkleTree.difference(ltree, rtree))
                for (Range localrange: interesting)
                    differences.addAll(diff.intersectionWith(localrange));
            
            // choose a repair method based on the significance of the difference
            String format = "Endpoints " + local + " and " + request.endpoint + " %s for " + request.cf;
            if (differences.isEmpty())
            {
                logger.info(String.format(format, "are consistent"));
                AntiEntropyService.instance.completedRequest(request);
                return;
            }

            // non-0 difference: perform streaming repair
            logger.info(String.format(format, "have " + differences.size() + " range(s) out of sync"));
            try
            {
                performStreamingRepair();
            }
            catch(IOException e)
            {
                throw new RuntimeException(e);
            }
        }

