    public List<Row> scan(IndexClause indexClause, IFilter dataFilter)
    {
        // TODO: allow merge join instead of just one index + loop
        IndexExpression first = highestSelectivityPredicate(indexClause);
        ColumnFamilyStore indexCFS = getIndexedColumnFamilyStore(first.column_name);
        assert indexCFS != null;
        DecoratedKey indexKey = indexCFS.partitioner_.decorateKey(first.value);
        QueryFilter indexFilter = QueryFilter.getSliceFilter(indexKey,
                                                             new QueryPath(indexCFS.getColumnFamilyName()),
                                                             ArrayUtils.EMPTY_BYTE_ARRAY,
                                                             ArrayUtils.EMPTY_BYTE_ARRAY,
                                                             null,
                                                             false,
                                                             indexClause.count);

        List<Row> rows = new ArrayList<Row>();
        ColumnFamily indexRow = indexCFS.getColumnFamily(indexFilter);
        if (indexRow == null)
            return rows;

        for (byte[] dataKey : indexRow.getColumnNames())
        {
            DecoratedKey dk = partitioner_.decorateKey(dataKey);
            ColumnFamily data = getColumnFamily(new QueryFilter(dk, new QueryPath(columnFamily_), dataFilter));
            boolean accepted = true;
            for (IndexExpression expression : indexClause.expressions)
            {
                // (we can skip "first" since we already know it's satisfied)
                if (expression != first && !satisfies(data, expression))
                {
                    accepted = false;
                    break;
                }
            }
            if (accepted)
                rows.add(new Row(dk, data));
        }

        return rows;
    }

