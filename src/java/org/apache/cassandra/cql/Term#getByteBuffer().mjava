    /**
     * Returns the typed value, serialized to a ByteBuffer.
     * 
     * @return a ByteBuffer of the value.
     * @throws InvalidRequestException if unable to coerce the string to its type.
     */
    public ByteBuffer getByteBuffer() throws InvalidRequestException
    {
        switch (type)
        {
            case STRING:
                return ByteBuffer.wrap(text.getBytes());
            case LONG:
                try
                {
                    return ByteBufferUtil.bytes(Long.parseLong(text));
                }
                catch (NumberFormatException e)
                {
                    throw new InvalidRequestException(text + " is not valid for type long");
                }
            case INTEGER: 
                try
                {
                    return ByteBufferUtil.bytes(Integer.parseInt(text));
                }
                catch (NumberFormatException e)
                {
                    throw new InvalidRequestException(text + " is not valid for type int");
                }
            case UNICODE:
                try
                {
                    return ByteBuffer.wrap(text.getBytes("UTF-8"));
                }
                catch (UnsupportedEncodingException e)
                {
                   throw new RuntimeException(e);
                }
            case UUID:
                try
                {
                    return LexicalUUIDType.instance.fromString(text);
                }
                catch (IllegalArgumentException e)
                {
                    throw new InvalidRequestException(text + " is not valid for type uuid");
                }
            case TIMEUUID:
                if (text.equals("") || text.toLowerCase().equals("now"))
                {
                    return ByteBuffer.wrap(UUIDGen.decompose(UUIDGen.makeType1UUIDFromHost(FBUtilities.getLocalAddress())));
                }
                
                // Milliseconds since epoch?
                if (text.matches("^\\d+$"))
                {
                    try
                    {
                        return ByteBuffer.wrap(UUIDGen.getTimeUUIDBytes(Long.parseLong(text)));
                    }
                    catch (NumberFormatException e)
                    {
                        throw new InvalidRequestException(text + " is not valid for type timeuuid");
                    }
                }
                
                try
                {
                    long timestamp = DateUtils.parseDate(text, iso8601Patterns).getTime();
                    return ByteBuffer.wrap(UUIDGen.getTimeUUIDBytes(timestamp));
                }
                catch (ParseException e1)
                {
                    // Ignore failures; we'll move onto the Next Thing.
                }
                
                // Last chance, a UUID string (i.e. f79326be-2d7b-11e0-b074-0026c650d722)
                try
                {
                    return TimeUUIDType.instance.fromString(text);
                }
                catch (IllegalArgumentException e)
                {
                    throw new InvalidRequestException(text + " is not valid for type timeuuid");
                }
        }
        
        // FIXME: handle scenario that should never happen
        return null;
    }

