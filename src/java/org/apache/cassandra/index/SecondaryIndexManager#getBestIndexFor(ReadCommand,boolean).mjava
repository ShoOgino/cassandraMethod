    /**
     * Called at query time to find the most selective of the registered index implementation
     * (i.e. the one likely to return the fewest results) from those registered.
     * Implementation specific validation of the target expression by the most selective
     * index should be performed in the searcherFor method to ensure that we pick the right
     * index regardless of the validity of the expression.
     *
     * This method is called at various points during the lifecycle of a ReadCommand (to obtain a Searcher,
     * get the index's underlying CFS for ReadOrderGroup, or an estimate of the result size from an average index
     * query).
     *
     * Ideally, we would do this relatively expensive operation only once, and attach the index to the
     * ReadCommand for future reference. This requires the index be passed onto additional commands generated
     * to process subranges etc.
     *
     * @param command ReadCommand to be executed
     * @return an Index instance, ready to use during execution of the command, or null if none
     * of the registered indexes can support the command.
     */
    public Index getBestIndexFor(ReadCommand command, boolean includeInTrace)
    {
        if (indexes.isEmpty() || command.rowFilter().isEmpty())
            return null;

        Set<Index> searchableIndexes = new HashSet<>();
        for (RowFilter.Expression expression : command.rowFilter())
        {
            indexes.values().stream()
                            .filter(index -> index.supportsExpression(expression.column(), expression.operator()))
                            .forEach(searchableIndexes::add);
        }

        if (searchableIndexes.isEmpty())
        {
            logger.debug("No applicable indexes found");
            if (includeInTrace)
                Tracing.trace("No applicable indexes found");
            return null;
        }

        Index selected = searchableIndexes.stream()
                                          .max((a, b) -> Longs.compare(a.getEstimatedResultRows(),
                                                                       b.getEstimatedResultRows()))
                                          .orElseThrow(() -> new AssertionError("Could not select most selective index"));

        // pay for an additional threadlocal get() rather than build the strings unnecessarily
        if (includeInTrace && Tracing.isTracing())
        {
            Tracing.trace("Index mean cardinalities are {}. Scanning with {}.",
                          searchableIndexes.stream().map(i -> i.getIndexName() + ':' + i.getEstimatedResultRows())
                                           .collect(Collectors.joining(",")),
                          selected.getIndexName());
        }
        return selected;
    }

