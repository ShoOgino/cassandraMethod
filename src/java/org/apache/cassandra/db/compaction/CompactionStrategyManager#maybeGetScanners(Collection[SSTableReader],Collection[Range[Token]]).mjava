    /**
     * Create ISSTableScanners from the given sstables
     *
     * Delegates the call to the compaction strategies to allow LCS to create a scanner
     * @param sstables
     * @param ranges
     * @return
     */
    @SuppressWarnings("resource")
    public AbstractCompactionStrategy.ScannerList maybeGetScanners(Collection<SSTableReader> sstables,  Collection<Range<Token>> ranges)
    {
        maybeReloadDiskBoundaries();
        readLock.lock();
        List<ISSTableScanner> scanners = new ArrayList<>(sstables.size());
        try
        {
            assert repaired.size() == unrepaired.size();
            assert repaired.size() == pendingRepairs.size();

            int numRepaired = repaired.size();
            List<Set<SSTableReader>> pendingSSTables = new ArrayList<>(numRepaired);
            List<Set<SSTableReader>> repairedSSTables = new ArrayList<>(numRepaired);
            List<Set<SSTableReader>> unrepairedSSTables = new ArrayList<>(numRepaired);

            for (int i = 0; i < numRepaired; i++)
            {
                pendingSSTables.add(new HashSet<>());
                repairedSSTables.add(new HashSet<>());
                unrepairedSSTables.add(new HashSet<>());
            }

            for (SSTableReader sstable : sstables)
            {
                int idx = compactionStrategyIndexFor(sstable);
                if (sstable.isPendingRepair())
                    pendingSSTables.get(idx).add(sstable);
                else if (sstable.isRepaired())
                    repairedSSTables.get(idx).add(sstable);
                else
                    unrepairedSSTables.get(idx).add(sstable);
            }

            for (int i = 0; i < pendingSSTables.size(); i++)
            {
                if (!pendingSSTables.get(i).isEmpty())
                    scanners.addAll(pendingRepairs.get(i).getScanners(pendingSSTables.get(i), ranges));
            }
            for (int i = 0; i < repairedSSTables.size(); i++)
            {
                if (!repairedSSTables.get(i).isEmpty())
                    scanners.addAll(repaired.get(i).getScanners(repairedSSTables.get(i), ranges).scanners);
            }
            for (int i = 0; i < unrepairedSSTables.size(); i++)
            {
                if (!unrepairedSSTables.get(i).isEmpty())
                    scanners.addAll(unrepaired.get(i).getScanners(unrepairedSSTables.get(i), ranges).scanners);
            }
        }
        catch (PendingRepairManager.IllegalSSTableArgumentException e)
        {
            ISSTableScanner.closeAllAndPropagate(scanners, new ConcurrentModificationException(e));
        }
        finally
        {
            readLock.unlock();
        }
        return new AbstractCompactionStrategy.ScannerList(scanners);
    }

