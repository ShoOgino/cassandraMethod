    @Test
    public void testIndexDeletions() throws IOException
    {
        ColumnFamilyStore cfs = Keyspace.open(KEYSPACE3).getColumnFamilyStore(CF_INDEX1);
        Mutation rm;

        rm = new Mutation(KEYSPACE3, ByteBufferUtil.bytes("k1"));
        rm.add(CF_INDEX1, cellname("birthdate"), ByteBufferUtil.bytes(1L), 0);
        rm.applyUnsafe();

        IndexExpression expr = new IndexExpression(ByteBufferUtil.bytes("birthdate"), IndexExpression.Operator.EQ, ByteBufferUtil.bytes(1L));
        List<IndexExpression> clause = Arrays.asList(expr);
        IDiskAtomFilter filter = new IdentityQueryFilter();
        Range<RowPosition> range = Util.range("", "");
        List<Row> rows = cfs.search(range, clause, filter, 100);
        assert rows.size() == 1 : StringUtils.join(rows, ",");
        String key = ByteBufferUtil.string(rows.get(0).key.getKey());
        assert "k1".equals( key );

        // delete the column directly
        rm = new Mutation(KEYSPACE3, ByteBufferUtil.bytes("k1"));
        rm.delete(CF_INDEX1, cellname("birthdate"), 1);
        rm.applyUnsafe();
        rows = cfs.search(range, clause, filter, 100);
        assert rows.isEmpty();

        // verify that it's not being indexed under the deletion column value either
        Cell deletion = rm.getColumnFamilies().iterator().next().iterator().next();
        ByteBuffer deletionLong = ByteBufferUtil.bytes((long) ByteBufferUtil.toInt(deletion.value()));
        IndexExpression expr0 = new IndexExpression(ByteBufferUtil.bytes("birthdate"), IndexExpression.Operator.EQ, deletionLong);
        List<IndexExpression> clause0 = Arrays.asList(expr0);
        rows = cfs.search(range, clause0, filter, 100);
        assert rows.isEmpty();

        // resurrect w/ a newer timestamp
        rm = new Mutation(KEYSPACE3, ByteBufferUtil.bytes("k1"));
        rm.add(CF_INDEX1, cellname("birthdate"), ByteBufferUtil.bytes(1L), 2);
        rm.applyUnsafe();
        rows = cfs.search(range, clause, filter, 100);
        assert rows.size() == 1 : StringUtils.join(rows, ",");
        key = ByteBufferUtil.string(rows.get(0).key.getKey());
        assert "k1".equals( key );

        // verify that row and delete w/ older timestamp does nothing
        rm = new Mutation(KEYSPACE3, ByteBufferUtil.bytes("k1"));
        rm.delete(CF_INDEX1, 1);
        rm.applyUnsafe();
        rows = cfs.search(range, clause, filter, 100);
        assert rows.size() == 1 : StringUtils.join(rows, ",");
        key = ByteBufferUtil.string(rows.get(0).key.getKey());
        assert "k1".equals( key );

        // similarly, column delete w/ older timestamp should do nothing
        rm = new Mutation(KEYSPACE3, ByteBufferUtil.bytes("k1"));
        rm.delete(CF_INDEX1, cellname("birthdate"), 1);
        rm.applyUnsafe();
        rows = cfs.search(range, clause, filter, 100);
        assert rows.size() == 1 : StringUtils.join(rows, ",");
        key = ByteBufferUtil.string(rows.get(0).key.getKey());
        assert "k1".equals( key );

        // delete the entire row (w/ newer timestamp this time)
        rm = new Mutation(KEYSPACE3, ByteBufferUtil.bytes("k1"));
        rm.delete(CF_INDEX1, 3);
        rm.applyUnsafe();
        rows = cfs.search(range, clause, filter, 100);
        assert rows.isEmpty() : StringUtils.join(rows, ",");

        // make sure obsolete mutations don't generate an index entry
        rm = new Mutation(KEYSPACE3, ByteBufferUtil.bytes("k1"));
        rm.add(CF_INDEX1, cellname("birthdate"), ByteBufferUtil.bytes(1L), 3);
        rm.applyUnsafe();
        rows = cfs.search(range, clause, filter, 100);
        assert rows.isEmpty() : StringUtils.join(rows, ",");

        // try insert followed by row delete in the same mutation
        rm = new Mutation(KEYSPACE3, ByteBufferUtil.bytes("k1"));
        rm.add(CF_INDEX1, cellname("birthdate"), ByteBufferUtil.bytes(1L), 1);
        rm.delete(CF_INDEX1, 2);
        rm.applyUnsafe();
        rows = cfs.search(range, clause, filter, 100);
        assert rows.isEmpty() : StringUtils.join(rows, ",");

        // try row delete followed by insert in the same mutation
        rm = new Mutation(KEYSPACE3, ByteBufferUtil.bytes("k1"));
        rm.delete(CF_INDEX1, 3);
        rm.add(CF_INDEX1, cellname("birthdate"), ByteBufferUtil.bytes(1L), 4);
        rm.applyUnsafe();
        rows = cfs.search(range, clause, filter, 100);
        assert rows.size() == 1 : StringUtils.join(rows, ",");
        key = ByteBufferUtil.string(rows.get(0).key.getKey());
        assert "k1".equals( key );
    }

