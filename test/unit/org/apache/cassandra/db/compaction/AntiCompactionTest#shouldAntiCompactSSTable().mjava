    @Test
    public void shouldAntiCompactSSTable() throws IOException, InterruptedException, ExecutionException
    {
        ColumnFamilyStore store = prepareColumnFamilyStore();
        Collection<SSTableReader> sstables = getUnrepairedSSTables(store);
        assertEquals(store.getLiveSSTables().size(), sstables.size());
        // SSTable range is 0 - 10, repair just a subset of the ranges (0 - 4) of the SSTable. Should result in
        // one repaired and one unrepaired SSTable
        Range<Token> range = new Range<Token>(new BytesToken("/".getBytes()), new BytesToken("4".getBytes()));
        List<Range<Token>> ranges = Arrays.asList(range);
        UUID parentRepairSession = UUID.randomUUID();

        try (LifecycleTransaction txn = store.getTracker().tryModify(sstables, OperationType.ANTICOMPACTION);
             Refs<SSTableReader> refs = Refs.ref(sstables))
        {
            CompactionManager.instance.performAnticompaction(store, ranges, refs, txn, 1, parentRepairSession);
        }

        SortedSet<SSTableReader> sstablesSorted = new TreeSet<>(SSTableReader.generationReverseComparator.reversed());
        sstablesSorted.addAll(store.getLiveSSTables());

        SSTableReader sstable = sstablesSorted.first();
        assertThat(store.getLiveSSTables().size(), is(2));
        assertThat(sstable.isRepaired(), is(true));
        assertThat(sstable.selfRef().globalCount(), is(1));
        assertThat(store.getTracker().getCompacting().size(), is(0));

        // Test we don't anti-compact already repaired SSTables. repairedAt shouldn't change for the already repaired SSTable (first)
        sstables = store.getLiveSSTables();
        // Range that's a subset of the repaired SSTable's ranges, so would cause an anti-compaction (if it wasn't repaired)
        range = new Range<Token>(new BytesToken("/".getBytes()), new BytesToken("2".getBytes()));
        ranges = Arrays.asList(range);
        try (Refs<SSTableReader> refs = Refs.ref(sstables))
        {
            // use different repairedAt to ensure it doesn't change
            ListenableFuture fut = CompactionManager.instance.submitAntiCompaction(store, ranges, refs, 200, parentRepairSession);
            fut.get();
        }

        sstablesSorted.clear();
        sstablesSorted.addAll(store.getLiveSSTables());
        assertThat(sstablesSorted.size(), is(2));
        assertThat(sstablesSorted.first().isRepaired(), is(true));
        assertThat(sstablesSorted.last().isRepaired(), is(false));
        assertThat(sstablesSorted.first().getSSTableMetadata().repairedAt, is(1L));
        assertThat(sstablesSorted.last().getSSTableMetadata().repairedAt, is(0L));
        assertThat(sstablesSorted.first().selfRef().globalCount(), is(1));
        assertThat(sstablesSorted.last().selfRef().globalCount(), is(1));
        assertThat(store.getTracker().getCompacting().size(), is(0));

        // Test repairing all the ranges of the repaired SSTable. Should mutate repairedAt without anticompacting,
        // but leave the unrepaired SSTable as is.
        range = new Range<Token>(new BytesToken("/".getBytes()), new BytesToken("4".getBytes()));
        ranges = Arrays.asList(range);

        try (Refs<SSTableReader> refs = Refs.ref(sstables))
        {
            // Same repaired at, but should be changed on the repaired SSTable now
            ListenableFuture fut = CompactionManager.instance.submitAntiCompaction(store, ranges, refs, 200, parentRepairSession);
            fut.get();
        }

        sstablesSorted.clear();
        sstablesSorted.addAll(store.getLiveSSTables());

        assertThat(sstablesSorted.size(), is(2));
        assertThat(sstablesSorted.first().isRepaired(), is(true));
        assertThat(sstablesSorted.last().isRepaired(), is(false));
        assertThat(sstablesSorted.first().getSSTableMetadata().repairedAt, is(200L));
        assertThat(sstablesSorted.last().getSSTableMetadata().repairedAt, is(0L));
        assertThat(sstablesSorted.first().selfRef().globalCount(), is(1));
        assertThat(sstablesSorted.last().selfRef().globalCount(), is(1));
        assertThat(store.getTracker().getCompacting().size(), is(0));

        // Repair whole range. Should mutate repairedAt on repaired SSTable (again) and
        // mark unrepaired SSTable as repaired
        range = new Range<Token>(new BytesToken("/".getBytes()), new BytesToken("999".getBytes()));
        ranges = Arrays.asList(range);

        try (Refs<SSTableReader> refs = Refs.ref(sstables))
        {
            // Both SSTables should have repairedAt of 400
            ListenableFuture fut = CompactionManager.instance.submitAntiCompaction(store, ranges, refs, 400, parentRepairSession);
            fut.get();
        }

        sstablesSorted.clear();
        sstablesSorted.addAll(store.getLiveSSTables());

        assertThat(sstablesSorted.size(), is(2));
        assertThat(sstablesSorted.first().isRepaired(), is(true));
        assertThat(sstablesSorted.last().isRepaired(), is(true));
        assertThat(sstablesSorted.first().getSSTableMetadata().repairedAt, is(400L));
        assertThat(sstablesSorted.last().getSSTableMetadata().repairedAt, is(400L));
        assertThat(sstablesSorted.first().selfRef().globalCount(), is(1));
        assertThat(sstablesSorted.last().selfRef().globalCount(), is(1));
        assertThat(store.getTracker().getCompacting().size(), is(0));
        assertOnDiskState(store, 2);
    }

