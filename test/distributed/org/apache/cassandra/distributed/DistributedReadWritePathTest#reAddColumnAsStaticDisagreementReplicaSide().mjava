    @Test
    public void reAddColumnAsStaticDisagreementReplicaSide() throws Throwable
    {
        try (TestCluster cluster = createCluster(2))
        {
            cluster.schemaChange("CREATE TABLE " + KEYSPACE + ".tbl (pk int, ck int, v1 int, PRIMARY KEY (pk, ck)) WITH read_repair='blocking'");

            for (int i = 1; i <= 3; i++)
            {
                cluster.coordinator().execute("INSERT INTO " + KEYSPACE + ".tbl (pk, ck, v1) VALUES (?, ?, ?)",
                                              ConsistencyLevel.ALL,
                                              1, i, i);
            }

            // Drop column on the replica
            cluster.schemaChange("ALTER TABLE " + KEYSPACE + ".tbl DROP v1", 2);

            // Columns are going to be read and read-repaired as long as they're available
            assertRows(cluster.coordinator().execute("SELECT * FROM " + KEYSPACE + ".tbl WHERE pk = 1",
                                                     ConsistencyLevel.ALL),
                       row(1, 1, 1),
                       row(1, 2, 2),
                       row(1, 3, 3));

            assertRows(cluster.get(2).executeInternal("SELECT * FROM " + KEYSPACE + ".tbl WHERE pk = 1"),
                       row(1, 1),
                       row(1, 2),
                       row(1, 3));

            // Re-add as static on the replica
            cluster.schemaChange("ALTER TABLE " + KEYSPACE + ".tbl ADD v1 int static", 2);

            // Try reading
            assertRows(cluster.coordinator().execute("SELECT * FROM " + KEYSPACE + ".tbl WHERE pk = 1",
                                                     ConsistencyLevel.ALL),
                       row(1, 1, 1),
                       row(1, 2, 2),
                       row(1, 3, 3));

            // Make sure read-repair did not corrupt the data
            assertRows(cluster.get(2).executeInternal("SELECT * FROM " + KEYSPACE + ".tbl WHERE pk = 1"),
                       row(1, 1, null),
                       row(1, 2, null),
                       row(1, 3, null));

            // Writing to the replica with disagreeing schema should not work
            Exception thrown = null;
            try
            {
                cluster.coordinator().execute("INSERT INTO " + KEYSPACE + ".tbl (pk, ck, v1) VALUES (?, ?, ?)",
                                              ConsistencyLevel.ALL,
                                              1, 1, 5);
            }
            catch (Exception e)
            {
                thrown = e;
            }

            Assert.assertNotNull(thrown);

            thrown = null;

            // If somehow replica got new data, reading that data should not be possible, either
            cluster.get(2).executeInternal("INSERT INTO " + KEYSPACE + ".tbl (pk, ck, v1) VALUES (?, ?, ?)",
                                           1, 1, 100);

            try
            {
                assertRows(cluster.coordinator().execute("SELECT * FROM " + KEYSPACE + ".tbl WHERE pk = 1",
                                                         ConsistencyLevel.ALL),
                           row(1, 1, 1),
                           row(1, 2, 2),
                           row(1, 3, 3));
            }
            catch (Exception e)
            {
                thrown = e;
            }

            Assert.assertNotNull(thrown);
        }
    }

