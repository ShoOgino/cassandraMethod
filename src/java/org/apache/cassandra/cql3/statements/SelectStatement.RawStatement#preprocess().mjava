        public SelectStatement preprocess() throws InvalidRequestException
        {
            CFMetaData cfm = ThriftValidation.validateColumnFamily(keyspace(), columnFamily());
            ThriftValidation.validateConsistencyLevel(keyspace(), parameters.consistencyLevel, RequestType.READ);

            if (parameters.limit <= 0)
                throw new InvalidRequestException("LIMIT must be strictly positive");

            CFDefinition cfDef = cfm.getCfDef();
            SelectStatement stmt = new SelectStatement(cfDef, parameters);
            stmt.setBoundTerms(getBoundsTerms());

            // Select clause
            if (parameters.isCount)
            {
                if (selectClause.size() != 1 || (!selectClause.get(0).equals("*") && !selectClause.get(0).equals("1")))
                    throw new InvalidRequestException("Only COUNT(*) and COUNT(1) operations are currently supported.");
            }
            else
            {
                for (ColumnIdentifier t : selectClause)
                {
                    CFDefinition.Name name = cfDef.get(t);
                    if (name == null)
                        throw new InvalidRequestException(String.format("Undefined name %s in selection clause", t));
                    // Keeping the case (as in 'case sensitive') of the input name for the resultSet
                    stmt.selectedNames.add(Pair.create(name, t));
                }
            }

            /*
             * WHERE clause. For a given entity, rules are:
             *   - EQ relation conflicts with anything else (including a 2nd EQ)
             *   - Can't have more than one LT(E) relation (resp. GT(E) relation)
             *   - IN relation are restricted to row keys (for now) and conflics with anything else
             *     (we could allow two IN for the same entity but that doesn't seem very useful)
             *   - The value_alias cannot be restricted in any way (we don't support wide rows with indexed value in CQL so far)
             */
            for (Relation rel : whereClause)
            {
                CFDefinition.Name name = cfDef.get(rel.getEntity());
                if (name == null)
                    throw new InvalidRequestException(String.format("Undefined name %s in where clause ('%s')", rel.getEntity(), rel));

                if (name.kind == CFDefinition.Name.Kind.VALUE_ALIAS)
                    throw new InvalidRequestException(String.format("Restricting the value of a compact CF (%s) is not supported", name.name));

                Restriction restriction = stmt.restrictions.get(name.name);
                switch (rel.operator())
                {
                    case EQ:
                        if (restriction != null)
                            throw new InvalidRequestException(String.format("%s cannot be restricted by more than one relation if it includes an Equal", name));
                        stmt.restrictions.put(name.name, new Restriction(Collections.singletonList(rel.getValue())));
                        break;
                    case GT:
                    case GTE:
                        if (name.kind == CFDefinition.Name.Kind.KEY_ALIAS && !StorageService.getPartitioner().preservesOrder())
                            throw new InvalidRequestException("Only EQ and IN relation are supported on first component of the PRIMARY KEY for RandomPartitioner");
                        if (restriction == null)
                        {
                            restriction = new Restriction();
                            stmt.restrictions.put(name.name, restriction);
                        }
                        if (restriction.start != null)
                            throw new InvalidRequestException(String.format("%s cannot be restricted by more than one Greater-Than relation", name));
                        restriction.start = rel.getValue();
                        if (rel.operator() == Relation.Type.GTE)
                            restriction.startInclusive = true;
                        break;
                    case LT:
                    case LTE:
                        if (name.kind == CFDefinition.Name.Kind.KEY_ALIAS && !StorageService.getPartitioner().preservesOrder())
                            throw new InvalidRequestException("Only EQ and IN relation are supported on first component of the PRIMARY KEY for RandomPartitioner");
                        if (restriction == null)
                        {
                            restriction = new Restriction();
                            stmt.restrictions.put(name.name, restriction);
                        }
                        if (restriction.end != null)
                            throw new InvalidRequestException(String.format("%s cannot be restricted by more than one Lesser-Than relation", name));
                        restriction.end = rel.getValue();
                        if (rel.operator() == Relation.Type.LTE)
                            restriction.endInclusive = true;
                        break;
                    case IN:
                        if (restriction != null)
                            throw new InvalidRequestException(String.format("%s cannot be restricted by more than one reation if it includes a IN", name));
                        if (name.kind != CFDefinition.Name.Kind.KEY_ALIAS)
                            throw new InvalidRequestException("IN relation can only be applied to the first component of the PRIMARY KEY");
                        stmt.restrictions.put(name.name, new Restriction(rel.getInValues()));
                        break;
                }
            }

            /*
             * At this point, the select statement if fully constructed, but we still have a few things to validate
             */

            // If a component of the PRIMARY KEY is restricted by a non-EQ relation, all preceding
            // components must have a EQ, and all following must have no restriction
            boolean shouldBeDone = false;
            CFDefinition.Name previous = null;
            for (CFDefinition.Name cname : cfDef.columns.values())
            {
                Restriction restriction = stmt.restrictions.get(cname.name);
                if (restriction == null)
                    shouldBeDone = true;
                else if (shouldBeDone)
                    throw new InvalidRequestException(String.format("PRIMARY KEY part %s cannot be restricted (preceding part %s is either not restricted or by a non-EQ relation)", cname, previous));
                else if (!restriction.isEquality())
                    shouldBeDone = true;
                // We could support IN for the last name, we don't yet
                else if (restriction.eqValues.size() > 1)
                    throw new InvalidRequestException(String.format("PRIMARY KEY part %s cannot be restricted by IN relation", cname));

                previous = cname;
            }

            // Deal with indexed columns
            if (!cfDef.metadata.values().isEmpty())
            {
                boolean hasEq = false;
                Set<ByteBuffer> indexed = Table.open(keyspace()).getColumnFamilyStore(columnFamily()).indexManager.getIndexedColumns();

                for (CFDefinition.Name name : cfDef.metadata.values())
                {
                    Restriction restriction = stmt.restrictions.get(name.name);
                    if (restriction == null)
                        continue;

                    stmt.hasIndexedExpression = true;
                    if (restriction.isEquality() && indexed.contains(name.name.key))
                    {
                        hasEq = true;
                        break;
                    }
                }

                if (stmt.hasIndexedExpression && !hasEq)
                    throw new InvalidRequestException("No indexed columns present in by-columns clause with Equal operator");

                // If we have indexed columns and the key = X clause, we transform it into a key >= X AND key <= X clause.
                // If it's a IN relation however, we reject it.
                Restriction r = stmt.restrictions.get(cfDef.key.name);
                if (r != null && r.isEquality())
                {
                    if (r.eqValues.size() > 1)
                        throw new InvalidRequestException("Select on indexed columns and with IN clause for the PRIMARY KEY are not supported");

                    r.start = r.eqValues.get(0);
                    r.startInclusive = true;
                    r.end = r.eqValues.get(0);
                    r.endInclusive = true;
                    r.eqValues = null;
                }
            }

            // Only allow reversed if the row key restriction is an equality,
            // since we don't know how to reverse otherwise
            if (stmt.parameters.isColumnsReversed)
            {
                Restriction r = stmt.restrictions.get(cfDef.key.name);
                if (r == null || !r.isEquality())
                    throw new InvalidRequestException("Descending order is only supported is the first part of the PRIMARY KEY is restricted by an Equal or a IN");
            }
            return stmt;
        }

