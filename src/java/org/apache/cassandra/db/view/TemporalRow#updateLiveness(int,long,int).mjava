    /*
     * PK ts:5, ttl:1, deletion: 2
     * Col ts:4, ttl:2, deletion: 3
     *
     * TTL use min, since it expires at the lowest time which we are expiring. If we have the above values, we
     * would want to return 1, since the base row expires in 1 second.
     *
     * Timestamp uses max, as this is the time that the row has been written to the view. See CASSANDRA-10910.
     *
     * Local Deletion Time should use max, as this deletion will cover all previous values written.
     */
    @SuppressWarnings("unchecked")
    private void updateLiveness(int ttl, long timestamp, int localDeletionTime)
    {
        // We are returning whichever is higher from valueIfSet
        // Natural order will return the max: 1.compareTo(2) < 0, so 2 is returned
        // Reverse order will return the min: 1.compareTo(2) > 0, so 1 is returned
        final Comparator max = Comparator.naturalOrder();
        final Comparator min = Comparator.reverseOrder();

        this.viewClusteringTtl = valueIfSet(viewClusteringTtl, ttl, NO_TTL, min);
        this.viewClusteringTimestamp = valueIfSet(viewClusteringTimestamp, timestamp, NO_TIMESTAMP, max);
        this.viewClusteringLocalDeletionTime = valueIfSet(viewClusteringLocalDeletionTime, localDeletionTime, NO_DELETION_TIME, max);
    }

