    private List<SSTableStreamingSections> getSSTableSectionsForRanges(Collection<Range<Token>> ranges, Collection<ColumnFamilyStore> stores, long overriddenRepairedAt)
    {
        Refs<SSTableReader> refs = new Refs<>();
        try
        {
            for (ColumnFamilyStore cfStore : stores)
            {
                final List<Range<RowPosition>> keyRanges = new ArrayList<>(ranges.size());
                for (Range<Token> range : ranges)
                    keyRanges.add(Range.makeRowRange(range));
                refs.addAll(cfStore.selectAndReference(new Function<View, List<SSTableReader>>()
                {
                    public List<SSTableReader> apply(View view)
                    {
                        Map<SSTableReader, SSTableReader> permittedInstances = new HashMap<>();
                        for (SSTableReader reader : ColumnFamilyStore.CANONICAL_SSTABLES.apply(view))
                            permittedInstances.put(reader, reader);

                        Set<SSTableReader> sstables = Sets.newHashSet();
                        for (Range<RowPosition> keyRange : keyRanges)
                        {
                            // keyRange excludes its start, while sstableInBounds is inclusive (of both start and end).
                            // This is fine however, because keyRange has been created from a token range through Range.makeRowRange (see above).
                            // And that later method uses the Token.maxKeyBound() method to creates the range, which return a "fake" key that
                            // sort after all keys having the token. That "fake" key cannot however be equal to any real key, so that even
                            // including keyRange.left will still exclude any key having the token of the original token range, and so we're
                            // still actually selecting what we wanted.
                            for (SSTableReader sstable : view.sstablesInBounds(keyRange.left, keyRange.right))
                            {
                                // sstableInBounds may contain early opened sstables
                                if (isIncremental && sstable.isRepaired())
                                    continue;
                                sstable = permittedInstances.get(sstable);
                                if (sstable != null)
                                    sstables.add(sstable);
                            }
                        }

                        logger.debug("ViewFilter for {}/{} sstables", sstables.size(), view.sstables.size());
                        return ImmutableList.copyOf(sstables);
                    }
                }).refs);
            }

            List<SSTableStreamingSections> sections = new ArrayList<>(refs.size());
            for (SSTableReader sstable : refs)
            {
                long repairedAt = overriddenRepairedAt;
                if (overriddenRepairedAt == ActiveRepairService.UNREPAIRED_SSTABLE)
                    repairedAt = sstable.getSSTableMetadata().repairedAt;
                sections.add(new SSTableStreamingSections(refs.get(sstable),
                                                          sstable.getPositionsForRanges(ranges),
                                                          sstable.estimatedKeysForRanges(ranges),
                                                          repairedAt));
            }
            return sections;
        }
        catch (Throwable t)
        {
            refs.release();
            throw t;
        }
    }

