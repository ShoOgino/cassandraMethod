    /**
     * Validates an union of expression index types. It will throw a {@link RuntimeException} if
     * any of the expressions in the provided clause is not valid for its index implementation.
     * @param clause the query clause
     * @throws org.apache.cassandra.exceptions.InvalidRequestException in case of validation errors
     */
    public void validateIndexSearchersForQuery(List<IndexExpression> clause) throws InvalidRequestException
    {
        // Group by index type
        Map<String, Set<IndexExpression>> expressionsByIndexType = new HashMap<>();
        Map<String, Set<ByteBuffer>> columnsByIndexType = new HashMap<>();
        for (IndexExpression indexExpression : clause)
        {
            SecondaryIndex index = getIndexForColumn(indexExpression.column);

            if (index == null)
                continue;

            String canonicalIndexName = index.getClass().getCanonicalName();
            Set<IndexExpression> expressions = expressionsByIndexType.get(canonicalIndexName);
            Set<ByteBuffer> columns = columnsByIndexType.get(canonicalIndexName);
            if (expressions == null)
            {
                expressions = new HashSet<>();
                columns = new HashSet<>();
                expressionsByIndexType.put(canonicalIndexName, expressions);
                columnsByIndexType.put(canonicalIndexName, columns);
            }

            expressions.add(indexExpression);
            columns.add(indexExpression.column);
        }

        // Validate
        boolean haveSupportedIndexLookup = false;
        for (Map.Entry<String, Set<IndexExpression>> expressions : expressionsByIndexType.entrySet())
        {
            Set<ByteBuffer> columns = columnsByIndexType.get(expressions.getKey());
            SecondaryIndex secondaryIndex = getIndexForColumn(columns.iterator().next());
            SecondaryIndexSearcher searcher = secondaryIndex.createSecondaryIndexSearcher(columns);
            for (IndexExpression expression : expressions.getValue())
            {
                searcher.validate(expression);
                haveSupportedIndexLookup |= secondaryIndex.supportsOperator(expression.operator);
            }
        }

        if (!haveSupportedIndexLookup)
        {
            // build the error message
            int i = 0;
            StringBuilder sb = new StringBuilder("No secondary indexes on the restricted columns support the provided operators: ");
            for (Map.Entry<String, Set<IndexExpression>> expressions : expressionsByIndexType.entrySet())
            {
                for (IndexExpression expression : expressions.getValue())
                {
                    if (i++ > 0)
                        sb.append(", ");
                    sb.append("'");
                    String columnName;
                    try
                    {
                        columnName = ByteBufferUtil.string(expression.column);
                    }
                    catch (CharacterCodingException ex)
                    {
                        columnName = "<unprintable>";
                    }
                    sb.append(columnName).append(" ").append(expression.operator).append(" <value>").append("'");
                }
            }

            throw new InvalidRequestException(sb.toString());
        }
    }

