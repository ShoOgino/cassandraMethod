    /**
     * Wraps an existing {@code CBuilder} to provide him with a MultiCBuilder interface
     * for the sake of passing it to {@link Restriction.appendTo}. The resulting
     * {@code MultiCBuilder} will still only be able to create a single clustering/bound
     * and an {@code IllegalArgumentException} will be thrown if elements that added that
     * would correspond to building multiple clusterings.
     */
    public static MultiCBuilder wrap(final CBuilder builder)
    {
        return new MultiCBuilder()
        {
            private boolean containsNull;
            private boolean containsUnset;
            private boolean hasMissingElements;

            public MultiCBuilder addElementToAll(ByteBuffer value)
            {
                builder.add(value);

                if (value == null)
                    containsNull = true;
                if (value == ByteBufferUtil.UNSET_BYTE_BUFFER)
                    containsUnset = true;

                return this;
            }

            public MultiCBuilder addEachElementToAll(List<ByteBuffer> values)
            {
                if (values.isEmpty())
                {
                    hasMissingElements = true;
                    return this;
                }

                if (values.size() > 1)
                    throw new IllegalArgumentException();

                return addElementToAll(values.get(0));
            }

            public MultiCBuilder addAllElementsToAll(List<List<ByteBuffer>> values)
            {
                if (values.isEmpty())
                {
                    hasMissingElements = true;
                    return this;
                }

                if (values.size() > 1)
                    throw new IllegalArgumentException();

                return addEachElementToAll(values.get(0));
            }

            public int remainingCount()
            {
                return builder.remainingCount();
            }

            public boolean containsNull()
            {
                return containsNull;
            }

            public boolean containsUnset()
            {
                return containsUnset;
            }

            public boolean hasMissingElements()
            {
                return hasMissingElements;
            }

            public NavigableSet<Clustering> build()
            {
                return BTreeSet.of(builder.comparator(), builder.build());
            }

            public NavigableSet<Slice.Bound> buildBound(boolean isStart, boolean isInclusive)
            {
                return BTreeSet.of(builder.comparator(), builder.buildBound(isStart, isInclusive));
            }
        };
    }

