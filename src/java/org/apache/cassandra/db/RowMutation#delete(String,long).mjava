    public void delete(String columnFamilyColumn, long timestamp)
    {
        String[] values = RowMutation.getColumnAndColumnFamily(columnFamilyColumn);
        String cfName = values[0];

        if (modifications_.containsKey(cfName))
        {
            throw new IllegalArgumentException("ColumnFamily " + cfName + " is already being modified");
        }
        if (values.length == 0 || values.length > 3)
            throw new IllegalArgumentException("Column Family " + columnFamilyColumn + " in invalid format. Must be in <column family>:<column> format.");

        int localDeleteTime = (int) (System.currentTimeMillis() / 1000);

        ColumnFamily columnFamily = modifications_.get(cfName);
        if (columnFamily == null)
            columnFamily = new ColumnFamily(cfName, DatabaseDescriptor.getColumnType(cfName));
        if (values.length == 2)
        {
            if (columnFamily.isSuper())
            {
                SuperColumn sc = new SuperColumn(values[1]);
                sc.markForDeleteAt(localDeleteTime, timestamp);
                columnFamily.addColumn(sc);
            }
            else
            {
                ByteBuffer bytes = ByteBuffer.allocate(4);
                bytes.putInt(localDeleteTime);
                columnFamily.addColumn(values[1], bytes.array(), timestamp, true);
            }
        }
        else if (values.length == 3)
        {
            ByteBuffer bytes = ByteBuffer.allocate(4);
            bytes.putInt(localDeleteTime);
            columnFamily.addColumn(values[1] + ":" + values[2], bytes.array(), timestamp, true);
        }
        else
        {
            assert values.length == 1;
            columnFamily.delete(localDeleteTime, timestamp);
        }
        modifications_.put(cfName, columnFamily);
    }

