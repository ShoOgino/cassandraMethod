    private UnfilteredRowIterator filterStaleEntries(UnfilteredRowIterator dataIter,
                                                     final CompositesIndex index,
                                                     final ByteBuffer indexValue,
                                                     final List<CompositesIndex.IndexedEntry> entries,
                                                     final OpOrder.Group writeOp,
                                                     final int nowInSec)
    {
        return new AlteringUnfilteredRowIterator(dataIter)
        {
            private int entriesIdx;

            @Override
            protected Row computeNext(Row row)
            {
                CompositesIndex.IndexedEntry entry = findEntry(row.clustering(), writeOp, nowInSec);
                if (!index.isStale(row, indexValue, nowInSec))
                    return row;

                // The entry is stale: delete the entry and ignore otherwise
                index.delete(entry, writeOp, nowInSec);
                return null;
            }

            private CompositesIndex.IndexedEntry findEntry(Clustering clustering, OpOrder.Group writeOp, int nowInSec)
            {
                assert entriesIdx < entries.size();
                while (entriesIdx < entries.size())
                {
                    CompositesIndex.IndexedEntry entry = entries.get(entriesIdx++);
                    // The entries are in clustering order. So that the requested entry should be the
                    // next entry, the one at 'entriesIdx'. However, we can have stale entries, entries
                    // that have no corresponding row in the base table typically because of a range
                    // tombstone or partition level deletion. Delete such stale entries.
                    int cmp = metadata().comparator.compare(entry.indexedEntryClustering, clustering);
                    assert cmp <= 0; // this would means entries are not in clustering order, which shouldn't happen
                    if (cmp == 0)
                        return entry;
                    else
                        index.delete(entry, writeOp, nowInSec);
                }
                // entries correspond to the rows we've queried, so we shouldn't have a row that has no corresponding entry.
                throw new AssertionError();
            }
        };
    }

