    /** {@inheritDoc} */
    public List<IMutation> getMutations(ClientState clientState, List<ByteBuffer> variables)
    throws RequestExecutionException, RequestValidationException
    {
        List<ByteBuffer> keys = buildKeyNames(cfDef, processedKeys, variables);

        ColumnNameBuilder builder = cfDef.getColumnNameBuilder();
        buildColumnNames(cfDef, processedKeys, builder, variables, true);

        // Lists SET operation incurs a read. Do that now. Note that currently,
        // if there is at least one list, we just read the whole "row" (in the CQL sense of
        // row) to simplify. Once #3885 is in, we can improve.
        boolean needsReading = false;
        for (Map.Entry<CFDefinition.Name, Operation> entry : processedColumns.entries())
        {
            CFDefinition.Name name = entry.getKey();
            Operation value = entry.getValue();

            if (!(name.type instanceof ListType))
                continue;

            if (value.requiresRead())
            {
                needsReading = true;
                break;
            }
        }

        Map<ByteBuffer, ColumnGroupMap> rows = needsReading ? readRows(keys, builder, (CompositeType)cfDef.cfm.comparator) : null;

        List<IMutation> rowMutations = new LinkedList<IMutation>();
        UpdateParameters params = new UpdateParameters(variables, getTimestamp(clientState), getTimeToLive());

        for (ByteBuffer key: keys)
            rowMutations.add(mutationForKey(cfDef, key, builder, params, rows == null ? null : rows.get(key)));

        return rowMutations;
    }

