    public static void insertBlocking(RowMutation rm, int consistency_level) throws UnavailableException
    {
        long startTime = System.currentTimeMillis();
        Message message;
        try
        {
            message = rm.makeRowMutationMessage();
        }
        catch (IOException e)
        {
            throw new RuntimeException(e);
        }
        try
        {
            List<InetAddress> naturalEndpoints = StorageService.instance().getNaturalEndpoints(rm.key());
            Map<InetAddress, InetAddress> endpointMap = StorageService.instance().getHintedEndpointMap(rm.key(), naturalEndpoints);
            int blockFor = determineBlockFor(naturalEndpoints.size(), endpointMap.size(), consistency_level);
            List<InetAddress> primaryNodes = getUnhintedNodes(endpointMap);
            if (primaryNodes.size() < blockFor) // guarantee blockFor = W live nodes.
            {
                throw new UnavailableException();
            }
            QuorumResponseHandler<Boolean> quorumResponseHandler = StorageService.instance().getResponseHandler(new WriteResponseResolver(), blockFor, consistency_level);
            if (logger.isDebugEnabled())
                logger.debug("insertBlocking writing key " + rm.key() + " to " + message.getMessageId() + "@[" + StringUtils.join(endpointMap.values(), ", ") + "]");

            // Get all the targets and stick them in an array
            MessagingService.instance().sendRR(message, primaryNodes.toArray(new InetAddress[primaryNodes.size()]), quorumResponseHandler);
            if (!quorumResponseHandler.get())
                throw new UnavailableException();
            if (primaryNodes.size() < endpointMap.size()) // Do we need to bother with Hinted Handoff?
            {
                for (Map.Entry<InetAddress, InetAddress> e : endpointMap.entrySet())
                {
                    if (e.getKey() != e.getValue()) // Hinted Handoff to target
                    {
                        MessagingService.instance().sendOneWay(message, e.getValue());
                    }
                }
            }
        }
        catch (Exception e)
        {
            logger.error("error writing key " + rm.key(), e);
            throw new UnavailableException();
        }
        finally
        {
            writeStats.add(System.currentTimeMillis() - startTime);
        }
    }

