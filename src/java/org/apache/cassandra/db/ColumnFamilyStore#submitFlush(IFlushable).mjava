    /**
     * submits flush sort on the flushSorter executor, which will in turn submit to flushWriter when sorted.
     * TODO because our executors use CallerRunsPolicy, when flushSorter fills up, no writes will proceed
     * because the next flush will start executing on the caller, mutation-stage thread that has the
     * flush write lock held.  (writes aquire this as a read lock before proceeding.)
     * This is good, because it backpressures flushes, but bad, because we can't write until that last
     * flushing thread finishes sorting, which will almost always be longer than any of the flushSorter threads proper
     * (since, by definition, it started last).
     */
    Condition submitFlush(final IFlushable flushable)
    {
        logger_.info("Enqueuing flush of " + flushable);
        if (flushable instanceof Memtable)
        {
            // special-casing Memtable here is a bit messy, but it's best to keep the flush-related happenings in one place
            // since they're a little complicated.  (We dont' want to move the remove back to switchMemtable, which is
            // the other sane option, since that could mean keeping a flushed memtable in the Historical set unnecessarily
            // while earlier flushes finish.)
            getMemtablesPendingFlushNotNull(columnFamily_).add((Memtable) flushable); // it's ok for the MT to briefly be both active and pendingFlush
        }
        final Condition condition = new SimpleCondition();
        flushSorter_.submit(new Runnable()
        {
            public void run()
            {
                final List sortedKeys = flushable.getSortedKeys();
                flushWriter_.submit(new Runnable()
                {
                    public void run()
                    {
                        try
                        {
                            addSSTable(flushable.writeSortedContents(sortedKeys));
                        }
                        catch (IOException e)
                        {
                            throw new RuntimeException(e);
                        }
                        if (flushable instanceof Memtable)
                        {
                            getMemtablesPendingFlushNotNull(columnFamily_).remove(flushable);
                        }
                        condition.signalAll();
                    }
                });
            }
        });
        return condition;
    }

