        /**
         * calculating endpoints to stream current ranges to if needed
         * in some situations node will handle current ranges as part of the new ranges
         **/
        public RangesByEndpoint calculateRangesToStreamWithEndpoints(RangesAtEndpoint streamRanges,
                                                                     AbstractReplicationStrategy strat,
                                                                     TokenMetadata tmdBefore,
                                                                     TokenMetadata tmdAfter)
        {
            RangesByEndpoint.Mutable endpointRanges = new RangesByEndpoint.Mutable();
            for (Replica toStream : streamRanges)
            {
                //If the range we are sending is full only send it to the new full replica
                //There will also be a new transient replica we need to send the data to, but not
                //the repaired data
                EndpointsForRange currentEndpoints = strat.calculateNaturalReplicas(toStream.range().right, tmdBefore);
                EndpointsForRange newEndpoints = strat.calculateNaturalReplicas(toStream.range().right, tmdAfter);
                logger.debug("Need to stream {}, current endpoints {}, new endpoints {}", toStream, currentEndpoints, newEndpoints);

                for (Replica current : currentEndpoints)
                {
                    for (Replica updated : newEndpoints)
                    {
                        if (current.endpoint().equals(updated.endpoint()))
                        {
                            //Nothing to do
                            if (current.equals(updated))
                                break;

                            //In these two (really three) cases the existing data is sufficient and we should subtract whatever is already replicated
                            if (current.isFull() == updated.isFull() || current.isFull())
                            {
                                //First subtract what we already have
                                Set<Range<Token>> subsToStream = toStream.range().subtract(current.range());
                                //Now we only stream what is still replicated
                                subsToStream = subsToStream.stream().flatMap(range -> range.intersectionWith(updated.range()).stream()).collect(Collectors.toSet());
                                for (Range<Token> subrange : subsToStream)
                                {
                                    //Only stream what intersects with what is in the new world
                                    Set<Range<Token>> intersections = subrange.intersectionWith(updated.range());
                                    for (Range<Token> intersection : intersections)
                                    {
                                        endpointRanges.put(updated.endpoint(), updated.decorateSubrange(intersection));
                                    }
                                }
                            }
                            else
                            {
                                for (Range<Token> intersection : toStream.range().intersectionWith(updated.range()))
                                {
                                    endpointRanges.put(updated.endpoint(), updated.decorateSubrange(intersection));
                                }
                            }
                        }
                    }
                }

                for (Replica updated : newEndpoints)
                {
                    if (!currentEndpoints.byEndpoint().containsKey(updated.endpoint()))
                    {
                        // Completely new range for this endpoint
                        if (toStream.isTransient() && updated.isFull())
                        {
                            throw new AssertionError(String.format("Need to stream %s, but only have %s which is transient and not full", updated, toStream));
                        }
                        for (Range<Token> intersection : updated.range().intersectionWith(toStream.range()))
                        {
                            endpointRanges.put(updated.endpoint(), updated.decorateSubrange(intersection));
                        }
                    }
                }
            }
            return endpointRanges.asImmutableView();
        }

