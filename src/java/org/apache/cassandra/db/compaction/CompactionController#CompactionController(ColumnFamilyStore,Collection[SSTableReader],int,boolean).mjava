    public CompactionController(ColumnFamilyStore cfs, Collection<SSTableReader> sstables, int gcBefore, boolean forceDeserialize)
    {
        assert cfs != null;
        this.cfs = cfs;
        this.sstables = new HashSet<SSTableReader>(sstables);
        this.gcBefore = gcBefore;
        // If we merge an old NodeId id, we must make sure that no further increment for that id are in an active memtable.
        // For that, we must make sure that this id was renewed before the creation of the oldest unflushed memtable. We
        // add 5 minutes to be sure we're on the safe side in terms of thread safety (though we should be fine in our
        // current 'stop all write during memtable switch' situation).
        this.mergeShardBefore = (int) ((cfs.oldestUnflushedMemtable() + 5 * 3600) / 1000);
        this.forceDeserialize = forceDeserialize;
        isMajor = cfs.isCompleteSSTables(this.sstables);
        // how many rows we expect to compact in 100ms
        long rowSize = cfs.getMeanRowSize();
        int rowsPerSecond = rowSize > 0
                          ? (int) (DatabaseDescriptor.getCompactionThroughputMbPerSec() * 1024 * 1024 / rowSize)
                          : 1000;
        throttleResolution = rowsPerSecond / 10;
        if (throttleResolution <= 0)
            throttleResolution = 1;
    }

