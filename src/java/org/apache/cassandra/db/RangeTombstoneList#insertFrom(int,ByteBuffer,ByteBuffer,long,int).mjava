    /*
     * Inserts a new element whose start should be inserted at index i. This method
     * assumes that:
     *   - starts[i] <= start
     *   - start < starts[i+1] or there is no i+1 element.
     */
    private void insertFrom(int i, ByteBuffer start, ByteBuffer end, long markedAt, int delTime)
    {
        if (i < 0)
        {
            insertAfter(i, start, end, markedAt, delTime);
            return;
        }

        /*
         * We have elt(i) = [s_i, e_i]@t_i and want to insert X = [s, e]@t, knowing that s_i < s < s_i+1.
         * We can have 3 cases:
         *  - s < e_i && e <= e_i: we're fully contained in i.
         *  - s < e_i && e > e_i: we rewrite X to X1=[s, e_i]@t + X2=[e_i, e]@t. X1 is fully contained
         *             in i and X2 is the insertAfter() case for i.
         *  - s >= e_i: we're in the insertAfter() case for i.
         */
        if (comparator.compare(start, ends[i]) < 0)
        {
            if (comparator.compare(end, ends[i]) <= 0)
            {
                update(i, start, end, markedAt, delTime);
            }
            else
            {
                insertAfter(i, ends[i], end, markedAt, delTime);
                update(i, start, ends[i], markedAt, delTime);
            }
        }
        else
        {
            insertAfter(i, start, end, markedAt, delTime);
        }
    }

