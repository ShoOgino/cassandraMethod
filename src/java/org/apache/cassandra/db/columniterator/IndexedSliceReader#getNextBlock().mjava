    public boolean getNextBlock() throws IOException
    {
        if (curRangeIndex < 0 || curRangeIndex >= indexes.size())
            return false;

        /* seek to the correct offset to the data, and calculate the data size */
        IndexHelper.IndexInfo curColPosition = indexes.get(curRangeIndex);

        /* see if this read is really necessary. */
        if (reversed)
        {
            if ((finishColumn.length > 0 && comparator.compare(finishColumn, curColPosition.lastName) > 0) ||
                (startColumn.length > 0 && comparator.compare(startColumn, curColPosition.firstName) < 0))
                return false;
        }
        else
        {
            if ((startColumn.length > 0 && comparator.compare(startColumn, curColPosition.lastName) > 0) ||
                (finishColumn.length > 0 && comparator.compare(finishColumn, curColPosition.firstName) < 0))
                return false;
        }

        boolean outOfBounds = false;

        file.reset(mark);
        long curOffset = file.skipBytes((int) curColPosition.offset);
        assert curOffset == curColPosition.offset;
        while (file.bytesPastMark(mark) < curColPosition.offset + curColPosition.width && !outOfBounds)
        {
            IColumn column = emptyColumnFamily.getColumnSerializer().deserialize(file);
            if (reversed)
                blockColumns.addFirst(column);
            else
                blockColumns.addLast(column);

            /* see if we can stop seeking. */
            if (!reversed && finishColumn.length > 0)
                outOfBounds = comparator.compare(column.name(), finishColumn) >= 0;
            else if (reversed && startColumn.length > 0)
                outOfBounds = comparator.compare(column.name(), startColumn) >= 0;

            if (outOfBounds)
                break;
        }

        if (reversed)
            curRangeIndex--;
        else
            curRangeIndex++;
        return true;
    }

