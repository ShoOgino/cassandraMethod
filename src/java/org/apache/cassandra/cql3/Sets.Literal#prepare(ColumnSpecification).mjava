        public Term.Terminal prepare(ColumnSpecification receiver) throws InvalidRequestException
        {
            validateAssignableTo(receiver);

            // We've parsed empty maps as a set literal to break the ambiguity so
            // handle that case now
            if (receiver.type instanceof MapType && elements.isEmpty())
                return new Maps.Value(Collections.<ByteBuffer, ByteBuffer>emptyMap());

            ColumnSpecification valueSpec = Sets.valueSpecOf(receiver);
            Set<ByteBuffer> values = new TreeSet<ByteBuffer>(((SetType)receiver.type).elements);
            for (Term.Raw rt : elements)
            {
                Term t = rt.prepare(valueSpec);

                if (t instanceof Term.NonTerminal)
                    throw new InvalidRequestException(String.format("Invalid set literal for %s: bind variables are not supported inside collection literals", receiver));

                // We don't allow prepared marker in collections, nor nested collections (for the later, prepare will throw an exception)
                assert t instanceof Constants.Value;
                ByteBuffer bytes = ((Constants.Value)t).bytes;
                if (bytes == null)
                    throw new InvalidRequestException("null is not supported inside collections");

                // We don't support value > 64K because the serialization format encode the length as an unsigned short.
                if (bytes.remaining() > FBUtilities.MAX_UNSIGNED_SHORT)
                    throw new InvalidRequestException(String.format("Set value is too long. Set values are limited to %d bytes but %d bytes value provided",
                                                                    FBUtilities.MAX_UNSIGNED_SHORT,
                                                                    bytes.remaining()));

                if (!values.add(bytes))
                    throw new InvalidRequestException(String.format("Invalid set literal: duplicate value %s", rt));
            }
            return new Value(values);
        }

