    /**
     * Returns a new SSTableReader with the same properties as this SSTableReader except that a new IndexSummary will
     * be built at the target samplingLevel.  This (original) SSTableReader instance will be marked as replaced, have
     * its DeletingTask removed, and have its periodic read-meter sync task cancelled.
     * @param samplingLevel the desired sampling level for the index summary on the new SSTableReader
     * @return a new SSTableReader
     * @throws IOException
     */
    public SSTableReader cloneWithNewSummarySamplingLevel(int samplingLevel) throws IOException
    {
        IndexSummary newSummary;
        if (samplingLevel < indexSummary.getSamplingLevel())
        {
            newSummary = IndexSummaryBuilder.downsample(indexSummary, samplingLevel, partitioner);

            SegmentedFile.Builder ibuilder = SegmentedFile.getBuilder(DatabaseDescriptor.getIndexAccessMode());
            SegmentedFile.Builder dbuilder = compression
                                           ? SegmentedFile.getCompressedBuilder()
                                           : SegmentedFile.getBuilder(DatabaseDescriptor.getDiskAccessMode());
            saveSummary(ibuilder, dbuilder, newSummary);
        }
        else if (samplingLevel > indexSummary.getSamplingLevel())
        {
            newSummary = upsampleSummary(samplingLevel);
        }
        else
        {
            throw new AssertionError("Attempted to clone SSTableReader with the same index summary sampling level");
        }

        markReplaced();
        if (readMeterSyncFuture != null)
            readMeterSyncFuture.cancel(false);

        SSTableReader replacement = new SSTableReader(descriptor, components, metadata, partitioner, ifile, dfile, newSummary, bf, maxDataAge, sstableMetadata);
        replacement.readMeter = this.readMeter;
        replacement.first = this.first;
        replacement.last = this.last;
        return replacement;
    }

