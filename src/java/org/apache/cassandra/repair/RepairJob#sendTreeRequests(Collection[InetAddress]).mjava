    /**
     * Send merkle tree request to every involved neighbor.
     */
    public void sendTreeRequests(Collection<InetAddress> endpoints)
    {
        // send requests to all nodes
        List<InetAddress> allEndpoints = new ArrayList<>(endpoints);
        allEndpoints.add(FBUtilities.getBroadcastAddress());

        // Create a snapshot at all nodes unless we're using pure parallel repairs
        if (parallelismDegree != RepairParallelism.PARALLEL)
        {
            List<ListenableFuture<InetAddress>> snapshotTasks = new ArrayList<>(allEndpoints.size());
            for (InetAddress endpoint : allEndpoints)
            {
                SnapshotTask snapshotTask = new SnapshotTask(desc, endpoint);
                snapshotTasks.add(snapshotTask);
                taskExecutor.execute(snapshotTask);
            }
            ListenableFuture<List<InetAddress>> allSnapshotTasks = Futures.allAsList(snapshotTasks);
            // Execute send tree request after all snapshot complete
            Futures.addCallback(allSnapshotTasks, new FutureCallback<List<InetAddress>>()
            {
                public void onSuccess(List<InetAddress> endpoints)
                {
                    sendTreeRequestsInternal(endpoints);
                }

                public void onFailure(Throwable throwable)
                {
                    // TODO need to propagate error to RepairSession
                    logger.error("Error occurred during snapshot phase", throwable);
                    listener.failedSnapshot();
                    failed = true;
                }
            }, taskExecutor);
        }
        else
        {
            sendTreeRequestsInternal(allEndpoints);
        }
    }

