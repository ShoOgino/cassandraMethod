    public List<Row> scan(IndexClause clause, AbstractBounds range, IFilter dataFilter)
    {
        // TODO: allow merge join instead of just one index + loop
        IndexExpression first = highestSelectivityPredicate(clause);
        ColumnFamilyStore indexCFS = getIndexedColumnFamilyStore(first.column_name);
        assert indexCFS != null;
        DecoratedKey indexKey = indexCFS.partitioner.decorateKey(first.value);

        List<Row> rows = new ArrayList<Row>();
        byte[] startKey = clause.start_key;
        
        outer:
        while (true)
        {
            /* we don't have a way to get the key back from the DK -- we just have a token --
             * so, we need to loop after starting with start_key, until we get to keys in the given `range`.
             * But, if the calling StorageProxy is doing a good job estimating data from each range, the range
             * should be pretty close to `start_key`. */
            QueryFilter indexFilter = QueryFilter.getSliceFilter(indexKey,
                                                                 new QueryPath(indexCFS.getColumnFamilyName()),
                                                                 startKey,
                                                                 ArrayUtils.EMPTY_BYTE_ARRAY,
                                                                 null,
                                                                 false,
                                                                 clause.count);
            ColumnFamily indexRow = indexCFS.getColumnFamily(indexFilter);
            if (indexRow == null)
                break;

            byte[] dataKey = null;
            int n = 0;
            for (IColumn column : indexRow.getSortedColumns())
            {
                if (column.isMarkedForDelete())
                    continue;
                dataKey = column.name();
                n++;
                DecoratedKey dk = partitioner.decorateKey(dataKey);
                if (!range.right.equals(partitioner.getMinimumToken()) && range.right.compareTo(dk.token) < 0)
                    break outer;
                if (!range.contains(dk.token))
                    continue;
                ColumnFamily data = getColumnFamily(new QueryFilter(dk, new QueryPath(columnFamily), dataFilter));
                if (satisfies(data, clause, first))
                    rows.add(new Row(dk, data));
                if (rows.size() == clause.count)
                    break outer;
            }
            startKey = dataKey;
            if (n < clause.count)
                break;
        }

        return rows;
    }

