    /**
     * Use this method to have these Mutations applied
     * across all replicas.
     *
     * @param mutations the mutations to be applied across the replicas
     */
    public static void mutateMV(ByteBuffer dataKey, Collection<Mutation> mutations, boolean writeCommitLog)
    {
        Tracing.trace("Determining replicas for mutation");
        final String localDataCenter = DatabaseDescriptor.getEndpointSnitch().getDatacenter(FBUtilities.getBroadcastAddress());

        long startTime = System.nanoTime();
        List<WriteResponseHandlerWrapper> wrappers = new ArrayList<>(mutations.size());

        try
        {
            Token baseToken = StorageService.instance.getTokenMetadata().partitioner.getToken(dataKey);

            ConsistencyLevel consistencyLevel = ConsistencyLevel.ONE;

            //Since the base -> view replication is 1:1 we only need to store the BL locally
            final Collection<InetAddress> batchlogEndpoints = Collections.singleton(FBUtilities.getBroadcastAddress());
            final UUID batchUUID = UUIDGen.getTimeUUID();
            BatchlogResponseHandler.BatchlogCleanup cleanup = new BatchlogResponseHandler.BatchlogCleanup(mutations.size(),
                                                                                                          () -> asyncRemoveFromBatchlog(batchlogEndpoints, batchUUID));

            // add a handler for each mutation - includes checking availability, but doesn't initiate any writes, yet
            for (Mutation mutation : mutations)
            {
                String keyspaceName = mutation.getKeyspaceName();
                Token tk = mutation.key().getToken();
                InetAddress pairedEndpoint = MaterializedViewUtils.getViewNaturalEndpoint(keyspaceName, baseToken, tk);
                List<InetAddress> naturalEndpoints = Lists.newArrayList(pairedEndpoint);

                WriteResponseHandlerWrapper wrapper = wrapMVBatchResponseHandler(mutation,
                                                                                 consistencyLevel,
                                                                                 consistencyLevel,
                                                                                 naturalEndpoints,
                                                                                 WriteType.BATCH,
                                                                                 cleanup);

                //When local node is the endpoint and there are no pending nodes we can
                // Just apply the mutation locally.
                if (pairedEndpoint.equals(FBUtilities.getBroadcastAddress()) &&
                    wrapper.handler.pendingEndpoints.isEmpty())
                {
                    if (writeCommitLog)
                        mutation.apply();
                    else
                        mutation.applyUnsafe();
                }
                else
                {
                    wrappers.add(wrapper);
                }
            }

            if (!wrappers.isEmpty())
            {
                Mutation blMutation = BatchlogManager.getBatchlogMutationFor(Lists.transform(wrappers, w -> w.mutation), batchUUID, MessagingService.current_version);

                //Apply to local batchlog memtable in this thread
                if (writeCommitLog)
                    blMutation.apply();
                else
                    blMutation.applyUnsafe();

                // now actually perform the writes and wait for them to complete
                asyncWriteBatchedMutations(wrappers, localDataCenter, Stage.MATERIALIZED_VIEW_MUTATION);
            }
        }
        finally
        {
            mvWriteMetrics.addNano(System.nanoTime() - startTime);
        }
    }

