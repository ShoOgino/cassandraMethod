        /**
         * Consumes and sequentially hashes values from the iterator that fall into the active
         * range. Should be called with an iterator that contains at least one matching entry.
         */
        private byte[] consume(Token left, Token right, PeekingIterator<RowHash> entries)
        {
            byte[] sequentialHash = entries.next().hash;
            while (entries.hasNext() && Range.contains(left, right, entries.peek().token))
                sequentialHash = Hashable.binaryHash(sequentialHash, entries.next().hash);
            return sequentialHash;
        }

