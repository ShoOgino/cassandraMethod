        public void maybeTryAdditionalReplicas()
        {
            if (shouldSpeculateAndMaybeWait())
            {
                //Handle speculation stats first in case the callback fires immediately
                cfs.metric.speculativeRetries.inc();
                speculated = true;

                ReadCommand retryCommand = command;
                Replica extraReplica;
                if (handler.resolver.isDataPresent())
                {
                    extraReplica = tryFind(replicaLayout().all(),
                            r -> !replicaLayout().selected().contains(r)).orNull();

                    // we should only use a SpeculatingReadExecutor if we have an extra replica to speculate against
                    assert extraReplica != null;

                    retryCommand = extraReplica.isTransient()
                            ? command.copyAsTransientQuery()
                            : command.copyAsDigestQuery();
                }
                else
                {
                    extraReplica = tryFind(replicaLayout().all(),
                            r -> r.isFull() && !replicaLayout().selected().contains(r)).orNull();
                    if (extraReplica == null)
                    {
                        cfs.metric.speculativeInsufficientReplicas.inc();
                        // cannot safely speculate a new data request, without more work - requests assumed to be
                        // unique per endpoint, and we have no full nodes left to speculate against
                        return;
                    }
                }

                if (traceState != null)
                    traceState.trace("speculating read retry on {}", extraReplica);
                logger.trace("speculating read retry on {}", extraReplica);
                MessagingService.instance().sendRRWithFailure(retryCommand.createMessage(), extraReplica.endpoint(), handler);
            }
        }

