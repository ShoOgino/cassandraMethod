    /** This is temporary until we start creating Cells of the different type (buffer vs. native) */
    public static Cell reconcile(CounterCell a, Cell b)
    {
        assert (b instanceof CounterCell) || (b instanceof DeletedCell) : "Wrong class type: " + b.getClass();

        // live + tombstone: track last tombstone
        if (b.isMarkedForDelete(Long.MIN_VALUE)) // cannot be an expired cell, so the current time is irrelevant
        {
            // live < tombstone
            if (a.timestamp() < b.timestamp())
                return b;

            // live last delete >= tombstone
            if (a.timestampOfLastDelete() >= b.timestamp())
                return a;

            // live last delete < tombstone
            return new BufferCounterCell(a.name(), a.value(), a.timestamp(), b.timestamp());
        }

        assert b instanceof CounterCell : "Wrong class type: " + b.getClass();

        // live < live last delete
        if (a.timestamp() < ((CounterCell) b).timestampOfLastDelete())
            return b;

        // live last delete > live
        if (a.timestampOfLastDelete() > b.timestamp())
            return a;

        // live + live. return one of the cells if its context is a superset of the other's, or merge them otherwise
        ByteBuffer context = CounterCell.contextManager.merge(a.value(), b.value());
        if (context == a.value() && a.timestamp() >= b.timestamp() && a.timestampOfLastDelete() >= ((CounterCell) b).timestampOfLastDelete())
            return a;
        else if (context == b.value() && b.timestamp() >= a.timestamp() && ((CounterCell) b).timestampOfLastDelete() >= a.timestampOfLastDelete())
            return b;
        else // merge clocks and timsestamps.
            return new BufferCounterCell(a.name(),
                                         context,
                                         Math.max(a.timestamp(), b.timestamp()),
                                         Math.max(a.timestampOfLastDelete(), ((CounterCell) b).timestampOfLastDelete()));
    }

