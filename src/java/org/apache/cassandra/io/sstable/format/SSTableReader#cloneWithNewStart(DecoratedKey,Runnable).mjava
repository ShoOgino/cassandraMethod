    public SSTableReader cloneWithNewStart(DecoratedKey newStart, final Runnable runOnClose)
    {
        synchronized (tidy.replaceLock)
        {
            assert tidy.replacedBy == null;

            if (newStart.compareTo(this.first) > 0)
            {
                if (newStart.compareTo(this.last) > 0)
                {
                    this.tidy.runOnClose = new Runnable()
                    {
                        public void run()
                        {
                            CLibrary.trySkipCache(dfile.path, 0, 0);
                            CLibrary.trySkipCache(ifile.path, 0, 0);
                            runOnClose.run();
                        }
                    };
                }
                else
                {
                    final long dataStart = getPosition(newStart, Operator.GE).position;
                    final long indexStart = getIndexScanPosition(newStart);
                    this.tidy.runOnClose = new Runnable()
                    {
                        public void run()
                        {
                            CLibrary.trySkipCache(dfile.path, 0, dataStart);
                            CLibrary.trySkipCache(ifile.path, 0, indexStart);
                            runOnClose.run();
                        }
                    };
                }
            }

            SSTableReader replacement = internalOpen(descriptor, components, metadata, partitioner, ifile, dfile, indexSummary.readOnlyClone(), bf, maxDataAge, sstableMetadata,
                    openReason == OpenReason.EARLY ? openReason : OpenReason.METADATA_CHANGE);
            replacement.readMeterSyncFuture = this.readMeterSyncFuture;
            replacement.readMeter = this.readMeter;
            replacement.first = this.last.compareTo(newStart) > 0 ? newStart : this.last;
            replacement.last = this.last;
            setReplacedBy(replacement);
            return replacement;
        }
    }

