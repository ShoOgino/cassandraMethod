        private boolean collectionAppliesTo(CollectionType type, Composite rowPrefix, ColumnFamily current, final long now) throws InvalidRequestException
        {
            Term.Terminal v = value.bind(options);

            // For map element access, we won't iterate over the collection, so deal with that first. In other case, we do.
            if (collectionElement != null && type instanceof MapType)
            {
                ByteBuffer e = collectionElement.bindAndGet(options);
                if (e == null)
                    throw new InvalidRequestException("Invalid null value for map access");
                return mapElementAppliesTo((MapType)type, current, rowPrefix, e, v.get(options), now);
            }

            CellName name = current.metadata().comparator.create(rowPrefix, column);
            // We are testing for collection equality, so we need to have the expected values *and* only those.
            ColumnSlice[] collectionSlice = new ColumnSlice[]{ name.slice() };
            // Filter live columns, this makes things simpler afterwards
            Iterator<Cell> iter = Iterators.filter(current.iterator(collectionSlice), new Predicate<Cell>()
            {
                public boolean apply(Cell c)
                {
                    // we only care about live columns
                    return c.isLive(now);
                }
            });

            if (v == null)
                return !iter.hasNext();

            if (collectionElement != null)
            {
                assert type instanceof ListType;
                ByteBuffer e = collectionElement.bindAndGet(options);
                if (e == null)
                    throw new InvalidRequestException("Invalid null value for list access");

                return listElementAppliesTo((ListType)type, iter, e, v.get(options));
            }

            switch (type.kind)
            {
                case LIST: return listAppliesTo((ListType)type, iter, ((Lists.Value)v).elements);
                case SET: return setAppliesTo((SetType)type, iter, ((Sets.Value)v).elements);
                case MAP: return mapAppliesTo((MapType)type, iter, ((Maps.Value)v).map);
            }
            throw new AssertionError();
        }

