        public Iterator<Unfiltered> slice(final Slice slice) throws IOException
        {
            final List<IndexHelper.IndexInfo> indexes = indexEntry.columnsIndex();

            // if our previous slicing already got us the biggest row in the sstable, we're done
            if (currentIndexIdx >= indexes.size())
                return Collections.emptyIterator();

            // Find the first index block we'll need to read for the slice.
            final int startIdx = IndexHelper.indexFor(slice.start(), indexes, sstable.metadata.comparator, false, currentIndexIdx);
            if (startIdx >= indexes.size())
                return Collections.emptyIterator();

            // If that's the last block we were reading, we're already where we want to be. Otherwise,
            // seek to that first block
            if (startIdx != currentIndexIdx)
                updateBlock(startIdx);

            // Find the last index block we'll need to read for the slice.
            final int endIdx = IndexHelper.indexFor(slice.end(), indexes, sstable.metadata.comparator, false, startIdx);

            final IndexHelper.IndexInfo startIndex = currentIndex();

            // The index search is based on the last name of the index blocks, so at that point we have that:
            //   1) indexes[startIdx - 1].lastName < slice.start <= indexes[startIdx].lastName
            //   2) indexes[endIdx - 1].lastName < slice.end <= indexes[endIdx].lastName
            // so if startIdx == endIdx and slice.end < indexes[startIdx].firstName, we're guaranteed that the
            // whole slice is between the previous block end and this bloc start, and thus has no corresponding
            // data. One exception is if the previous block ends with an openMarker as it will cover our slice
            // and we need to return it.
            if (startIdx == endIdx && metadata().comparator.compare(slice.end(), startIndex.firstName) < 0 && openMarker == null && sstable.descriptor.version.storeRows())
                return Collections.emptyIterator();

            return new AbstractIterator<Unfiltered>()
            {
                private boolean beforeStart = true;
                private int currentIndexIdx = startIdx;

                protected Unfiltered computeNext()
                {
                    try
                    {
                        // While we're before the start of the slice, we can skip row but we should keep
                        // track of open range tombstones
                        if (beforeStart)
                        {
                            // See ForwardReader equivalent method to see why this inequality is not strict.
                            while (deserializer.hasNext() && deserializer.compareNextTo(slice.start()) <= 0)
                            {
                                if (deserializer.nextIsRow())
                                    deserializer.skipNext();
                                else
                                    updateOpenMarker((RangeTombstoneMarker)deserializer.readNext());
                            }

                            beforeStart = false;

                            // We've reached the beginning of our queried slice. If we have an open marker
                            // we should return that first.
                            if (openMarker != null)
                                return new RangeTombstoneBoundMarker(slice.start(), openMarker);
                        }

                        // If we've crossed an index block boundary, update our informations
                        if (currentIndexIdx < indexes.size() && file.bytesPastMark(mark) >= currentIndex().width)
                            updateBlock(++currentIndexIdx);

                        // Return the next atom unless we've reached the end, or we're beyond our slice
                        // end (note that unless we're on the last block for the slice, there is no point
                        // in checking the slice end).
                        if (currentIndexIdx < indexes.size()
                            && currentIndexIdx <= endIdx
                            && deserializer.hasNext()
                            && (currentIndexIdx != endIdx || deserializer.compareNextTo(slice.end()) <= 0))
                        {
                            Unfiltered next = deserializer.readNext();
                            if (next.kind() == Unfiltered.Kind.RANGE_TOMBSTONE_MARKER)
                                updateOpenMarker((RangeTombstoneMarker)next);
                            return next;
                        }

                        // If we have an open marker, we should close it before finishing
                        if (openMarker != null)
                            return new RangeTombstoneBoundMarker(slice.end(), getAndClearOpenMarker());

                        return endOfData();
                    }
                    catch (IOException e)
                    {
                        try
                        {
                            close();
                        }
                        catch (IOException suppressed)
                        {
                            e.addSuppressed(suppressed);
                        }
                        sstable.markSuspect();
                        throw new CorruptSSTableException(e, file.getPath());
                    }
                }
            };
        }

