    private static ResultSet buildCasFailureResultSet(ByteBuffer key, ColumnFamily cf, Iterable<ColumnIdentifier> columnsWithConditions, boolean isBatch)
    throws InvalidRequestException
    {
        CFMetaData cfm = cf.metadata();
        CFDefinition cfDef = cfm.getCfDef();

        Selection selection;
        if (columnsWithConditions == null)
        {
            selection = Selection.wildcard(cfDef);
        }
        else
        {
            // We can have multiple conditions on the same columns (for collections) so use a set
            // to avoid duplicate, but preserve the order just to it follows the order of IF in the query in general
            Set<CFDefinition.Name> names = new LinkedHashSet<CFDefinition.Name>();
            // Adding the partition key for batches to disambiguate if the conditions span multipe rows (we don't add them outside
            // of batches for compatibility sakes).
            if (isBatch)
            {
                names.addAll(cfDef.partitionKeys());
                names.addAll(cfDef.clusteringColumns());
            }
            for (ColumnIdentifier id : columnsWithConditions)
                names.add(cfDef.get(id));
            selection = Selection.forColumns(new ArrayList<>(names));
        }

        long now = System.currentTimeMillis();
        Selection.ResultSetBuilder builder = selection.resultSetBuilder(now);
        SelectStatement.forSelection(cfm, selection)
                       .processColumnFamily(cfDef, key, cf, Collections.<ByteBuffer>emptyList(), now, builder);

        return builder.build();
    }

