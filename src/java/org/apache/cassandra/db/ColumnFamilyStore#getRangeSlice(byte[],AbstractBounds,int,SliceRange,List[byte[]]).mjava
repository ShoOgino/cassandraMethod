    /**
     *
     * @param super_column
     * @param range: either a Bounds, which includes start key, or a Range, which does not.
     * @param keyMax maximum number of keys to process, regardless of startKey/finishKey
     * @param sliceRange may be null if columnNames is specified. specifies contiguous columns to return in what order.
     * @param columnNames may be null if sliceRange is specified. specifies which columns to return in what order.      @return list of key->list<column> tuples.
     * @throws ExecutionException
     * @throws InterruptedException
     */
    public List<Row> getRangeSlice(byte[] super_column, final AbstractBounds range, int keyMax, SliceRange sliceRange, List<byte[]> columnNames)
    throws ExecutionException, InterruptedException
    {
        List<Row> rows = new ArrayList<Row>();
        boolean completed;
        if ((range instanceof Bounds || !((Range)range).isWrapAround()))
        {
            completed = getRangeRows(rows, super_column, range, keyMax, sliceRange, columnNames);
        }
        else
        {
            // wrapped range
            Token min = StorageService.getPartitioner().getMinimumToken();
            Range first = new Range(range.left, min);
            completed = getRangeRows(rows, super_column, first, keyMax, sliceRange, columnNames);
            if (!completed && min.compareTo(range.right) < 0)
            {
                Range second = new Range(min, range.right);
                getRangeRows(rows, super_column, second, keyMax, sliceRange, columnNames);
            }
        }

        return rows;
    }

