        /**
         * Collects values from the given iterator that fall into the
         * range represented by left and right. Recurses until we reach
         * hashdepth, where hashes are added sequentially, and then binary
         * hashes the results back to the root.
         *
         * @param left The left token of the active range.
         * @param right The right token of the active range.
         * @param depth The depth of the active range.
         * @param entries A peek()able iterator.
         */
        private byte[] validateHelper(Token left, Token right, byte depth, PeekingIterator<RowHash> entries) throws StopRecursion.InvalidHash
        {
            if (entries.hasNext() && Range.contains(left, right, entries.peek().token))
            {
                // see if we can recurse deeper
                if (depth < tree.hashdepth)
                {
                    Token midpoint = tree.partitioner().midpoint(left, right);
                    if (left.compareTo(midpoint) < 0 && midpoint.compareTo(right) < 0)
                    {
                        // we can recurse deeper
                        byte[] lhash = validateHelper(left, midpoint, inc(depth), entries);
                        byte[] rhash = validateHelper(midpoint, right, inc(depth), entries);
                        return Hashable.binaryHash(lhash, rhash);
                    }
                    // else: the Token impl. cannot provide more resolution for this range
                }

                // hash relevant values from the iterator, and add to the context
                return consume(left, right, entries);
            }
            else
            {
                // this range is empty: return static hash value:
                // the hash is the one generated by a binary tree of depth (tree.hashdepth-depth)
                return EMPTIES[tree.hashdepth-depth];
            }
        }

