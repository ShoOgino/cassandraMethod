    /**
     * May be used by custom QueryHandler implementations
     */
    public List<IndexExpression> getIndexExpressions(List<ByteBuffer> variables) throws InvalidRequestException
    {
        if (!usesSecondaryIndexing || restrictedNames.isEmpty())
            return Collections.emptyList();

        List<IndexExpression> expressions = new ArrayList<IndexExpression>();
        for (CFDefinition.Name name : restrictedNames.keySet())
        {
            Restriction restriction;
            switch (name.kind)
            {
                case KEY_ALIAS:
                    restriction = keyRestrictions[name.position];
                    break;
                case COLUMN_ALIAS:
                    restriction = columnRestrictions[name.position];
                    break;
                case COLUMN_METADATA:
                case STATIC:
                    restriction = metadataRestrictions.get(name);
                    break;
                default:
                    // We don't allow restricting a VALUE_ALIAS for now in prepare.
                    throw new AssertionError();
            }

            if (restriction.isSlice())
            {
                Restriction.Slice slice = (Restriction.Slice)restriction;
                for (Bound b : Bound.values())
                {
                    if (slice.hasBound(b))
                    {
                        ByteBuffer value = slice.bound(b, variables);
                        validateIndexExpressionValue(value, name);
                        IndexOperator op = slice.getIndexOperator(b);
                        // If the underlying comparator for name is reversed, we need to reverse the IndexOperator: user operation
                        // always refer to the "forward" sorting even if the clustering order is reversed, but the 2ndary code does
                        // use the underlying comparator as is.
                        if (name.type instanceof ReversedType)
                            op = reverse(op);
                        expressions.add(new IndexExpression(name.name.key, op, value));
                    }
                }
            }
            else
            {
                ByteBuffer value;
                if (restriction.isMultiColumn())
                {
                    List<ByteBuffer> values = restriction.values(variables);
                    value = values.get(name.position);
                }
                else
                {
                    List<ByteBuffer> values = restriction.values(variables);
                    if (values.size() != 1)
                        throw new InvalidRequestException("IN restrictions are not supported on indexed columns");

                    value = values.get(0);
                }

                validateIndexExpressionValue(value, name);
                expressions.add(new IndexExpression(name.name.key, IndexOperator.EQ, value));
            }
        }
        return expressions;
    }

