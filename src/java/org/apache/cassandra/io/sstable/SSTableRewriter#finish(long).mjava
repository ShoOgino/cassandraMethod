    /**
     * Finishes the new file(s)
     *
     * Creates final files, adds the new files to the dataTracker (via replaceReader).
     *
     * We add them to the tracker to be able to get rid of the tmpfiles
     *
     * It is up to the caller to do the compacted sstables replacement
     * gymnastics (ie, call DataTracker#markCompactedSSTablesReplaced(..))
     *
     *
     * @param repairedAt the repair time, -1 if we should use the time we supplied when we created
     *                   the SSTableWriter (and called rewriter.switchWriter(..)), actual time if we want to override the
     *                   repair time.
     */
    public List<SSTableReader> finish(long repairedAt)
    {
        List<SSTableReader> finished = new ArrayList<>();
        if (writer.getFilePointer() > 0)
        {
            SSTableReader reader = repairedAt < 0 ? writer.closeAndOpenReader(maxAge) : writer.closeAndOpenReader(maxAge, repairedAt);
            finished.add(reader);
            replaceEarlyOpenedFile(currentlyOpenedEarly, reader);
            moveStarts(reader, Functions.constant(reader.last), false);
        }
        else
        {
            writer.abort(true);
        }
        // make real sstables of the written ones:
        for (Pair<SSTableWriter, SSTableReader> w : finishedWriters)
        {
            if (w.left.getFilePointer() > 0)
            {
                SSTableReader newReader = repairedAt < 0 ? w.left.closeAndOpenReader(maxAge) : w.left.closeAndOpenReader(maxAge, repairedAt);
                finished.add(newReader);
                // w.right is the tmplink-reader we added when switching writer, replace with the real sstable.
                replaceEarlyOpenedFile(w.right, newReader);
            }
            else
            {
                assert w.right == null;
                w.left.abort(true);
            }
        }
        if (!isOffline)
        {
            dataTracker.unmarkCompacting(finished);
        }
        return finished;
    }

