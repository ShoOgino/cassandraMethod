        /**
         * Used only by o.a.c.service.MigrationManager to fix possibly broken System.nanoTime() timestamps
         * of the schema migrations from remote nodes
         *
         * @param dis The source of the data
         * @param version The version of remote node
         *
         * @return row mutation with fixed internal timestamps
         *
         * @throws IOException If data could not be read
         */
        public RowMutation deserializeFixingTimestamps(DataInput dis, int version) throws IOException
        {
            RowMutation mutation = deserialize(dis, version);

            long now = FBUtilities.timestampMicros();
            Map<UUID, ColumnFamily> fixedModifications = new HashMap<UUID, ColumnFamily>();

            for (Map.Entry<UUID, ColumnFamily> modification : mutation.modifications.entrySet())
            {
                ColumnFamily cfOld = modification.getValue();
                ColumnFamily cf = ColumnFamily.create(cfOld.metadata());

                if (cfOld.isMarkedForDelete())
                {
                    DeletionTime dt = cfOld.deletionInfo().getTopLevelDeletion();
                    cf.delete(new DeletionInfo(dt.markedForDeleteAt > now ? now : dt.markedForDeleteAt,
                                               dt.localDeletionTime));
                }

                for (IColumn column : cfOld.columns)
                {
                    // don't clone if column already has a correct timestamp
                    if (column.timestamp() <= now)
                    {
                        cf.addColumn(column);
                        continue;
                    }

                    if (column.isMarkedForDelete())
                        cf.addColumn(new DeletedColumn(column.name(), column.value(), now));
                    else
                        cf.addColumn(new Column(column.name(), column.value(), now));
                }

                if (cf.isMarkedForDelete() && cf.isEmpty())
                    continue;

                fixedModifications.put(modification.getKey(), cf);
            }

            return new RowMutation(mutation.getTable(), mutation.key(), fixedModifications);
        }

