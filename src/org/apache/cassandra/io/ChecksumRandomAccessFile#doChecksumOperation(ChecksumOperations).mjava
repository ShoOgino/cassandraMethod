    private void doChecksumOperation(ChecksumOperations chksumOps) throws IOException
    {        
        int buffSz = buff_.length;
        /*
         * If the diskPos_ is at the buffer boundary then return 
         * diskPos_ - 1 else return the actual diskPos_.
        */        
        long currentPosition = ( (diskPos_ % buffSz) == 0 ) ? diskPos_ - 1 : diskPos_;
        /* Tells me which buffered chunk I am in. */
        long chunk = (currentPosition / buffSz) + 1; 
        /* Number of checksum chunks within a buffer */
        int chksumChunks = buff_.length / checksumSz_;  
        /* Position of the start of the previous buffer boundary */
        long pos = (chunk == 0) ? 0 : (chunk - 1)*buffSz;
        int startOffset = 0;
        int chksumChunkId = (int)(chksumChunks*(chunk - 1) + 1);
        do
        {            
            int fId = ChecksumManager.getFileId(filename_);               
            switch( chksumOps )
            {
                case LOG:                    
                    ChecksumManager.instance(filename_).logChecksum(fId, chksumChunkId++, buff_, startOffset, checksumSz_);
                    break;
                case VERIFY:
                    ChecksumManager.instance(filename_).validateChecksum(filename_, chksumChunkId++, buff_, startOffset, checksumSz_);
                    break;
            }
            pos += checksumSz_;
            startOffset += checksumSz_;
        }
        while ( pos < currentPosition );
    }

