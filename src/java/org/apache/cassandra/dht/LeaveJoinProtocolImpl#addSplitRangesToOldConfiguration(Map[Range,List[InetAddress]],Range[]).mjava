    /**
     * This method figures out the ranges that have been split and
     * replaces them with the split range.
     * @param oldRangeToEndPointMap old range mapped to their replicas.
     * @param rangesAfterNodesJoin ranges after the nodes have joined at
     *        their respective position.
     */
    private void addSplitRangesToOldConfiguration(Map<Range, List<InetAddress>> oldRangeToEndPointMap, Range[] rangesAfterNodesJoin)
    {
        /* 
         * Find the ranges that are split. Maintain a mapping between
         * the range being split and the list of subranges.
        */                
        Map<Range, List<Range>> splitRanges = LeaveJoinProtocolHelper.getRangeSplitRangeMapping(oldRangeToEndPointMap.keySet().toArray( new Range[0] ), tokens_);
        /* Mapping of split ranges to the list of endpoints responsible for the range */                
        Map<Range, List<InetAddress>> replicasForSplitRanges = new HashMap<Range, List<InetAddress>>();
        Set<Range> rangesSplit = splitRanges.keySet();                
        for ( Range splitRange : rangesSplit )
        {
            replicasForSplitRanges.put( splitRange, oldRangeToEndPointMap.get(splitRange) );
        }
        /* Remove the ranges that are split. */
        for ( Range splitRange : rangesSplit )
        {
            oldRangeToEndPointMap.remove(splitRange);
        }
        
        /* Add the subranges of the split range to the map with the same replica set. */
        for ( Range splitRange : rangesSplit )
        {
            List<Range> subRanges = splitRanges.get(splitRange);
            List<InetAddress> replicas = replicasForSplitRanges.get(splitRange);
            for ( Range subRange : subRanges )
            {
                /* Make sure we clone or else we are hammered. */
                oldRangeToEndPointMap.put(subRange, new ArrayList<InetAddress>(replicas));
            }
        }
    }

