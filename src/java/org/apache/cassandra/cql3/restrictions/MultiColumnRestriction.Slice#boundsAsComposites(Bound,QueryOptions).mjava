        @Override
        public List<Composite> boundsAsComposites(Bound bound, QueryOptions options) throws InvalidRequestException
        {
            CBuilder builder = ctype.builder();
            Iterator<ColumnDefinition> iter = columnDefs.iterator();
            ColumnDefinition firstName = iter.next();
            // A hack to preserve pre-6875 behavior for tuple-notation slices where the comparator mixes ASCENDING
            // and DESCENDING orders.  This stores the bound for the first component; we will re-use it for all following
            // components, even if they don't match the first component's reversal/non-reversal.  Note that this does *not*
            // guarantee correct query results, it just preserves the previous behavior.
            Bound firstComponentBound = !firstName.isReversedType() ? bound : bound.reverse();

            if (!hasBound(firstComponentBound))
            {
                Composite prefix = builder.build();
                return Collections.singletonList(builder.remainingCount() > 0 && bound.isEnd()
                        ? prefix.end()
                        : prefix);
            }

            List<ByteBuffer> vals = componentBounds(firstComponentBound, options);

            ByteBuffer v = checkNotNull(vals.get(firstName.position()), "Invalid null value in condition for column %s", firstName.name);
            builder.add(v);

            while (iter.hasNext())
            {
                ColumnDefinition def = iter.next();
                if (def.position() >= vals.size())
                    break;

                v = checkNotNull(vals.get(def.position()), "Invalid null value in condition for column %s", def.name);
                builder.add(v);
            }
            Composite.EOC eoc =  eocFor(this, bound, firstComponentBound);
            return Collections.singletonList(builder.build().withEOC(eoc));
        }

