    private static List<Composite> buildMultiColumnSliceBound(Bound bound,
                                                              List<ColumnDefinition> defs,
                                                              MultiColumnRestriction.Slice slice,
                                                              boolean isReversed,
                                                              CBuilder builder,
                                                              QueryOptions options) throws InvalidRequestException
    {
        Bound eocBound = isReversed ? Bound.reverse(bound) : bound;

        Iterator<ColumnDefinition> iter = defs.iterator();
        ColumnDefinition firstName = iter.next();
        // A hack to preserve pre-6875 behavior for tuple-notation slices where the comparator mixes ASCENDING
        // and DESCENDING orders.  This stores the bound for the first component; we will re-use it for all following
        // components, even if they don't match the first component's reversal/non-reversal.  Note that this does *not*
        // guarantee correct query results, it just preserves the previous behavior.
        Bound firstComponentBound = isReversed == isReversedType(firstName) ? bound : Bound.reverse(bound);

        if (!slice.hasBound(firstComponentBound))
        {
            Composite prefix = builder.build();
            return Collections.singletonList(builder.remainingCount() > 0 && eocBound == Bound.END
                    ? prefix.end()
                    : prefix);
        }

        List<ByteBuffer> vals = slice.componentBounds(firstComponentBound, options);

        ByteBuffer v = vals.get(firstName.position());
        if (v == null)
            throw new InvalidRequestException("Invalid null value in condition for column " + firstName.name);
        builder.add(v);

        while (iter.hasNext())
        {
            ColumnDefinition def = iter.next();
            if (def.position() >= vals.size())
                break;

            v = vals.get(def.position());
            if (v == null)
                throw new InvalidRequestException("Invalid null value in condition for column " + def.name);
            builder.add(v);
        }
        Relation.Type relType = slice.getRelation(eocBound, firstComponentBound);
        return Collections.singletonList(builder.build().withEOC(eocForRelation(relType)));
    }

