    /**
     * Test CompressedInputStream not hang when closed while reading
     * @throws IOException
     */
    @Test(expected = EOFException.class)
    public void testClose() throws IOException
    {
        CompressionParams param = CompressionParams.snappy(32);
        CompressionMetadata.Chunk[] chunks = {new CompressionMetadata.Chunk(0, 100)};
        final SynchronousQueue<Integer> blocker = new SynchronousQueue<>();
        InputStream blockingInput = new InputStream()
        {
            @Override
            public int read() throws IOException
            {
                try
                {
                    // 10 second cut off not to stop other test in case
                    return Objects.requireNonNull(blocker.poll(10, TimeUnit.SECONDS));
                }
                catch (InterruptedException e)
                {
                    throw new IOException("Interrupted as expected", e);
                }
            }
        };
        CompressionInfo info = new CompressionInfo(chunks, param);
        try (CompressedInputStream cis = new CompressedInputStream(blockingInput, info, ChecksumType.CRC32, () -> 1.0))
        {
            new Thread(new Runnable()
            {
                @Override
                public void run()
                {
                    try
                    {
                        cis.close();
                    }
                    catch (Exception ignore) {}
                }
            }).start();
            // block here
            cis.read();
        }
    }

