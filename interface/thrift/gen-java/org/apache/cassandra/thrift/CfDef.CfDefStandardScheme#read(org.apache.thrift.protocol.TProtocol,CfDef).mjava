    public void read(org.apache.thrift.protocol.TProtocol iprot, CfDef struct) throws org.apache.thrift.TException {
      org.apache.thrift.protocol.TField schemeField;
      iprot.readStructBegin();
      while (true)
      {
        schemeField = iprot.readFieldBegin();
        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
          break;
        }
        switch (schemeField.id) {
          case 1: // KEYSPACE
            if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {
              struct.keyspace = iprot.readString();
              struct.setKeyspaceIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 2: // NAME
            if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {
              struct.name = iprot.readString();
              struct.setNameIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 3: // COLUMN_TYPE
            if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {
              struct.column_type = iprot.readString();
              struct.setColumn_typeIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 5: // COMPARATOR_TYPE
            if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {
              struct.comparator_type = iprot.readString();
              struct.setComparator_typeIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 6: // SUBCOMPARATOR_TYPE
            if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {
              struct.subcomparator_type = iprot.readString();
              struct.setSubcomparator_typeIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 8: // COMMENT
            if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {
              struct.comment = iprot.readString();
              struct.setCommentIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 12: // READ_REPAIR_CHANCE
            if (schemeField.type == org.apache.thrift.protocol.TType.DOUBLE) {
              struct.read_repair_chance = iprot.readDouble();
              struct.setRead_repair_chanceIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 13: // COLUMN_METADATA
            if (schemeField.type == org.apache.thrift.protocol.TType.LIST) {
              {
                org.apache.thrift.protocol.TList _list110 = iprot.readListBegin();
                struct.column_metadata = new ArrayList<ColumnDef>(_list110.size);
                for (int _i111 = 0; _i111 < _list110.size; ++_i111)
                {
                  ColumnDef _elem112; // required
                  _elem112 = new ColumnDef();
                  _elem112.read(iprot);
                  struct.column_metadata.add(_elem112);
                }
                iprot.readListEnd();
              }
              struct.setColumn_metadataIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 14: // GC_GRACE_SECONDS
            if (schemeField.type == org.apache.thrift.protocol.TType.I32) {
              struct.gc_grace_seconds = iprot.readI32();
              struct.setGc_grace_secondsIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 15: // DEFAULT_VALIDATION_CLASS
            if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {
              struct.default_validation_class = iprot.readString();
              struct.setDefault_validation_classIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 16: // ID
            if (schemeField.type == org.apache.thrift.protocol.TType.I32) {
              struct.id = iprot.readI32();
              struct.setIdIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 17: // MIN_COMPACTION_THRESHOLD
            if (schemeField.type == org.apache.thrift.protocol.TType.I32) {
              struct.min_compaction_threshold = iprot.readI32();
              struct.setMin_compaction_thresholdIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 18: // MAX_COMPACTION_THRESHOLD
            if (schemeField.type == org.apache.thrift.protocol.TType.I32) {
              struct.max_compaction_threshold = iprot.readI32();
              struct.setMax_compaction_thresholdIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 24: // REPLICATE_ON_WRITE
            if (schemeField.type == org.apache.thrift.protocol.TType.BOOL) {
              struct.replicate_on_write = iprot.readBool();
              struct.setReplicate_on_writeIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 26: // KEY_VALIDATION_CLASS
            if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {
              struct.key_validation_class = iprot.readString();
              struct.setKey_validation_classIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 28: // KEY_ALIAS
            if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {
              struct.key_alias = iprot.readBinary();
              struct.setKey_aliasIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 29: // COMPACTION_STRATEGY
            if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {
              struct.compaction_strategy = iprot.readString();
              struct.setCompaction_strategyIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 30: // COMPACTION_STRATEGY_OPTIONS
            if (schemeField.type == org.apache.thrift.protocol.TType.MAP) {
              {
                org.apache.thrift.protocol.TMap _map113 = iprot.readMapBegin();
                struct.compaction_strategy_options = new HashMap<String,String>(2*_map113.size);
                for (int _i114 = 0; _i114 < _map113.size; ++_i114)
                {
                  String _key115; // optional
                  String _val116; // required
                  _key115 = iprot.readString();
                  _val116 = iprot.readString();
                  struct.compaction_strategy_options.put(_key115, _val116);
                }
                iprot.readMapEnd();
              }
              struct.setCompaction_strategy_optionsIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 32: // COMPRESSION_OPTIONS
            if (schemeField.type == org.apache.thrift.protocol.TType.MAP) {
              {
                org.apache.thrift.protocol.TMap _map117 = iprot.readMapBegin();
                struct.compression_options = new HashMap<String,String>(2*_map117.size);
                for (int _i118 = 0; _i118 < _map117.size; ++_i118)
                {
                  String _key119; // optional
                  String _val120; // required
                  _key119 = iprot.readString();
                  _val120 = iprot.readString();
                  struct.compression_options.put(_key119, _val120);
                }
                iprot.readMapEnd();
              }
              struct.setCompression_optionsIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 33: // BLOOM_FILTER_FP_CHANCE
            if (schemeField.type == org.apache.thrift.protocol.TType.DOUBLE) {
              struct.bloom_filter_fp_chance = iprot.readDouble();
              struct.setBloom_filter_fp_chanceIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 34: // CACHING
            if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {
              struct.caching = iprot.readString();
              struct.setCachingIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 37: // DCLOCAL_READ_REPAIR_CHANCE
            if (schemeField.type == org.apache.thrift.protocol.TType.DOUBLE) {
              struct.dclocal_read_repair_chance = iprot.readDouble();
              struct.setDclocal_read_repair_chanceIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 38: // POPULATE_IO_CACHE_ON_FLUSH
            if (schemeField.type == org.apache.thrift.protocol.TType.BOOL) {
              struct.populate_io_cache_on_flush = iprot.readBool();
              struct.setPopulate_io_cache_on_flushIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 39: // MEMTABLE_FLUSH_PERIOD_IN_MS
            if (schemeField.type == org.apache.thrift.protocol.TType.I32) {
              struct.memtable_flush_period_in_ms = iprot.readI32();
              struct.setMemtable_flush_period_in_msIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 40: // DEFAULT_TIME_TO_LIVE
            if (schemeField.type == org.apache.thrift.protocol.TType.I32) {
              struct.default_time_to_live = iprot.readI32();
              struct.setDefault_time_to_liveIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 41: // INDEX_INTERVAL
            if (schemeField.type == org.apache.thrift.protocol.TType.I32) {
              struct.index_interval = iprot.readI32();
              struct.setIndex_intervalIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 42: // SPECULATIVE_RETRY
            if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {
              struct.speculative_retry = iprot.readString();
              struct.setSpeculative_retryIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 43: // TRIGGERS
            if (schemeField.type == org.apache.thrift.protocol.TType.LIST) {
              {
                org.apache.thrift.protocol.TList _list121 = iprot.readListBegin();
                struct.triggers = new ArrayList<TriggerDef>(_list121.size);
                for (int _i122 = 0; _i122 < _list121.size; ++_i122)
                {
                  TriggerDef _elem123; // required
                  _elem123 = new TriggerDef();
                  _elem123.read(iprot);
                  struct.triggers.add(_elem123);
                }
                iprot.readListEnd();
              }
              struct.setTriggersIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 9: // ROW_CACHE_SIZE
            if (schemeField.type == org.apache.thrift.protocol.TType.DOUBLE) {
              struct.row_cache_size = iprot.readDouble();
              struct.setRow_cache_sizeIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 11: // KEY_CACHE_SIZE
            if (schemeField.type == org.apache.thrift.protocol.TType.DOUBLE) {
              struct.key_cache_size = iprot.readDouble();
              struct.setKey_cache_sizeIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 19: // ROW_CACHE_SAVE_PERIOD_IN_SECONDS
            if (schemeField.type == org.apache.thrift.protocol.TType.I32) {
              struct.row_cache_save_period_in_seconds = iprot.readI32();
              struct.setRow_cache_save_period_in_secondsIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 20: // KEY_CACHE_SAVE_PERIOD_IN_SECONDS
            if (schemeField.type == org.apache.thrift.protocol.TType.I32) {
              struct.key_cache_save_period_in_seconds = iprot.readI32();
              struct.setKey_cache_save_period_in_secondsIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 21: // MEMTABLE_FLUSH_AFTER_MINS
            if (schemeField.type == org.apache.thrift.protocol.TType.I32) {
              struct.memtable_flush_after_mins = iprot.readI32();
              struct.setMemtable_flush_after_minsIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 22: // MEMTABLE_THROUGHPUT_IN_MB
            if (schemeField.type == org.apache.thrift.protocol.TType.I32) {
              struct.memtable_throughput_in_mb = iprot.readI32();
              struct.setMemtable_throughput_in_mbIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 23: // MEMTABLE_OPERATIONS_IN_MILLIONS
            if (schemeField.type == org.apache.thrift.protocol.TType.DOUBLE) {
              struct.memtable_operations_in_millions = iprot.readDouble();
              struct.setMemtable_operations_in_millionsIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 25: // MERGE_SHARDS_CHANCE
            if (schemeField.type == org.apache.thrift.protocol.TType.DOUBLE) {
              struct.merge_shards_chance = iprot.readDouble();
              struct.setMerge_shards_chanceIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 27: // ROW_CACHE_PROVIDER
            if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {
              struct.row_cache_provider = iprot.readString();
              struct.setRow_cache_providerIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 31: // ROW_CACHE_KEYS_TO_SAVE
            if (schemeField.type == org.apache.thrift.protocol.TType.I32) {
              struct.row_cache_keys_to_save = iprot.readI32();
              struct.setRow_cache_keys_to_saveIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          default:
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      struct.validate();
    }

