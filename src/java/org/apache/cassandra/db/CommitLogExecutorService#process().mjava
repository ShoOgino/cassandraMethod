    void process()
    {
        while (queue.isEmpty())
        {
            try
            {
                Thread.sleep(1);
            }
            catch (InterruptedException e)
            {
                throw new RuntimeException(e);
            }
        }

        // attempt to do a bunch of LogRecordAdder ops before syncing
        incompleteTasks.clear();
        taskValues.clear();
        while (!queue.isEmpty()
               && queue.peek().getRawCallable() instanceof CommitLog.LogRecordAdder
               && incompleteTasks.size() < 20)
        {
            CheaterFutureTask task = queue.remove();
            incompleteTasks.add(task);
            try
            {
                taskValues.add(task.getRawCallable().call());
            }
            catch (Exception e)
            {
                // it doesn't seem worth bothering future-izing the exception
                // since if a commitlog op throws, we're probably screwed anyway
                throw new RuntimeException(e);
            }
        }

        if (incompleteTasks.size() == 0)
        {
            // no LRAs; just run the task
            queue.remove().run();
        }
        else
        {
            // now sync and set the tasks' values (which allows thread calling get() to proceed)
            try
            {
                CommitLog.open().sync();
            }
            catch (IOException e)
            {
                throw new RuntimeException(e);
            }
            for (int i = 0; i < incompleteTasks.size(); i++)
            {
                incompleteTasks.get(i).set(taskValues.get(i));
            }
        }
    }

