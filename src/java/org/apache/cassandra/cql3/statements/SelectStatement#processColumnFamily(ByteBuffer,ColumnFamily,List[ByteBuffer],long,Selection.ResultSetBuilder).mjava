    // Used by ModificationStatement for CAS operations
    void processColumnFamily(ByteBuffer key, ColumnFamily cf, List<ByteBuffer> variables, long now, Selection.ResultSetBuilder result)
    throws InvalidRequestException
    {
        ByteBuffer[] keyComponents = cfm.getKeyValidator() instanceof CompositeType
                                   ? ((CompositeType)cfm.getKeyValidator()).split(key)
                                   : new ByteBuffer[]{ key };

        if (parameters.isDistinct)
        {
            if (!cf.hasOnlyTombstones(now))
            {
                result.newRow();
                // selection.getColumnsList() will contain only the partition key components - all of them.
                for (ColumnDefinition def : selection.getColumnsList())
                    result.add(keyComponents[def.position()]);
            }
        }
        else if (cfm.isDense())
        {
            // One cqlRow per column
            for (Column c : columnsInOrder(cf, variables))
            {
                if (c.isMarkedForDelete(now))
                    continue;

                ByteBuffer[] components = null;
                if (cfm.hasCompositeComparator())
                {
                    components = ((CompositeType)cfm.comparator).split(c.name());
                }
                else if (sliceRestriction != null)
                {
                    // For dynamic CF, the column could be out of the requested bounds, filter here
                    if (!sliceRestriction.isInclusive(Bound.START) && c.name().equals(sliceRestriction.bound(Bound.START, variables)))
                        continue;
                    if (!sliceRestriction.isInclusive(Bound.END) && c.name().equals(sliceRestriction.bound(Bound.END, variables)))
                        continue;
                }

                result.newRow();
                // Respect selection order
                for (ColumnDefinition def : selection.getColumnsList())
                {
                    switch (def.kind)
                    {
                        case PARTITION_KEY:
                            result.add(keyComponents[def.position()]);
                            break;
                        case CLUSTERING_COLUMN:
                            ByteBuffer val = cfm.hasCompositeComparator()
                                           ? (def.position() < components.length ? components[def.position()] : null)
                                           : c.name();
                            result.add(val);
                            break;
                        case COMPACT_VALUE:
                            result.add(c);
                            break;
                        case REGULAR:
                            // This should not happen for compact CF
                            throw new AssertionError();
                        default:
                            throw new AssertionError();
                    }
                }
            }
        }
        else if (cfm.hasCompositeComparator())
        {
            // Sparse case: group column in cqlRow when composite prefix is equal
            CompositeType composite = (CompositeType)cfm.comparator;

            ColumnGroupMap.Builder builder = new ColumnGroupMap.Builder(composite, cfm.hasCollections(), now);

            for (Column c : cf)
            {
                if (c.isMarkedForDelete(now))
                    continue;

                builder.add(c);
            }

            for (ColumnGroupMap group : builder.groups())
                handleGroup(selection, result, keyComponents, group);
        }
        else
        {
            if (cf.hasOnlyTombstones(now))
                return;

            // Static case: One cqlRow for all columns
            result.newRow();
            for (ColumnDefinition def : selection.getColumnsList())
            {
                if (def.kind == ColumnDefinition.Kind.PARTITION_KEY)
                    result.add(keyComponents[def.position()]);
                else
                    result.add(cf.getColumn(def.name.bytes));
            }
        }
    }

