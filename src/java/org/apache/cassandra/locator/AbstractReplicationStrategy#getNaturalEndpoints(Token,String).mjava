    /**
     * get the (possibly cached) endpoints that should store the given Token, for the given table.
     * Note that while the endpoints are conceptually a Set (no duplicates will be included),
     * we return a List to avoid an extra allocation when sorting by proximity later
     * @param searchToken the token the natural endpoints are requested for
     * @param table the table the natural endpoints are requested for
     * @return a copy of the natural endpoints for the given token and table
     * @throws IllegalStateException if the number of requested replicas is greater than the number of known endpints
     */
    public ArrayList<InetAddress> getNaturalEndpoints(Token searchToken, String table) throws IllegalStateException
    {
        int replicas = getReplicationFactor(table);
        Token keyToken = TokenMetadata.firstToken(tokenMetadata.sortedTokens(), searchToken);
        EndpointCacheKey cacheKey = new EndpointCacheKey(table, keyToken);
        ArrayList<InetAddress> endpoints = cachedEndpoints.get(cacheKey);
        if (endpoints == null)
        {
            TokenMetadata tokenMetadataClone = tokenMetadata.cloneOnlyTokenMap();
            keyToken = TokenMetadata.firstToken(tokenMetadataClone.sortedTokens(), searchToken);
            cacheKey = new EndpointCacheKey(table, keyToken);
            endpoints = new ArrayList<InetAddress>(calculateNaturalEndpoints(searchToken, tokenMetadataClone, table));
            cachedEndpoints.put(cacheKey, endpoints);
        }

        // calculateNaturalEndpoints should have checked this already, this is a safety
        assert replicas <= endpoints.size();

        return new ArrayList<InetAddress>(endpoints);
    }

