    public boolean markCompacting(AbstractCompactionTask task, int min, int max)
    {
        Collection<SSTableReader> sstablesToMark = task.getSSTables();
        if (sstablesToMark == null || sstablesToMark.isEmpty())
            return false;

        if (max < min || max < 1)
            return false;

        View currentView, newView;
        // order preserving set copy of the input
        Set<SSTableReader> remaining = new LinkedHashSet<SSTableReader>(sstablesToMark);
        do
        {
            currentView = view.get();

            // find the subset that is active and not already compacting
            remaining.removeAll(currentView.compacting);
            remaining.retainAll(currentView.sstables);
            if (remaining.size() < min || remaining.size() > max)
                // cannot meet the min and max threshold
                return false;

            newView = currentView.markCompacting(sstablesToMark);
        }
        while (!view.compareAndSet(currentView, newView));
        return true;
    }

