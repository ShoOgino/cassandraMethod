    /**
     * Returns a new BTree with the provided set inserting/replacing as necessary any equal items
     *
     * @param btree              the tree to update
     * @param comparator         the comparator that defines the ordering over the items in the tree
     * @param updateWith         the items to either insert / update
     * @param updateWithIsSorted if false, updateWith will be copied and sorted to facilitate construction
     * @param replaceF           a function to apply to a pair we are swapping
     * @param terminateEarly     a function that returns Boolean.TRUE if we should terminate before finishing our work.
     *                           the argument to terminateEarly is ignored.
     * @param <V>
     * @return
     */
    public static <V> Object[] update(Object[] btree,
                                      Comparator<V> comparator,
                                      Collection<V> updateWith,
                                      boolean updateWithIsSorted,
                                      ReplaceFunction<V> replaceF,
                                      Function<?, Boolean> terminateEarly)
    {
        if (btree.length == 0)
            return build(updateWith, comparator, updateWithIsSorted);

        if (!updateWithIsSorted)
            updateWith = sorted(updateWith, comparator, updateWith.size());

        // if the b-tree is just a single root node, we can try a quick in-place merge
        if (isLeaf(btree) && btree.length + updateWith.size() < QUICK_MERGE_LIMIT)
        {
            // since updateWith is sorted, we can skip elements from earlier iterations tracked by this offset
            int btreeOffset = 0;
            int keyEnd = getLeafKeyEnd(btree);
            Object[] merged = new Object[QUICK_MERGE_LIMIT];
            int mergedCount = 0;
            for (V v : updateWith)
            {
                // find the index i where v would belong in the original btree
                int i = find(comparator, v, btree, btreeOffset, keyEnd);
                boolean found = i >= 0;
                if (!found)
                    i = -i - 1;

                // copy original elements up to i into the merged array
                int count = i - btreeOffset;
                if (count > 0)
                {
                    System.arraycopy(btree, btreeOffset, merged, mergedCount, count);
                    mergedCount += count;
                    btreeOffset = i;
                }

                if (found)
                {
                    // apply replaceF if it matches an existing element
                    btreeOffset++;
                    if (replaceF != null)
                        v = replaceF.apply((V) btree[i], v);
                }
                else if (replaceF != null)
                {
                    // new element but still need to apply replaceF to handle indexing and size-tracking
                    v = replaceF.apply(null, v);
                }

                merged[mergedCount++] = v;
            }

            // copy any remaining original elements
            if (btreeOffset < keyEnd)
            {
                int count = keyEnd - btreeOffset;
                System.arraycopy(btree, btreeOffset, merged, mergedCount, count);
                mergedCount += count;
            }

            if (mergedCount > FAN_FACTOR)
            {
                // TODO this code will never execute since QUICK_MERGE_LIMIT == FAN_FACTOR
                int mid = (mergedCount >> 1) & ~1; // divide by two, rounding down to an even number
                return new Object[] { merged[mid],
                                      Arrays.copyOfRange(merged, 0, mid),
                                      Arrays.copyOfRange(merged, 1 + mid, mergedCount + ((mergedCount + 1) & 1)), };
            }

            return Arrays.copyOfRange(merged, 0, mergedCount + (mergedCount & 1));
        }

        return modifier.get().update(btree, comparator, updateWith, replaceF, terminateEarly);
    }

