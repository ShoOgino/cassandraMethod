    /**
     * drop a column family. blockOnDeletion was added to make testing simpler.
     */
    public static Future drop(final CFMetaData cfm, final boolean blockOnFileDeletion)
    {
        return executor.submit(new WrappedRunnable() 
        {
            protected void runMayThrow() throws Exception
            {
                KSMetaData ksm = DatabaseDescriptor.getTableDefinition(cfm.tableName);
                if (ksm == null)
                    throw new ConfigurationException("Keyspace does not already exist.");
                else if (!ksm.cfMetaData().containsKey(cfm.cfName))
                    throw new ConfigurationException("CF is not defined in that keyspace.");
                
                // clone ksm but do not include the new def
                List<CFMetaData> newCfs = new ArrayList<CFMetaData>(ksm.cfMetaData().values());
                newCfs.remove(cfm);
                assert newCfs.size() == ksm.cfMetaData().size() - 1;
                ksm = new KSMetaData(ksm.name, ksm.strategyClass, ksm.replicationFactor, ksm.snitch, newCfs.toArray(new CFMetaData[newCfs.size()]));
                
                // store it.
                UUID newVersion = saveKeyspaceDefinition(ksm);
                
                // reinitialize the table.
                CFMetaData.purge(cfm);
                DatabaseDescriptor.setTableDefinition(ksm, newVersion);
                Table.open(ksm.name).dropCf(cfm.cfName);
                
                // indicate that some files need to be deleted (eventually)
                SystemTable.markForRemoval(cfm);
                
                // we don't really need a new segment, but let's force it to be consistent with other operations.
                CommitLog.instance().forceNewSegment();
        
                cleanupDeadFiles(blockOnFileDeletion);    
            }
        });
    }

