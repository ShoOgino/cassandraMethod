    /**
     * This function executes local and remote reads, and blocks for the results:
     *
     * 1. Get the replica locations, sorted by response time according to the snitch
     * 2. Send a data request to the closest replica, and digest requests to either
     *    a) all the replicas, if read repair is enabled
     *    b) the closest R-1 replicas, where R is the number required to satisfy the ConsistencyLevel
     * 3. Wait for a response from R replicas
     * 4. If the digests (if any) match the data return the data
     * 5. else carry out read repair by getting data from all the nodes.
     */
    private static List<Row> fetchRows(List<ReadCommand> commands, ConsistencyLevel consistency_level) throws IOException, UnavailableException, TimeoutException
    {
        List<ReadCallback<Row>> readCallbacks = new ArrayList<ReadCallback<Row>>();
        List<List<InetAddress>> commandEndpoints = new ArrayList<List<InetAddress>>();
        List<Row> rows = new ArrayList<Row>();
        Set<ReadCommand> repairs = new HashSet<ReadCommand>();

        // send out read requests
        for (ReadCommand command: commands)
        {
            assert !command.isDigestQuery();

            List<InetAddress> endpoints = StorageService.instance.getLiveNaturalEndpoints(command.table, command.key);
            DatabaseDescriptor.getEndpointSnitch().sortByProximity(FBUtilities.getLocalAddress(), endpoints);

            ReadResponseResolver resolver = new ReadResponseResolver(command.table, command.key);
            ReadCallback<Row> handler = getReadCallback(resolver, command.table, consistency_level);
            handler.assureSufficientLiveNodes(endpoints);

            // if we're not going to read repair, cut the endpoints list down to the ones required to satisfy ConsistencyLevel
            if (randomlyReadRepair(command))
            {
                if (endpoints.size() > handler.blockfor)
                    repairs.add(command);
            }
            else
            {
                endpoints = endpoints.subList(0, handler.blockfor);
            }

            // The data-request message is sent to dataPoint, the node that will actually get
            // the data for us. The other replicas are only sent a digest query.
            ReadCommand digestCommand = null;
            if (endpoints.size() > 1)
            {
                digestCommand = command.copy();
                digestCommand.setDigestQuery(true);
            }

            InetAddress dataPoint = endpoints.get(0);
            if (dataPoint.equals(FBUtilities.getLocalAddress()))
            {
                if (logger.isDebugEnabled())
                    logger.debug("reading data for " + command + " locally");
                StageManager.getStage(Stage.READ).execute(new LocalReadRunnable(command, handler));
            }
            else
            {
                Message message = command.makeReadMessage();
                if (logger.isDebugEnabled())
                    logger.debug("reading data for " + command + " from " + message.getMessageId() + "@" + dataPoint);
                MessagingService.instance().sendRR(message, dataPoint, handler);
            }

            // We lazy-construct the digest Message object since it may not be necessary if we
            // are doing a local digest read, or no digest reads at all.
            Message digestMessage = null;
            for (InetAddress digestPoint : endpoints.subList(1, endpoints.size()))
            {
                if (digestPoint.equals(FBUtilities.getLocalAddress()))
                {
                    if (logger.isDebugEnabled())
                        logger.debug("reading digest for " + command + " locally");
                    StageManager.getStage(Stage.READ).execute(new LocalReadRunnable(digestCommand, handler));
                }
                else
                {
                    if (digestMessage == null)
                        digestMessage = digestCommand.makeReadMessage();
                    if (logger.isDebugEnabled())
                        logger.debug("reading digest for " + command + " from " + digestMessage.getMessageId() + "@" + digestPoint);
                    MessagingService.instance().sendRR(digestMessage, digestPoint, handler);
                }
            }

            readCallbacks.add(handler);
            commandEndpoints.add(endpoints);
        }

        // read results and make a second pass for any digest mismatches
        List<RepairCallback<Row>> repairResponseHandlers = null;
        for (int i = 0; i < commands.size(); i++)
        {
            ReadCallback<Row> readCallback = readCallbacks.get(i);
            Row row;
            ReadCommand command = commands.get(i);
            List<InetAddress> endpoints = commandEndpoints.get(i);
            try
            {
                long startTime2 = System.currentTimeMillis();
                row = readCallback.get(); // CL.ONE is special cased here to ignore digests even if some have arrived
                if (row != null)
                    rows.add(row);

                if (logger.isDebugEnabled())
                    logger.debug("Read: " + (System.currentTimeMillis() - startTime2) + " ms.");

                if (repairs.contains(command))
                    repairExecutor.schedule(new RepairRunner(readCallback.resolver, command, endpoints), DatabaseDescriptor.getRpcTimeout(), TimeUnit.MILLISECONDS);
            }
            catch (DigestMismatchException ex)
            {
                if (logger.isDebugEnabled())
                    logger.debug("Digest mismatch:", ex);
                RepairCallback<Row> handler = repair(command, endpoints);
                if (repairResponseHandlers == null)
                    repairResponseHandlers = new ArrayList<RepairCallback<Row>>();
                repairResponseHandlers.add(handler);
            }
        }

        // read the results for the digest mismatch retries
        if (repairResponseHandlers != null)
        {
            for (RepairCallback<Row> handler : repairResponseHandlers)
            {
                try
                {
                    Row row = handler.get();
                    if (row != null)
                        rows.add(row);
                }
                catch (DigestMismatchException e)
                {
                    throw new AssertionError(e); // full data requested from each node here, no digests should be sent
                }
            }
        }

        return rows;
    }

