    private boolean updateDefinition(CFMetaData cfm, ColumnDefinition def, String keyspace, ByteBuffer toReplace, UserType updated)
    {
        AbstractType<?> t = updateWith(def.type, keyspace, toReplace, updated);
        if (t == null)
            return false;

        // We need to update this validator ...
        cfm.addOrReplaceColumnDefinition(def.withNewType(t));

        // ... but if it's part of the comparator or key validator, we need to go update those too.
        switch (def.kind)
        {
            case PARTITION_KEY:
                cfm.keyValidator(updateWith(cfm.getKeyValidator(), keyspace, toReplace, updated));
                break;
            case CLUSTERING_COLUMN:
                cfm.comparator = CellNames.fromAbstractType(updateWith(cfm.comparator.asAbstractType(), keyspace, toReplace, updated), cfm.comparator.isDense());
                break;
            default:
                // If it's a collection, we still want to modify the comparator because the collection is aliased in it
                if (def.type instanceof CollectionType && def.type.isMultiCell())
                {
                    t = updateWith(cfm.comparator.asAbstractType(), keyspace, toReplace, updated);
                    // If t == null, all relevant comparators were updated via updateWith, which reaches into types and
                    // collections
                    if (t != null)
                        cfm.comparator = CellNames.fromAbstractType(t, cfm.comparator.isDense());
                }
                break;
        }
        return true;
    }

