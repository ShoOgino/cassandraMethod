    /**
     * Performs blocking or timed wait for a task, depending on current
     * configuration settings, or returns null if this worker must exit because
     * of any of: 1. There are more than maximumPoolSize workers (due to a call
     * to setMaximumPoolSize). 2. The pool is stopped. 3. The pool is shutdown
     * and the queue is empty. 4. This worker timed out waiting for a task, and
     * timed-out workers are subject to termination (that is,
     * {@code allowCoreThreadTimeOut || workerCount > corePoolSize}) both
     * before and after the timed wait.
     * 
     * @return task, or null if the worker must exit, in which case workerCount
     *         is decremented
     */
    private Runnable getTask()
    {
        boolean timedOut = false; // Did the last poll() time out?

        retry: for (;;)
        {
            int c = ctl.get();
            int rs = runStateOf(c);

            // Check if queue empty only if necessary.
            if (rs >= SHUTDOWN && (rs >= STOP || workQueue.isEmpty()))
            {
                decrementWorkerCount();
                return null;
            }

            boolean timed; // Are workers subject to culling?

            for (;;)
            {
                int wc = workerCountOf(c);
                timed = allowCoreThreadTimeOut || wc > corePoolSize;

                if (wc <= maximumPoolSize && !(timedOut && timed))
                    break;
                if (compareAndDecrementWorkerCount(c))
                    return null;
                c = ctl.get(); // Re-read ctl
                if (runStateOf(c) != rs)
                    continue retry;
                // else CAS failed due to workerCount change; retry inner loop
            }

            try
            {
                Runnable r = timed ? workQueue.poll(keepAliveTime,
                        TimeUnit.NANOSECONDS) : workQueue.take();
                if (r != null)
                    return r;
                timedOut = true;
            }
            catch (InterruptedException retry)
            {
                timedOut = false;
            }
        }
    }

