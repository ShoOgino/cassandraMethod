    /**
     * if columnNameComparator is CompositeType the columns are compared by components using the subcomparator
     * on the same position.
     *
     * if comparator is not CompositeType, the lists are assumed to be of max size 1 and compared using the comparator
     * directly.
     *
     * @param minColumnNames lhs
     * @param candidates rhs
     * @param columnNameComparator comparator to use
     * @return a list with smallest column names according to (sub)comparator
     */
    public static List<ByteBuffer> mergeMin(List<ByteBuffer> minColumnNames, List<ByteBuffer> candidates, AbstractType<?> columnNameComparator)
    {
        if (minColumnNames.size() == 0)
            return candidates;

        if (candidates.size() == 0)
            return minColumnNames;

        if (columnNameComparator instanceof CompositeType)
        {
            CompositeType ct = (CompositeType)columnNameComparator;
            List<ByteBuffer> retList = new ArrayList<ByteBuffer>(ct.types.size());
            for (int i = 0; i < minColumnNames.size(); i++)
            {
                retList.add(min(minColumnNames.get(i), candidates.get(i), ct.types.get(i)));
            }
            return retList;
        }
        else
        {
            return Collections.singletonList(min(minColumnNames.get(0), candidates.get(0), columnNameComparator));
        }
    }

