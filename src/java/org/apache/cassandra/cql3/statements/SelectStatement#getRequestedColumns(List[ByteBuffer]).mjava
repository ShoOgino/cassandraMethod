    private SortedSet<ByteBuffer> getRequestedColumns(List<ByteBuffer> variables) throws InvalidRequestException
    {
        // Note: getRequestedColumns don't handle static columns, but due to CASSANDRA-5762
        // we always do a slice for CQL3 tables, so it's ok to ignore them here
        assert !isColumnRange();

        ColumnNameBuilder builder = cfDef.getColumnNameBuilder();
        Iterator<CFDefinition.Name> idIter = cfDef.clusteringColumns().iterator();
        for (Restriction r : columnRestrictions)
        {
            CFDefinition.Name name = idIter.next();
            assert r != null && !r.isSlice();

            if (r.isEQ())
            {
                List<ByteBuffer> values = r.values(variables);
                ByteBuffer val = values.get(0);
                if (val == null)
                    throw new InvalidRequestException(String.format("Invalid null value for clustering key part %s", name.name));
                builder.add(val);
            }
            else
            {
                if (!r.isMultiColumn())
                {
                    // We have a IN, which we only support for the last column.
                    // If compact, just add all values and we're done. Otherwise,
                    // for each value of the IN, creates all the columns corresponding to the selection.
                    List<ByteBuffer> values = r.values(variables);
                    if (values.isEmpty())
                        return null;
                    SortedSet<ByteBuffer> columns = new TreeSet<ByteBuffer>(cfDef.cfm.comparator);
                    Iterator<ByteBuffer> iter = values.iterator();
                    while (iter.hasNext())
                    {
                        ByteBuffer val = iter.next();
                        ColumnNameBuilder b = iter.hasNext() ? builder.copy() : builder;
                        if (val == null)
                            throw new InvalidRequestException(String.format("Invalid null value for clustering key part %s", name.name));
                        b.add(val);
                        if (cfDef.isCompact)
                            columns.add(b.build());
                        else
                            columns.addAll(addSelectedColumns(b));
                    }
                    return columns;
                }
                else
                {
                    // we have a multi-column IN restriction
                    List<List<ByteBuffer>> values = ((MultiColumnRestriction.IN) r).splitValues(variables);
                    if (values.isEmpty())
                        return null;
                    TreeSet<ByteBuffer> inValues = new TreeSet<>(cfDef.cfm.comparator);
                    for (List<ByteBuffer> components : values)
                    {
                        ColumnNameBuilder b = builder.copy();
                        for (int i = 0; i < components.size(); i++)
                        {
                            if (components.get(i) == null)
                            {
                                List<CFDefinition.Name> clusteringCols = new ArrayList<>(cfDef.clusteringColumns());
                                throw new InvalidRequestException("Invalid null value in condition for clustering column " + clusteringCols.get(i + name.position));
                            }
                            b.add(components.get(i));
                        }
                        if (cfDef.isCompact)
                            inValues.add(b.build());
                        else
                            inValues.addAll(addSelectedColumns(b));
                    }
                    return inValues;
                }
            }
        }

        return addSelectedColumns(builder);
    }

