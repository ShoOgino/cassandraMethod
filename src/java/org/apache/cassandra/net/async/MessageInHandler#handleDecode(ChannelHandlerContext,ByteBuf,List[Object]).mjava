    /**
     * For each new message coming in, builds up a {@link MessageHeader} instance incrementally. This method
     * attempts to deserialize as much header information as it can out of the incoming {@link ByteBuf}, and
     * maintains a trivial state machine to remember progress across invocations.
     */
    @SuppressWarnings("resource")
    public void handleDecode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception
    {
        ByteBufDataInputPlus inputPlus = new ByteBufDataInputPlus(in);
        while (true)
        {
            switch (state)
            {
                case READ_FIRST_CHUNK:
                    MessageHeader header = readFirstChunk(in);
                    if (header == null)
                        return;
                    header.from = peer;
                    messageHeader = header;
                    state = State.READ_VERB;
                    // fall-through
                case READ_VERB:
                    if (in.readableBytes() < VERB_LENGTH)
                        return;
                    messageHeader.verb = MessagingService.Verb.fromId(in.readInt());
                    state = State.READ_PARAMETERS_SIZE;
                    // fall-through
                case READ_PARAMETERS_SIZE:
                    long length = VIntCoding.readUnsignedVInt(in);
                    if (length < 0)
                        return;
                    messageHeader.parameterLength = (int) length;
                    messageHeader.parameters = messageHeader.parameterLength == 0 ? Collections.emptyMap() : new EnumMap<>(ParameterType.class);
                    state = State.READ_PARAMETERS_DATA;
                    // fall-through
                case READ_PARAMETERS_DATA:
                    if (messageHeader.parameterLength > 0)
                    {
                        if (in.readableBytes() < messageHeader.parameterLength)
                            return;
                        readParameters(in, inputPlus, messagingVersion, messageHeader.parameterLength, messageHeader.parameters);
                    }
                    state = State.READ_PAYLOAD_SIZE;
                    // fall-through
                case READ_PAYLOAD_SIZE:
                    length = VIntCoding.readUnsignedVInt(in);
                    if (length < 0)
                        return;
                    messageHeader.payloadSize = (int) length;
                    state = State.READ_PAYLOAD;
                    // fall-through
                case READ_PAYLOAD:
                    if (in.readableBytes() < messageHeader.payloadSize)
                        return;

                    // TODO consider deserializing the message not on the event loop
                    MessageIn<Object> messageIn = MessageIn.read(inputPlus, messagingVersion,
                                                                     messageHeader.messageId, messageHeader.constructionTime, messageHeader.from,
                                                                     messageHeader.payloadSize, messageHeader.verb, messageHeader.parameters);

                    if (messageIn != null)
                        messageConsumer.accept(messageIn, messageHeader.messageId);

                    state = State.READ_FIRST_CHUNK;
                    messageHeader = null;
                    break;
                default:
                    throw new IllegalStateException("unknown/unhandled state: " + state);
            }
        }
    }

