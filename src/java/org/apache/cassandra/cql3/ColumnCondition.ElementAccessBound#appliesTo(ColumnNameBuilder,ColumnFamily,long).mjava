        public boolean appliesTo(ColumnNameBuilder rowPrefix, ColumnFamily current, final long now) throws InvalidRequestException
        {
            if (collectionElement == null)
                throw new InvalidRequestException("Invalid null value for " + (column.type instanceof MapType ? "map" : "list") + " element access");

            ColumnNameBuilder collectionPrefix = copyOrUpdatePrefix(current.metadata(), rowPrefix).add(column.name.key);
            if (column.type instanceof MapType)
                return equalsValue(value, current.getColumn(collectionPrefix.add(collectionElement).build()), ((MapType)column.type).values, now);

            assert column.type instanceof ListType;
            int idx = ByteBufferUtil.toInt(collectionElement);
            if (idx < 0)
                throw new InvalidRequestException(String.format("Invalid negative list index %d", idx));

            Iterator<Column> iter = collectionColumns(collectionPrefix, current, now);
            int adv = Iterators.advance(iter, idx);
            if (adv != idx || !iter.hasNext())
                throw new InvalidRequestException(String.format("List index %d out of bound, list has size %d", idx, adv));

            // We don't support null values inside collections, so a condition like 'IF l[3] = null' can only
            // be false. We do special case though, as the compare below might mind getting a null.
            if (value == null)
                return false;

            return ((ListType)column.type).elements.compare(iter.next().value(), value) == 0;
        }

