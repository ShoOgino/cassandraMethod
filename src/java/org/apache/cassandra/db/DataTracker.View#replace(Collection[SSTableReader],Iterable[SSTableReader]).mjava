        View replace(Collection<SSTableReader> oldSSTables, Iterable<SSTableReader> replacements)
        {
            ImmutableSet<SSTableReader> oldSet = ImmutableSet.copyOf(oldSSTables);
            int newSSTablesSize = shadowed.size() + sstables.size() - oldSSTables.size() + Iterables.size(replacements);
            assert newSSTablesSize >= Iterables.size(replacements) : String.format("Incoherent new size %d replacing %s by %s in %s", newSSTablesSize, oldSSTables, replacements, this);
            Map<SSTableReader, SSTableReader> newSSTables = new HashMap<>(newSSTablesSize);
            Set<SSTableReader> newShadowed = new HashSet<>(shadowed.size());

            for (SSTableReader sstable : sstables)
                if (!oldSet.contains(sstable))
                    newSSTables.put(sstable, sstable);

            for (SSTableReader sstable : shadowed)
                if (!oldSet.contains(sstable))
                    newShadowed.add(sstable);

            for (SSTableReader replacement : replacements)
            {
                if (replacement.openReason == SSTableReader.OpenReason.SHADOWED)
                    newShadowed.add(replacement);
                else
                    newSSTables.put(replacement, replacement);
            }

            assert newSSTables.size() + newShadowed.size() == newSSTablesSize :
                String.format("Expecting new size of %d, got %d while replacing %s by %s in %s",
                          newSSTablesSize, newSSTables.size() + newShadowed.size(), oldSSTables, replacements, this);
            newShadowed = ImmutableSet.copyOf(newShadowed);
            newSSTables = ImmutableMap.copyOf(newSSTables);
            SSTableIntervalTree intervalTree = buildIntervalTree(newSSTables.keySet());
            return new View(liveMemtables, flushingMemtables, newSSTables, compacting, newShadowed, intervalTree);
        }

