        protected ChannelFuture write0(QueuedMessage message)
        {
            long pendingCount = pendingMessageCount.incrementAndGet();
            ChannelFuture future = channel.write(message);
            strategy.newArrival(message);

            // if we lost the race to set the state, simply write to the channel (no flush)
            if (!scheduledFlush.compareAndSet(false, true))
                return future;

            long flushDelayNanos;
            // if we've hit the minimum number of messages for coalescing or we've run out of coalesce time, flush.
            // note: we check the exact count, instead of greater than or equal to, of message here to prevent a flush task
            // for each message (if there's messages coming in on multiple threads). There will be, of course, races
            // with the consumer decrementing the pending counter, but that's still less excessive flushes.
            if (pendingCount == minMessagesForCoalesce || (flushDelayNanos = strategy.currentCoalescingTimeNanos()) <= 0)
            {
                scheduledFlush.set(false);
                channel.flush();
            }
            else
            {
                // calling schedule() on the eventLoop will force it to wake up (if not already executing) and schedule the task
                channel.eventLoop().schedule(() -> {
                    // NOTE: this executes on the event loop
                    scheduledFlush.set(false);
                    // we execute() the flush() as an additional task rather than immediately in-line as there is a
                    // race condition when this task runs (executing on the event loop) and a thread that writes the channel (top of this method).
                    // If this task is picked up but before the scheduledFlush falg is flipped, the other thread writes
                    // and then checks the scheduledFlush (which is still true) and exits.
                    // This task changes the flag and if it calls flush() in-line, and netty flushs everything immediately (that is, what's been serialized)
                    // to the transport as we're on the event loop. The other thread's write became a task that executes *after* this task in the netty queue,
                    // and if there's not a subsequent followup flush scheduled, that write can be orphaned until another write comes in.
                    channel.eventLoop().execute(channel::flush);
                }, flushDelayNanos, TimeUnit.NANOSECONDS);
            }
            return future;
        }

