    /**
     * Run an operation over all sstables using jobs threads
     *
     * @param cfs the column family store to run the operation on
     * @param operation the operation to run
     * @param jobs the number of threads to use - 0 means use all available. It never uses more than concurrent_compactors threads
     * @return status of the operation
     * @throws ExecutionException
     * @throws InterruptedException
     */
    private AllSSTableOpStatus parallelAllSSTableOperation(final ColumnFamilyStore cfs, final OneSSTableOperation operation, int jobs) throws ExecutionException, InterruptedException
    {
        Iterable<SSTableReader> compactingSSTables = cfs.markAllCompacting();
        if (compactingSSTables == null)
        {
            logger.info("Aborting operation on {}.{} after failing to interrupt other compaction operations", cfs.keyspace.getName(), cfs.name);
            return AllSSTableOpStatus.ABORTED;
        }
        if (Iterables.isEmpty(compactingSSTables))
        {
            logger.info("No sstables for {}.{}", cfs.keyspace.getName(), cfs.name);
            return AllSSTableOpStatus.SUCCESSFUL;
        }
        Set<SSTableReader> sstables = Sets.newHashSet(operation.filterSSTables(compactingSSTables));
        Set<SSTableReader> filteredAway = Sets.difference(Sets.newHashSet(compactingSSTables), sstables);
        cfs.getDataTracker().unmarkCompacting(filteredAway);
        final Set<SSTableReader> finished = Sets.newConcurrentHashSet();

        List<Future<Object>> futures = new ArrayList<>();
        try
        {
            for (final SSTableReader sstable : sstables)
            {
                if (executor.isShutdown())
                {
                    logger.info("Executor has shut down, not submitting task");
                    return AllSSTableOpStatus.ABORTED;
                }

                Callable<Object> callable = new Callable<Object>()
                {
                    @Override
                    public Object call() throws Exception
                    {
                        try
                        {
                            operation.execute(sstable);
                        }
                        finally
                        {
                            cfs.getDataTracker().unmarkCompacting(Collections.singleton(sstable));
                            finished.add(sstable);
                        }
                        return this;
                    }
                };
                futures.add(executor.submit(callable));
                if (jobs > 0 && futures.size() == jobs)
                {
                    FBUtilities.waitOnFutures(futures);
                    futures.clear();
                }
            }
            FBUtilities.waitOnFutures(futures);
        }
        finally
        {
            cfs.getDataTracker().unmarkCompacting(Sets.difference(sstables, finished));
        }
        return AllSSTableOpStatus.SUCCESSFUL;
    }

