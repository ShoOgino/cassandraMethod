    public static void insertBlocking(final RowMutation rm, int consistency_level) throws UnavailableException
    {
        long startTime = System.currentTimeMillis();
        try
        {
            List<InetAddress> naturalEndpoints = StorageService.instance().getNaturalEndpoints(rm.key());
            Map<InetAddress, InetAddress> endpointMap = StorageService.instance().getHintedEndpointMap(rm.key(), naturalEndpoints);
            int blockFor = determineBlockFor(naturalEndpoints.size(), endpointMap.size(), consistency_level);

            // avoid starting a write we know can't achieve the required consistency
            int liveNodes = 0;
            for (Map.Entry<InetAddress, InetAddress> entry : endpointMap.entrySet())
            {
                if (entry.getKey().equals(entry.getValue()))
                {
                    liveNodes++;
                }
            }
            if (liveNodes < blockFor)
            {
                throw new UnavailableException();
            }

            // send out the writes, as in insert() above, but this time with a callback that tracks responses
            final WriteResponseHandler responseHandler = StorageService.instance().getWriteResponseHandler(blockFor, consistency_level);
            Message unhintedMessage = null;
            for (Map.Entry<InetAddress, InetAddress> entry : endpointMap.entrySet())
            {
                InetAddress target = entry.getKey();
                InetAddress hintedTarget = entry.getValue();

                if (target.equals(hintedTarget))
                {
                    if (target.equals(FBUtilities.getLocalAddress()))
                    {
                        if (logger.isDebugEnabled())
                            logger.debug("insert writing local key " + rm.key());
                        Runnable runnable = new Runnable()
                        {
                            public void run()
                            {
                                try
                                {
                                    rm.apply();
                                    responseHandler.localResponse();
                                }
                                catch (IOException e)
                                {
                                    throw new IOError(e);
                                }
                            }
                        };
                        StageManager.getStage(StageManager.mutationStage_).execute(runnable);
                    }
                    else
                    {
                        if (unhintedMessage == null)
                        {
                            unhintedMessage = rm.makeRowMutationMessage();
                            MessagingService.instance().addCallback(responseHandler, unhintedMessage.getMessageId());
                        }
                        if (logger.isDebugEnabled())
                            logger.debug("insert writing key " + rm.key() + " to " + unhintedMessage.getMessageId() + "@" + target);
                        MessagingService.instance().sendOneWay(unhintedMessage, target);
                    }
                }
                else
                {
                    // (hints aren't part of the callback since they don't count towards consistency until they are on the final destination node)
                    Message hintedMessage = rm.makeRowMutationMessage();
                    hintedMessage.addHeader(RowMutation.HINT, target.getAddress());
                    if (logger.isDebugEnabled())
                        logger.debug("insert writing key " + rm.key() + " to " + hintedMessage.getMessageId() + "@" + hintedTarget + " for " + target);
                    MessagingService.instance().sendOneWay(hintedMessage, hintedTarget);
                }
            }

            // wait for writes.  throws timeoutexception if necessary
            responseHandler.get();
        }
        catch (TimeoutException e)
        {
            throw new UnavailableException();
        }
        catch (IOException e)
        {
            throw new RuntimeException("error writing key " + rm.key(), e);
        }
        finally
        {
            writeStats.add(System.currentTimeMillis() - startTime);
        }
    }

