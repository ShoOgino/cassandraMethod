    /**
     * For each row version, compare with resolved (the superset of all row versions);
     * if it is missing anything, send a mutation to the endpoint it come from.
     */
    public static void maybeScheduleRepairs(ColumnFamily resolved, String table, DecoratedKey key, List<ColumnFamily> versions, List<InetAddress> endpoints)
    {
        for (int i = 0; i < versions.size(); i++)
        {
            ColumnFamily diffCf = ColumnFamily.diff(versions.get(i), resolved);
            if (diffCf == null) // no repair needs to happen
                continue;

            // create and send the row mutation message based on the diff
            RowMutation rowMutation = new RowMutation(table, key.key);

            AbstractType defaultValidator = diffCf.metadata().getDefaultValidator();
            if (defaultValidator.isCommutative())
                ((AbstractCommutativeType)defaultValidator).cleanContext(diffCf, endpoints.get(i));

            if (diffCf.getColumnsMap().isEmpty() && !diffCf.isMarkedForDelete())
                continue;

            rowMutation.add(diffCf);
            Message repairMessage;
            try
            {
                repairMessage = rowMutation.makeRowMutationMessage(StorageService.Verb.READ_REPAIR, Gossiper.instance.getVersion(endpoints.get(i)));
            }
            catch (IOException e)
            {
                throw new IOError(e);
            }
            MessagingService.instance().sendOneWay(repairMessage, endpoints.get(i));
        }
    }

