    /**
     * Writes a backlog of message to this {@link ChannelWriter}. This is mostly equivalent to calling
     * {@link #write(QueuedMessage, boolean)} for every message of the provided backlog queue, but
     * it ignores any coalescing, triggering a flush only once after all messages have been sent.
     *
     * @param backlog the backlog of message to send.
     * @return the count of items written to the channel from the queue.
     */
    int writeBacklog(Queue<QueuedMessage> backlog, boolean allowReconnect)
    {
        int count = 0;
        while (true)
        {
            if (!channel.isWritable())
                break;

            QueuedMessage msg = backlog.poll();
            if (msg == null)
                break;

            pendingMessageCount.incrementAndGet();
            ChannelFuture future = channel.write(msg);
            future.addListener(f -> handleMessageFuture(f, msg, allowReconnect));
            count++;
        }

        // as this is an infrequent operation, don't bother coordinating with the instance-level flush task
        if (count > 0)
            channel.flush();

        return count;
    }

