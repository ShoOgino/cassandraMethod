    /**
     * Configure the global instance of the FullQueryLogger
     * @param path Dedicated path where the FQL can store it's files.
     * @param rollCycle How often to roll FQL log segments so they can potentially be reclaimed
     * @param blocking Whether the FQL should block if the FQL falls behind or should drop log records
     * @param maxQueueWeight Maximum weight of in memory queue for records waiting to be written to the file before blocking or dropping
     * @param maxLogSize Maximum size of the rolled files to retain on disk before deleting the oldest file
     * @param cleanDirectory Indicates to clean the directory before starting FullQueryLogger or not
     * @param archiveCommand the archive command to execute on rolled log files
     * @param maxArchiveRetries max number of retries of failed archive commands
     */
    public synchronized void configure(Path path, String rollCycle, boolean blocking, int maxQueueWeight, long maxLogSize, boolean cleanDirectory, String archiveCommand, int maxArchiveRetries)
    {
        Preconditions.checkNotNull(path, "path was null");
        File pathAsFile = path.toFile();
        Preconditions.checkNotNull(rollCycle, "rollCycle was null");
        rollCycle = rollCycle.toUpperCase();

        //Exists and is a directory or can be created
        Preconditions.checkArgument((pathAsFile.exists() && pathAsFile.isDirectory()) || (!pathAsFile.exists() && pathAsFile.mkdirs()), "path exists and is not a directory or couldn't be created");
        Preconditions.checkArgument(pathAsFile.canRead() && pathAsFile.canWrite() && pathAsFile.canExecute(), "path is not readable, writable, and executable");
        Preconditions.checkNotNull(RollCycles.valueOf(rollCycle), "unrecognized roll cycle");
        Preconditions.checkArgument(maxQueueWeight > 0, "maxQueueWeight must be > 0");
        Preconditions.checkArgument(maxLogSize > 0, "maxLogSize must be > 0");
        logger.info("Attempting to configure full query logger path: {} Roll cycle: {} Blocking: {} Max queue weight: {} Max log size:{}, archive command: {}", path, rollCycle, blocking, maxQueueWeight, maxLogSize, archiveCommand);

        if (binLog != null)
        {
            logger.warn("Full query logger already configured. Ignoring requested configuration.");
            throw new IllegalStateException("Already configured");
        }

        // create the archiver before cleaning directories - ExternalArchiver will try to archive any existing file.
        BinLogArchiver archiver = Strings.isNullOrEmpty(archiveCommand) ? new DeletingArchiver(maxLogSize) : new ExternalArchiver(archiveCommand, path, maxArchiveRetries);
        if (cleanDirectory)
        {
            logger.info("Cleaning directory: {} as requested",path);
            if (path.toFile().exists())
            {
                Throwable error = cleanDirectory(path.toFile(), null);
                if (error != null)
                {
                    throw new RuntimeException(error);
                }
            }
        }
        this.path = path;
        this.blocking = blocking;
        binLog = new BinLog(path, RollCycles.valueOf(rollCycle), maxQueueWeight, archiver);
        binLog.start();
    }

