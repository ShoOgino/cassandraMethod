    private long computeTimestampForEntryDeletion(Row baseRow)
    {
        // We delete the old row with it's row entry timestamp using a shadowable deletion.
        // We must make sure that the deletion deletes everything in the entry (or the entry will
        // still show up), so we must use the bigger timestamp found in the existing row (for any
        // column included in the view at least).
        // TODO: We have a problem though: if the entry is "resurected" by a later update, we would
        // need to ensure that the timestamp for then entry then is bigger than the tombstone
        // we're just inserting, which is not currently guaranteed.
        // This is a bug for a separate ticket though.
        long timestamp = baseRow.primaryKeyLivenessInfo().timestamp();
        for (ColumnData data : baseRow)
        {
            if (!view.getDefinition().includes(data.column().name))
                continue;

            timestamp = Math.max(timestamp, data.maxTimestamp());
        }
        return timestamp;
    }

