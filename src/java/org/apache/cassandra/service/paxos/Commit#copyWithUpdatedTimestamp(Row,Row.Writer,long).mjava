    private static void copyWithUpdatedTimestamp(Row row, Row.Writer writer, long timestamp)
    {
        Rows.writeClustering(row.clustering(), writer);
        writer.writePartitionKeyLivenessInfo(row.primaryKeyLivenessInfo().withUpdatedTimestamp(timestamp));
        writer.writeRowDeletion(row.deletion());

        for (Cell cell : row)
            writer.writeCell(cell.column(), cell.isCounterCell(), cell.value(), cell.livenessInfo().withUpdatedTimestamp(timestamp), cell.path());

        for (int i = 0; i < row.columns().complexColumnCount(); i++)
        {
            ColumnDefinition c = row.columns().getComplex(i);
            DeletionTime dt = row.getDeletion(c);
            // We use t-1 to make sure that on inserting a collection literal, the deletion that comes with it does not
            // end up deleting the inserted data (see #6069)
            if (!dt.isLive())
                writer.writeComplexDeletion(c, new SimpleDeletionTime(timestamp-1, dt.localDeletionTime()));
        }
        writer.endOfRow();
    }

