    public static void serializeSuperColumnFamily(ColumnFamily scf, DataOutput out, int version) throws IOException
    {
        /*
         * There is 2 complications:
         *   1) We need to know the number of super columns in the column
         *   family to write in the header (so we do a first pass to group
         *   columns before serializing).
         *   2) For deletion infos, we need to figure out which are top-level
         *   deletions and which are super columns deletions (i.e. the
         *   subcolumns range deletions).
         */
        DeletionInfo delInfo = scf.deletionInfo();
        Map<CellName, List<Cell>> scMap = groupSuperColumns(scf);

        // Actually Serialize
        scf.getComparator().deletionInfoSerializer().serialize(new DeletionInfo(delInfo.getTopLevelDeletion()), out, version);
        out.writeInt(scMap.size());

        CellNameType subComparator = subType(scf.getComparator());
        for (Map.Entry<CellName, List<Cell>> entry : scMap.entrySet())
        {
            scf.getComparator().cellSerializer().serialize(entry.getKey(), out);

            DeletionTime delTime = delInfo.rangeCovering(entry.getKey());
            DeletionInfo scDelInfo = delTime == null ? DeletionInfo.live() : new DeletionInfo(delTime);
            DeletionTime.serializer.serialize(scDelInfo.getTopLevelDeletion(), out);

            out.writeInt(entry.getValue().size());
            ColumnSerializer serializer = subComparator.columnSerializer();
            for (Cell subCell : entry.getValue())
                serializer.serialize(subCell, out);
        }
    }

