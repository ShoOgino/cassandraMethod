    public List<Row> scan(IndexClause indexClause, IFilter dataFilter)
    {
        // TODO: use statistics to pick clause w/ highest selectivity
        // TODO even later: allow merge join instead of just one index + loop
        IndexExpression first = indexClause.expressions.get(0);
        ColumnFamilyStore indexCFS = getIndexedColumnFamilyStore(first.column_name);
        assert indexCFS != null;
        DecoratedKey indexKey = indexCFS.partitioner_.decorateKey(first.value);
        QueryFilter indexFilter = QueryFilter.getSliceFilter(indexKey,
                                                             new QueryPath(indexCFS.getColumnFamilyName()),
                                                             ArrayUtils.EMPTY_BYTE_ARRAY,
                                                             ArrayUtils.EMPTY_BYTE_ARRAY,
                                                             null,
                                                             false,
                                                             indexClause.count);

        List<Row> rows = new ArrayList<Row>();
        ColumnFamily indexRow = indexCFS.getColumnFamily(indexFilter);
        if (indexRow == null)
            return rows;

        for (byte[] dataKey : indexRow.getColumnNames())
        {
            DecoratedKey dk = partitioner_.decorateKey(dataKey);
            ColumnFamily data = getColumnFamily(new QueryFilter(dk, new QueryPath(columnFamily_), dataFilter));
            rows.add(new Row(dk, data));
        }

        // TODO apply remaining expressions

        return rows;
    }

