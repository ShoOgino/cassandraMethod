    /*
     * Inserts a new element knowing that the new element start strictly after
     * the one at index i, i.e that:
     *   - ends[i] <= start (or i == -1)
     */
    private void insertAfter(int i, ByteBuffer start, ByteBuffer end, long markedAt, int delTime)
    {
        if (i == size - 1)
        {
            addInternal(i+1, start, end, markedAt, delTime);
            return;
        }

        /*
         * We have the following intervals:
         *           i            i+1
         *   ..., [s1, e1]@t1, [s2, e2]@t2, ...
         *
         * And we want to insert X = [s, e]@t, knowing that e1 <= s.
         * We can have 2 cases:
         *  - s < s2: we rewrite X to X1=[s, s2]@t + X2=[s2, e]@t. X2 meet the weakInsertFrom() condition
         *            for i+1, and X1 is a new element between i and i+1.
         *  - s2 <= s: we're in the weakInsertFrom() case for i+1.
         */
        if (comparator.compare(start, starts[i+1]) < 0)
        {
            /*
             * If it happens the new element is fully before the current one, we insert it and
             * we're done
             */
            if (comparator.compare(end, starts[i+1]) <= 0)
            {
                addInternal(i+1, start, end, markedAt, delTime);
                return;
            }

            weakInsertFrom(i+1, starts[i+1], end, markedAt, delTime);
            addInternal(i+1, start, starts[i+1], markedAt, delTime);
        }
        else
        {
            weakInsertFrom(i+1, start, end, markedAt, delTime);
        }
    }

