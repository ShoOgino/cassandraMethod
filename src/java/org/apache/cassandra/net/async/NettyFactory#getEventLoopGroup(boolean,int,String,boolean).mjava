    /**
     * Create an {@link EventLoopGroup}, for epoll or nio. The {@code boostIoRatio} flag passes a hint to the netty
     * event loop threads to optimize comsuming all the tasks from the netty channel before checking for IO activity.
     * By default, netty will process some maximum number of tasks off it's queue before it will check for activity on
     * any of the open FDs, which basically amounts to checking for any incoming data. If you have a class of event loops
     * that that do almost *no* inbound activity (like cassandra's outbound channels), then it behooves us to have the
     * outbound netty channel consume as many tasks as it can before making the system calls to check up on the FDs,
     * as we're not expecting any incoming data on those sockets, anyways. Thus, we pass the magic value {@code 100}
     * to achieve the maximum consuption from the netty queue. (for implementation details, as of netty 4.1.8,
     * see {@link io.netty.channel.epoll.EpollEventLoop#run()}.
     */
    static EventLoopGroup getEventLoopGroup(boolean useEpoll, int threadCount, String threadNamePrefix, boolean boostIoRatio)
    {
        if (useEpoll)
        {
            logger.debug("using netty epoll event loop for pool prefix {}", threadNamePrefix);
            EpollEventLoopGroup eventLoopGroup = new EpollEventLoopGroup(threadCount, new DefaultThreadFactory(threadNamePrefix));
            if (boostIoRatio)
                eventLoopGroup.setIoRatio(100);
            return eventLoopGroup;
        }

        logger.debug("using netty nio event loop for pool prefix {}", threadNamePrefix);
        NioEventLoopGroup eventLoopGroup = new NioEventLoopGroup(threadCount, new DefaultThreadFactory(threadNamePrefix));
        if (boostIoRatio)
            eventLoopGroup.setIoRatio(100);
        return eventLoopGroup;
    }

