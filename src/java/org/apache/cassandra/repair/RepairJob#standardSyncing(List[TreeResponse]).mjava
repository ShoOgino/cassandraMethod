    private ListenableFuture<List<SyncStat>> standardSyncing(List<TreeResponse> trees)
    {
        InetAddressAndPort local = FBUtilities.getLocalAddressAndPort();

        List<SyncTask> syncTasks = new ArrayList<>();
        // We need to difference all trees one against another
        for (int i = 0; i < trees.size() - 1; ++i)
        {
            TreeResponse r1 = trees.get(i);
            for (int j = i + 1; j < trees.size(); ++j)
            {
                TreeResponse r2 = trees.get(j);

                // Avoid streming between two tansient replicas
                if (isTransient(r1.endpoint) && isTransient(r2.endpoint))
                    continue;

                SyncTask task;
                if (r1.endpoint.equals(local) || r2.endpoint.equals(local))
                {
                    TreeResponse self = r1.endpoint.equals(local) ? r1 : r2;
                    TreeResponse remote = r2.endpoint.equals(local) ? r1 : r2;

                    // pull only if local is full
                    boolean requestRanges = !isTransient(self.endpoint);
                    // push only if remote is full; additionally check for pull repair
                    boolean transferRanges = !isTransient(remote.endpoint) && !session.pullRepair;

                    // Nothing to do
                    if (!requestRanges && !transferRanges)
                        continue;

                    task = new LocalSyncTask(desc, self, remote, isIncremental ? desc.parentSessionId : null,
                                             requestRanges, transferRanges, session.previewKind);
                }
                else if (isTransient(r1.endpoint) || isTransient(r2.endpoint))
                {
                    // Stream only from transient replica
                    TreeResponse streamFrom = isTransient(r1.endpoint) ? r1 : r2;
                    TreeResponse streamTo = isTransient(r1.endpoint) ? r2 : r1;
                    task = new AsymmetricRemoteSyncTask(desc, streamTo, streamFrom, previewKind);
                    session.waitForSync(Pair.create(desc, task.nodePair()), (AsymmetricRemoteSyncTask) task);
                }
                else
                {
                    task = new SymmetricRemoteSyncTask(desc, r1, r2, session.previewKind);
                    // SymmetricRemoteSyncTask expects SyncComplete message sent back.
                    // Register task to RepairSession to receive response.
                    session.waitForSync(Pair.create(desc, task.nodePair()), (SymmetricRemoteSyncTask) task);
                }
                syncTasks.add(task);
                taskExecutor.submit(task);
            }
        }
        return Futures.allAsList(syncTasks);
    }

