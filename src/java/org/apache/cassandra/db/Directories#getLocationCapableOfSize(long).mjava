    /**
     * Finds location which is capable of holding given {@code estimatedSize}.
     * Picks a non-blacklisted directory with most free space and least current tasks.
     * If no directory can hold given {@code estimatedSize}, then returns null.
     *
     * @param estimatedSize estimated size you need to find location to fit
     * @return directory capable of given estimated size, or null if none found
     */
    public DataDirectory getLocationCapableOfSize(long estimatedSize)
    {
        List<DataDirectory> candidates = new ArrayList<DataDirectory>();

        // pick directories with enough space and so that resulting sstable dirs aren't blacklisted for writes.
        for (DataDirectory dataDir : dataFileLocations)
        {
            File sstableDir = getLocationForDisk(dataDir);

            if (BlacklistedDirectories.isUnwritable(sstableDir))
                continue;

            // need a separate check for sstableDir itself - could be a mounted separate disk or SSD just for this CF.
            if (dataDir.getEstimatedAvailableSpace() > estimatedSize && sstableDir.getUsableSpace() * 0.9 > estimatedSize)
                candidates.add(dataDir);
        }

        // sort directories by free space, in _descending_ order.
        Collections.sort(candidates);

        // sort directories by load, in _ascending_ order.
        Collections.sort(candidates, new Comparator<DataDirectory>()
        {
            public int compare(DataDirectory a, DataDirectory b)
            {
                return a.currentTasks.get() - b.currentTasks.get();
            }
        });

        return candidates.isEmpty() ? null : candidates.get(0);
    }

