    /**
     * {@inheritDoc}
     *
     * Release open buffers and poll the {@link #queue} for more data.
     * <p>
     * This is best, and more or less expected, to be invoked on a consuming thread (not the event loop)
     * becasue if we block on the queue we can't fill it on the event loop (as that's where the buffers are coming from).
     */
    @Override
    protected void reBuffer() throws IOException
    {
        currentBuf.release();
        buffer = null;
        currentBuf = null;

        // possibly re-enable auto-read, *before* blocking on the queue, because if we block on the queue
        // without enabling auto-read we'll block forever :(
        if (!channelConfig.isAutoRead() && queuedByteCount.get() < lowWaterMark)
            channelConfig.setAutoRead(true);

        try
        {
            currentBuf = queue.take();
            int bytes;
            // if we get an explicitly empty buffer, we treat that as an indicator that the input is closed
            if (currentBuf == null || (bytes = currentBuf.readableBytes()) == 0)
            {
                releaseResources();
                throw new EOFException();
            }

            buffer = currentBuf.nioBuffer(currentBuf.readerIndex(), bytes);
            assert buffer.remaining() == bytes;
            queuedByteCount.addAndGet(-bytes);
            return;
        }
        catch (InterruptedException ie)
        {
            // nop - ignore
        }
    }

