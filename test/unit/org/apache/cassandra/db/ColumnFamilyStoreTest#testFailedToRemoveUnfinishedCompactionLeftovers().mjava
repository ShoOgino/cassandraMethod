    /**
     * @see <a href="https://issues.apache.org/jira/browse/CASSANDRA-6086">CASSANDRA-6086</a>
     */
    @Test
    public void testFailedToRemoveUnfinishedCompactionLeftovers() throws Throwable
    {
        final String ks = "Keyspace1";
        final String cf = "Standard4"; // should be empty

        final CFMetaData cfmeta = Schema.instance.getCFMetaData(ks, cf);
        Directories dir = new Directories(cfmeta);
        ByteBuffer key = bytes("key");

        // Write SSTable generation 3 that has ancestors 1 and 2
        final Set<Integer> ancestors = Sets.newHashSet(1, 2);
        SSTableSimpleWriter writer = new SSTableSimpleWriter(dir.getDirectoryForCompactedSSTables(),
                                                cfmeta, StorageService.getPartitioner())
        {
            protected SSTableWriter getWriter()
            {
                MetadataCollector collector = new MetadataCollector(cfmeta.comparator);
                for (int ancestor : ancestors)
                    collector.addAncestor(ancestor);
                String file = new Descriptor(directory, ks, cf, 3, true).filenameFor(Component.DATA);
                return new SSTableWriter(file,
                                         0,
                                         ActiveRepairService.UNREPAIRED_SSTABLE,
                                         metadata,
                                         StorageService.getPartitioner(),
                                         collector);
            }
        };
        writer.newRow(key);
        writer.addColumn(bytes("col"), bytes("val"), 1);
        writer.close();

        Map<Descriptor, Set<Component>> sstables = dir.sstableLister().list();
        assert sstables.size() == 1;

        Map.Entry<Descriptor, Set<Component>> sstableToOpen = sstables.entrySet().iterator().next();
        final SSTableReader sstable1 = SSTableReader.open(sstableToOpen.getKey());

        // simulate we don't have generation in compaction_history
        Map<Integer, UUID> unfinishedCompactions = new HashMap<>();
        UUID compactionTaskID = UUID.randomUUID();
        for (Integer ancestor : ancestors)
            unfinishedCompactions.put(ancestor, compactionTaskID);
        ColumnFamilyStore.removeUnfinishedCompactionLeftovers(cfmeta, unfinishedCompactions);

        // SSTable should not be deleted
        sstables = dir.sstableLister().list();
        assert sstables.size() == 1;
        assert sstables.containsKey(sstable1.descriptor);
    }

