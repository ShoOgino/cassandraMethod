    /*
     * The method is needed - temporarily - to migrate max_compaction_threshold and min_compaction_threshold
     * to the compaction map, where they belong.
     *
     * We must use reflection to validate the options because not every compaction strategy respects and supports
     * the threshold params (LCS doesn't, STCS and DTCS don't).
     */
    @SuppressWarnings("unchecked")
    private static Map<String, String> buildCompactionMap(CFMetaData cfm)
    {
        Map<String, String> options = new HashMap<>(cfm.compactionStrategyOptions);

        Map<String, String> optionsWithThresholds = new HashMap<>(options);
        options.putIfAbsent(CFPropDefs.KW_MINCOMPACTIONTHRESHOLD, Integer.toString(cfm.getMinCompactionThreshold()));
        options.putIfAbsent(CFPropDefs.KW_MAXCOMPACTIONTHRESHOLD, Integer.toString(cfm.getMaxCompactionThreshold()));

        try
        {
            Map<String, String> unrecognizedOptions = (Map<String, String>) cfm.compactionStrategyClass
                                                                               .getMethod("validateOptions", Map.class)
                                                                               .invoke(null, optionsWithThresholds);
            if (unrecognizedOptions.isEmpty())
                options = optionsWithThresholds;
        }
        catch (Exception e)
        {
            throw new RuntimeException(e);
        }

        options.put("class", cfm.compactionStrategyClass.getName());

        return options;
    }

