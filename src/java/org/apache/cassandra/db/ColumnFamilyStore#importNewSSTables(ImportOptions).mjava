    @VisibleForTesting
    synchronized void importNewSSTables(ImportOptions options)
    {
        logger.info("Loading new SSTables for {}/{}: {}",
                    keyspace.getName(), name, options);

        File dir = null;
        if (options.srcPath != null && !options.srcPath.isEmpty())
        {
            dir = new File(options.srcPath);
            if (!dir.exists())
            {
                throw new RuntimeException(String.format("Directory %s does not exist", options.srcPath));
            }
            if (!Directories.verifyFullPermissions(dir, options.srcPath))
            {
                throw new RuntimeException("Insufficient permissions on directory " + options.srcPath);
            }
        }

        Set<Descriptor> currentDescriptors = new HashSet<>();
        for (SSTableReader sstable : getSSTables(SSTableSet.CANONICAL))
            currentDescriptors.add(sstable.descriptor);
        Set<SSTableReader> newSSTables = new HashSet<>();
        Directories.SSTableLister lister = dir == null ?
                directories.sstableLister(Directories.OnTxnErr.IGNORE).skipTemporary(true) :
                directories.sstableLister(dir, Directories.OnTxnErr.IGNORE).skipTemporary(true);

        // verify first to avoid starting to copy sstables to the data directories and then have to abort.
        if (options.verifySSTables || options.verifyTokens)
        {
            for (Map.Entry<Descriptor, Set<Component>> entry : lister.list().entrySet())
            {
                Descriptor descriptor = entry.getKey();
                SSTableReader reader = null;
                try
                {
                    reader = SSTableReader.open(descriptor, entry.getValue(), metadata);
                    Verifier.Options verifierOptions = Verifier.options().extendedVerification(options.extendedVerify)
                                                                         .checkOwnsTokens(options.verifyTokens)
                                                                         .invokeDiskFailurePolicy(false)
                                                                         .mutateRepairStatus(false).build();
                    try (Verifier verifier = new Verifier(this, reader, false, verifierOptions))
                    {
                        verifier.verify();
                    }
                }
                catch (Throwable t)
                {
                    throw new RuntimeException("Can't import sstable "+descriptor, t);
                }
                finally
                {
                    if (reader != null)
                        reader.selfRef().release();
                }
            }
        }

        for (Map.Entry<Descriptor, Set<Component>> entry : lister.list().entrySet())
        {
            Descriptor descriptor = entry.getKey();

            if (currentDescriptors.contains(descriptor))
                continue; // old (initialized) SSTable found, skipping

            if (!descriptor.isCompatible())
                throw new RuntimeException(String.format("Can't open incompatible SSTable! Current version %s, found file: %s",
                        descriptor.getFormat().getLatestVersion(),
                        descriptor));

            File targetDirectory;
            try
            {
                if (new File(descriptor.filenameFor(Component.STATS)).exists())
                {
                    if (options.resetLevel)
                    {
                        descriptor.getMetadataSerializer().mutateLevel(descriptor, 0);
                    }
                    if (options.clearRepaired)
                    {
                        descriptor.getMetadataSerializer().mutateRepaired(descriptor,
                                                                          ActiveRepairService.UNREPAIRED_SSTABLE,
                                                                          null);
                    }
                }
                targetDirectory = findBestDiskAndInvalidateCaches(this, descriptor, options.srcPath, options.invalidateCaches, options.jbodCheck);
                logger.debug("{} will get copied to {}", descriptor, targetDirectory);
            }
            catch (IOException e)
            {
                logger.error("{} is corrupt, can't import", descriptor, e);
                throw new RuntimeException(e);
            }

            Descriptor newDescriptor;
            do
            {
                newDescriptor = new Descriptor(descriptor.version,
                                               // If source dir is not provided, then we are just loading from data directory, so use same data directory otherwise
                                               // get the most suitable location to load into
                                               targetDirectory,
                                               descriptor.ksname,
                                               descriptor.cfname,
                                               // Increment the generation until we find a filename that doesn't exist. This is needed because the new
                                               // SSTables that are being loaded might already use these generation numbers.
                                               fileIndexGenerator.incrementAndGet(),
                                               descriptor.formatType);
            }
            while (new File(newDescriptor.filenameFor(Component.DATA)).exists());

            logger.info("Renaming new SSTable {} to {}", descriptor, newDescriptor);
            SSTableWriter.rename(descriptor, newDescriptor, entry.getValue());

            SSTableReader reader;
            try
            {
                reader = SSTableReader.open(newDescriptor, entry.getValue(), metadata);
            }
            catch (Throwable t)
            {
                for (SSTableReader sstable : newSSTables)
                    sstable.selfRef().release();
                // log which sstables we have copied so far, so that the operator can remove them
                if (options.srcPath != null)
                    logger.error("Aborting import of sstables. {} copied, {} was corrupt", newSSTables, newDescriptor);
                throw new RuntimeException(newDescriptor+" is corrupt, can't import", t);
            }
            newSSTables.add(reader);
        }

        if (newSSTables.isEmpty())
        {
            logger.info("No new SSTables were found for {}/{}", keyspace.getName(), name);
            return;
        }

        logger.info("Loading new SSTables and building secondary indexes for {}/{}: {}", keyspace.getName(), name, newSSTables);

        try (Refs<SSTableReader> refs = Refs.ref(newSSTables))
        {
            data.addSSTables(newSSTables);
        }

        logger.info("Done loading load new SSTables for {}/{}", keyspace.getName(), name);
    }

