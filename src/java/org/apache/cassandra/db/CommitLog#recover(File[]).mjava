    void recover(File[] clogs) throws IOException
    {
        DataInputBuffer bufIn = new DataInputBuffer();

        for (File file : clogs)
        {
            IFileReader reader = SequenceFile.reader(file.getAbsolutePath());
            CommitLogHeader clHeader = readCommitLogHeader(reader);
            /* seek to the lowest position */
            int lowPos = CommitLogHeader.getLowestPosition(clHeader);
            /*
             * If lowPos == 0 then we need to skip the processing of this
             * file.
            */
            if (lowPos == 0)
                break;
            else
                reader.seek(lowPos);

            Set<Table> tablesRecovered = new HashSet<Table>();

            /* read the logs populate RowMutation and apply */
            while ( !reader.isEOF() )
            {
                byte[] bytes;
                try
                {
                    bytes = new byte[(int)reader.readLong()];
                    reader.readDirect(bytes);
                }
                catch (EOFException e)
                {
                    // last CL entry didn't get completely written.  that's ok.
                    break;
                }
                bufIn.reset(bytes, bytes.length);

                /* read the commit log entry */
                Row row = Row.serializer().deserialize(bufIn);
                Table table = Table.open(row.getTable());
                tablesRecovered.add(table);
                Collection<ColumnFamily> columnFamilies = new ArrayList<ColumnFamily>(row.getColumnFamilies());
                /* remove column families that have already been flushed */
                for (ColumnFamily columnFamily : columnFamilies)
                {
                    /* TODO: Remove this to not process Hints */
                    if ( !DatabaseDescriptor.isApplicationColumnFamily(columnFamily.name()) )
                    {
                        row.removeColumnFamily(columnFamily);
                        continue;
                    }
                    int id = table.getColumnFamilyId(columnFamily.name());
                    if ( !clHeader.isDirty(id) || reader.getCurrentPosition() < clHeader.getPosition(id) )
                        row.removeColumnFamily(columnFamily);
                }
                if ( !row.isEmpty() )
                {
                    table.applyNow(row);
                }
            }
            reader.close();
            /* apply the rows read -- success will result in the CL file being discarded */
            for (Table table : tablesRecovered)
            {
                table.flush(true);
            }
        }
    }

