    private void checkInverses(CFMetaData cfm) throws Exception
    {
        DecoratedKey k = StorageService.getPartitioner().decorateKey(ByteBufferUtil.bytes(cfm.ksName));

        // This is a nasty hack to work around the fact that non-null componentIndex
        // are only used by CQL (so far) so we don't expose them through thrift
        // There is a CFM with componentIndex defined in Keyspace2 which is used by
        // ColumnFamilyStoreTest to verify index repair (CASSANDRA-2897)
        for (ColumnDefinition def: cfm.allColumns())
        {
            // Remove what we know is not thrift compatible
            if (!def.isThriftCompatible())
                cfm.removeColumnDefinition(def);
        }

        // Test thrift conversion
        assert cfm.equals(CFMetaData.fromThrift(cfm.toThrift())) : String.format("\n%s\n!=\n%s", cfm, CFMetaData.fromThrift(cfm.toThrift()));

        // Test schema conversion
        RowMutation rm = cfm.toSchema(System.currentTimeMillis());
        ColumnFamily serializedCf = rm.getColumnFamily(Schema.instance.getId(Table.SYSTEM_KS, SystemTable.SCHEMA_COLUMNFAMILIES_CF));
        ColumnFamily serializedCD = rm.getColumnFamily(Schema.instance.getId(Table.SYSTEM_KS, SystemTable.SCHEMA_COLUMNS_CF));
        UntypedResultSet.Row result = QueryProcessor.resultify("SELECT * FROM system.schema_columnfamilies", new Row(k, serializedCf)).one();
        CFMetaData newCfm = CFMetaData.addColumnDefinitionSchema(CFMetaData.fromSchemaNoColumns(result), new Row(k, serializedCD));
        assert cfm.equals(newCfm) : String.format("\n%s\n!=\n%s", cfm, newCfm);
    }

