    public boolean batch_insert_blocking(batch_mutation_t batchMutation)
    {
		// 1. Get the N nodes from storage service where the data needs to be
		// replicated
		// 2. Construct a message for read\write
		// 3. SendRR ( to all the nodes above )
		// 4. Wait for a response from atleast X nodes where X <= N
		// 5. return success
    	boolean result = false;
		try
		{
			logger_.warn(" batch_insert_blocking");
			validateTable(batchMutation.table);
			IResponseResolver<Boolean> writeResponseResolver = new WriteResponseResolver();
			QuorumResponseHandler<Boolean> quorumResponseHandler = new QuorumResponseHandler<Boolean>(
					DatabaseDescriptor.getReplicationFactor(),
					writeResponseResolver);
			EndPoint[] endpoints = storageService.getNStorageEndPoint(batchMutation.key);
			// TODO: throw a thrift exception if we do not have N nodes

			logger_.debug(" Creating the row mutation");
			RowMutation rm = new RowMutation(batchMutation.table,
					batchMutation.key.trim());
			Set keys = batchMutation.cfmap.keySet();
			Iterator keyIter = keys.iterator();
			while (keyIter.hasNext())
			{
				Object key = keyIter.next(); // Get the next key.
				List<column_t> list = batchMutation.cfmap.get(key);
				for (column_t columnData : list)
				{
					rm.add(key.toString() + ":" + columnData.columnName,
							columnData.value.getBytes(), columnData.timestamp);

				}
			}            
            
			RowMutationMessage rmMsg = new RowMutationMessage(rm);           
			Message message = new Message(StorageService.getLocalStorageEndPoint(), 
                    StorageService.mutationStage_,
					StorageService.mutationVerbHandler_, 
                    new Object[]{ rmMsg }
            );
			MessagingService.getMessagingInstance().sendRR(message, endpoints,
					quorumResponseHandler);
			logger_.debug(" Calling quorum response handler's get");
			result = quorumResponseHandler.get(); 
                       
			// TODO: if the result is false that means the writes to all the
			// servers failed hence we need to throw an exception or return an
			// error back to the client so that it can take appropriate action.
		}
		catch (Exception e)
		{
			logger_.info( LogUtil.throwableToString(e) );
		}
		return result;
    	
    }

