    public List<KeySlice> get_range_slices(ColumnParent column_parent, SlicePredicate predicate, KeyRange range, ConsistencyLevel consistency_level)
    throws InvalidRequestException, UnavailableException, TException, TimedOutException
    {

        if (startSessionIfRequested())
        {
            Map<String, String> traceParameters = ImmutableMap.of(
                    "column_parent", column_parent.toString(),
                    "predicate", predicate.toString(),
                    "range", range.toString(),
                    "consistency_level", consistency_level.name());
            Tracing.instance().begin("get_range_slices", traceParameters);
        }
        else
        {
            logger.debug("range_slice");
        }

        try
        {

            String keyspace = null;
            CFMetaData metadata = null;

            ClientState cState = state();
            keyspace = cState.getKeyspace();
            cState.hasColumnFamilyAccess(column_parent.column_family, Permission.READ);

            metadata = ThriftValidation.validateColumnFamily(keyspace, column_parent.column_family);
            ThriftValidation.validateColumnParent(metadata, column_parent);
            ThriftValidation.validatePredicate(metadata, column_parent, predicate);
            ThriftValidation.validateKeyRange(metadata, column_parent.super_column, range);
            ThriftValidation.validateConsistencyLevel(keyspace, consistency_level, RequestType.READ);

            List<Row> rows = null;
            try
            {
                IPartitioner p = StorageService.getPartitioner();
                AbstractBounds<RowPosition> bounds;
                if (range.start_key == null)
                {
                    Token.TokenFactory tokenFactory = p.getTokenFactory();
                    Token left = tokenFactory.fromString(range.start_token);
                    Token right = tokenFactory.fromString(range.end_token);
                    bounds = Range.makeRowRange(left, right, p);
                }
                else
                {
                    bounds = new Bounds<RowPosition>(RowPosition.forKey(range.start_key, p), RowPosition.forKey(
                            range.end_key, p));
                }
                schedule(DatabaseDescriptor.getRangeRpcTimeout());
                try
                {
                    IFilter filter = ThriftValidation.asIFilter(predicate,
                            metadata.getComparatorFor(column_parent.super_column));
                    rows = StorageProxy.getRangeSlice(new RangeSliceCommand(keyspace, column_parent, filter, bounds,
                            range.row_filter, range.count), consistency_level);
                }
                finally
                {
                    release();
                }
                assert rows != null;
            }
            catch (TimeoutException e)
            {
                logger.debug("... timed out");
                throw new TimedOutException();
            }
            catch (IOException e)
            {
                throw new RuntimeException(e);
            }

            return thriftifyKeySlices(rows, column_parent, predicate);
        }
        finally
        {
            Tracing.instance().stopSession();
        }
    }

