        public Iterator<Unfiltered> slice(final Slice slice) throws IOException
        {
            return new AbstractIterator<Unfiltered>()
            {
                private boolean beforeStart = true;

                protected Unfiltered computeNext()
                {
                    try
                    {
                        // While we're before the start of the slice, we can skip row but we should keep
                        // track of open range tombstones
                        if (beforeStart)
                        {
                            // Note that the following comparison is not strict. The reason is that the only cases
                            // where it can be == is if the "next" is a RT start marker (either a '[' of a ')[' boundary),
                            // and if we had a strict inequality and an open RT marker before this, we would issue
                            // the open marker first, and then return then next later, which would yet in the
                            // stream both '[' (or '(') and then ')[' for the same clustering value, which is wrong.
                            // By using a non-strict inequality, we avoid that problem (if we do get ')[' for the same
                            // clustering value than the slice, we'll simply record it in 'openMarker').
                            while (deserializer.hasNext() && deserializer.compareNextTo(slice.start()) <= 0)
                            {
                                if (deserializer.nextIsRow())
                                    deserializer.skipNext();
                                else
                                    updateOpenMarker((RangeTombstoneMarker)deserializer.readNext());
                            }

                            beforeStart = false;

                            // We've reached the beginning of our queried slice. If we have an open marker
                            // we should return that first.
                            if (openMarker != null)
                                return new RangeTombstoneBoundMarker(slice.start(), openMarker);
                        }

                        if (deserializer.hasNext() && deserializer.compareNextTo(slice.end()) <= 0)
                        {
                            Unfiltered next = deserializer.readNext();
                            if (next.kind() == Unfiltered.Kind.RANGE_TOMBSTONE_MARKER)
                                updateOpenMarker((RangeTombstoneMarker)next);
                            return next;
                        }

                        // If we have an open marker, we should close it before finishing
                        if (openMarker != null)
                            return new RangeTombstoneBoundMarker(slice.end(), getAndClearOpenMarker());

                        return endOfData();
                    }
                    catch (IOException e)
                    {
                        try
                        {
                            close();
                        }
                        catch (IOException suppressed)
                        {
                            e.addSuppressed(suppressed);
                        }
                        sstable.markSuspect();
                        throw new CorruptSSTableException(e, file.getPath());
                    }
                }
            };
        }

