    private SerializationHeader(AbstractType<?> keyType,
                                List<AbstractType<?>> clusteringTypes,
                                PartitionColumns columns,
                                RowStats stats,
                                Map<ByteBuffer, AbstractType<?>> typeMap)
    {
        this.keyType = keyType;
        this.clusteringTypes = clusteringTypes;
        this.columns = columns;
        this.stats = stats;
        this.typeMap = typeMap;

        // Not that if a given stats is unset, it means that either it's unused (there is
        // no tombstone whatsoever for instance) or that we have no information on it. In
        // that former case, it doesn't matter which base we use but in the former, we use
        // bases that are more likely to provide small encoded values than the default
        // "unset" value.
        this.baseTimestamp = stats.hasMinTimestamp() ? stats.minTimestamp : 0;
        this.baseDeletionTime = stats.hasMinLocalDeletionTime() ? stats.minLocalDeletionTime : DEFAULT_BASE_DELETION;
        this.baseTTL = stats.minTTL;

        // For the dense layout, we have a 1 byte overhead for absent columns. For the sparse layout, it's a 1
        // overhead for present columns (in fact we use a 2 byte id, but assuming vint encoding, we'll pay 2 bytes
        // only for the columns after the 128th one and for simplicity we assume that once you have that many column,
        // you'll tend towards a clearly dense or clearly sparse case so that the heurstic above shouldn't still be
        // too inapropriate). So if on average more than half of our columns are set per row, we better go for sparse.
        this.useSparseColumnLayout = stats.avgColumnSetPerRow <= (columns.regulars.columnCount()/ 2);
    }

