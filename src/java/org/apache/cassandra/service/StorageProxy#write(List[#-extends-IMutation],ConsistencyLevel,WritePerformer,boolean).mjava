    /**
     * Perform the write of a batch of mutations given a WritePerformer.
     * For each mutation, gather the list of write endpoints, apply locally and/or
     * forward the mutation to said write endpoint (deletaged to the actual
     * WritePerformer) and wait for the responses based on consistency level.
     *
     * @param mutations the mutations to be applied
     * @param consistency_level the consistency level for the write operation
     * @param performer the WritePerformer in charge of appliying the mutation
     * given the list of write endpoints (either standardWritePerformer for
     * standard writes or counterWritePerformer for counter writes).
     * @param updateStats whether or not to update the writeStats. This must be
     * true for standard writes but false for counter writes as the latency of
     * the latter is tracked in mutateCounters() by counterWriteStats.
     */
    public static void write(List<? extends IMutation> mutations, ConsistencyLevel consistency_level, WritePerformer performer, boolean updateStats) throws UnavailableException, TimeoutException
    {
        final String localDataCenter = DatabaseDescriptor.getEndpointSnitch().getDatacenter(FBUtilities.getLocalAddress());

        long startTime = System.nanoTime();
        List<IWriteResponseHandler> responseHandlers = new ArrayList<IWriteResponseHandler>();

        IMutation mostRecentMutation = null;
        try
        {
            for (IMutation mutation : mutations)
            {
                mostRecentMutation = mutation;
                String table = mutation.getTable();
                AbstractReplicationStrategy rs = Table.open(table).getReplicationStrategy();

                Collection<InetAddress> writeEndpoints = getWriteEndpoints(table, mutation.key());
                Multimap<InetAddress, InetAddress> hintedEndpoints = rs.getHintedEndpoints(writeEndpoints);

                final IWriteResponseHandler responseHandler = rs.getWriteResponseHandler(writeEndpoints, hintedEndpoints, consistency_level);

                // exit early if we can't fulfill the CL at this time
                responseHandler.assureSufficientLiveNodes();

                responseHandlers.add(responseHandler);
                performer.apply(mutation, hintedEndpoints, responseHandler, localDataCenter);
            }
            // wait for writes.  throws timeoutexception if necessary
            for (IWriteResponseHandler responseHandler : responseHandlers)
            {
                responseHandler.get();
            }
        }
        catch (IOException e)
        {
            assert mostRecentMutation != null;
            throw new RuntimeException("error writing key " + ByteBufferUtil.bytesToHex(mostRecentMutation.key()), e);
        }
        finally
        {
            if (updateStats)
                writeStats.addNano(System.nanoTime() - startTime);
        }
    }

