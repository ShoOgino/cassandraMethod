    /*
     * switchMemtable puts Memtable.getSortedContents on the writer executor.  When the write is complete,
     * we turn the writer into an SSTableReader and add it to ssTables where it is available for reads.
     * This method does not block except for synchronizing on DataTracker, but the Future it returns will
     * not complete until the Memtable (and all prior Memtables) have been successfully flushed, and the CL
     * marked clean up to the position owned by the Memtable.
     */
    public ListenableFuture<?> switchMemtable()
    {
        synchronized (data)
        {
            if (previousFlushFailure != null)
                throw new IllegalStateException("A flush previously failed with the error below. To prevent data loss, "
                                              + "no flushes can be carried out until the node is restarted.",
                                                previousFlushFailure);
            logFlush();
            Flush flush = new Flush(false);
            ListenableFutureTask<?> flushTask = ListenableFutureTask.create(flush, null);
            flushExecutor.submit(flushTask);
            ListenableFutureTask<?> task = ListenableFutureTask.create(flush.postFlush, null);
            postFlushExecutor.submit(task);

            @SuppressWarnings("unchecked")
            ListenableFuture<?> future = Futures.allAsList(flushTask, task);
            return future;
        }
    }

