    @Override
    public void execute(NodeProbe probe)
    {
        joiningNodes = probe.getJoiningNodes(withPort);
        leavingNodes = probe.getLeavingNodes(withPort);
        movingNodes = probe.getMovingNodes(withPort);
        loadMap = probe.getLoadMap(withPort);
        Map<String, String> tokensToEndpoints = probe.getTokenToEndpointMap(withPort);
        liveNodes = probe.getLiveNodes(withPort);
        unreachableNodes = probe.getUnreachableNodes(withPort);
        hostIDMap = probe.getHostIdMap(withPort);
        epSnitchInfo = probe.getEndpointSnitchInfoProxy();

        StringBuilder errors = new StringBuilder();

        if (withPort)
        {
            Map<String, Float> ownerships = null;
            boolean hasEffectiveOwns = false;
            try
            {
                ownerships = probe.effectiveOwnershipWithPort(keyspace);
                hasEffectiveOwns = true;
            }
            catch (IllegalStateException e)
            {
                ownerships = probe.getOwnershipWithPort();
                errors.append("Note: ").append(e.getMessage()).append("%n");
            }
            catch (IllegalArgumentException ex)
            {
                System.out.printf("%nError: %s%n", ex.getMessage());
                System.exit(1);
            }

            SortedMap<String, SetHostStatWithPort> dcs = NodeTool.getOwnershipByDcWithPort(probe, resolveIp, tokensToEndpoints, ownerships);

            // More tokens than nodes (aka vnodes)?
            if (dcs.values().size() < tokensToEndpoints.keySet().size())
                isTokenPerNode = false;

            findMaxAddressLengthWithPort(dcs);

            // Datacenters
            for (Map.Entry<String, SetHostStatWithPort> dc : dcs.entrySet())
            {
                String dcHeader = String.format("Datacenter: %s%n", dc.getKey());
                System.out.printf(dcHeader);
                for (int i = 0; i < (dcHeader.length() - 1); i++) System.out.print('=');
                System.out.println();

                // Legend
                System.out.println("Status=Up/Down");
                System.out.println("|/ State=Normal/Leaving/Joining/Moving");

                printNodesHeader(hasEffectiveOwns, isTokenPerNode);

                ArrayListMultimap<InetAddressAndPort, HostStatWithPort> hostToTokens = ArrayListMultimap.create();
                for (HostStatWithPort stat : dc.getValue())
                    hostToTokens.put(stat.endpoint, stat);

                for (InetAddressAndPort endpoint : hostToTokens.keySet())
                {
                    Float owns = ownerships.get(endpoint.toString());
                    List<HostStatWithPort> tokens = hostToTokens.get(endpoint);
                    printNodeWithPort(endpoint.toString(), owns, tokens, hasEffectiveOwns, isTokenPerNode);
                }
            }

            System.out.printf("%n" + errors.toString());
        }
        else
        {
            Map<InetAddress, Float> ownerships = null;
            boolean hasEffectiveOwns = false;
            try
            {
                ownerships = probe.effectiveOwnership(keyspace);
                hasEffectiveOwns = true;
            }
            catch (IllegalStateException e)
            {
                ownerships = probe.getOwnership();
                errors.append("Note: ").append(e.getMessage()).append("%n");
            }
            catch (IllegalArgumentException ex)
            {
                System.out.printf("%nError: %s%n", ex.getMessage());
                System.exit(1);
            }

            SortedMap<String, SetHostStat> dcs = NodeTool.getOwnershipByDc(probe, resolveIp, tokensToEndpoints, ownerships);

            // More tokens than nodes (aka vnodes)?
            if (dcs.values().size() < tokensToEndpoints.keySet().size())
                isTokenPerNode = false;

            findMaxAddressLength(dcs);

            // Datacenters
            for (Map.Entry<String, SetHostStat> dc : dcs.entrySet())
            {
                String dcHeader = String.format("Datacenter: %s%n", dc.getKey());
                System.out.printf(dcHeader);
                for (int i = 0; i < (dcHeader.length() - 1); i++) System.out.print('=');
                System.out.println();

                // Legend
                System.out.println("Status=Up/Down");
                System.out.println("|/ State=Normal/Leaving/Joining/Moving");

                printNodesHeader(hasEffectiveOwns, isTokenPerNode);

                ArrayListMultimap<InetAddress, HostStat> hostToTokens = ArrayListMultimap.create();
                for (HostStat stat : dc.getValue())
                    hostToTokens.put(stat.endpoint, stat);

                for (InetAddress endpoint : hostToTokens.keySet())
                {
                    Float owns = ownerships.get(endpoint);
                    List<HostStat> tokens = hostToTokens.get(endpoint);
                    printNode(endpoint.getHostAddress(), owns, tokens, hasEffectiveOwns, isTokenPerNode);
                }
            }

            System.out.printf("%n" + errors.toString());
        }
    }

