    /**
     * Removes as many cold sstables as possible while retaining at least 1-coldReadsToOmit of the total reads/sec
     * across all sstables
     * @param sstables all sstables to consider
     * @param coldReadsToOmit the proportion of total reads/sec that will be omitted (0=omit nothing, 1=omit everything)
     * @param minThreshold min compaction threshold
     * @return a list of sstables with the coldest sstables excluded until the reads they represent reaches coldReadsToOmit
     */
    @VisibleForTesting
    static List<SSTableReader> filterColdSSTables(List<SSTableReader> sstables, double coldReadsToOmit, int minThreshold)
    {
        if (coldReadsToOmit == 0.0)
            return sstables;

        // Sort the sstables by hotness (coldest-first). We first build a map because the hotness may change during the sort.
        final Map<SSTableReader, Double> hotnessSnapshot = getHotnessMap(sstables);
        Collections.sort(sstables, new Comparator<SSTableReader>()
        {
            public int compare(SSTableReader o1, SSTableReader o2)
            {
                int comparison = Double.compare(hotnessSnapshot.get(o1), hotnessSnapshot.get(o2));
                if (comparison != 0)
                    return comparison;

                // break ties with size on disk (mainly for system tables and cold tables)
                comparison = Long.compare(o1.bytesOnDisk(), o2.bytesOnDisk());
                if (comparison != 0)
                    return comparison;

                // if there's still a tie, use generation, which is guaranteed to be unique.  this ensures that
                // our filtering is deterministic, which can be useful when debugging.
                return o1.descriptor.generation - o2.descriptor.generation;
            }
        });

        // calculate the total reads/sec across all sstables
        double totalReads = 0.0;
        for (SSTableReader sstr : sstables)
            if (sstr.getReadMeter() != null)
                totalReads += sstr.getReadMeter().twoHourRate();

        // if this is a system table with no read meters or we don't have any read rates yet, just return them all
        if (totalReads == 0.0)
            return sstables;

        // iteratively ignore the coldest sstables until ignoring one more would put us over the coldReadsToOmit threshold
        double maxColdReads = coldReadsToOmit * totalReads;

        double totalColdReads = 0.0;
        int cutoffIndex = 0;
        while (cutoffIndex < sstables.size())
        {
            SSTableReader sstable = sstables.get(cutoffIndex);
            if (sstable.getReadMeter() == null)
            {
                throw new AssertionError("If you're seeing this exception, please attach your logs to CASSANDRA-8238 to help us debug. "+sstable);
            }
            double reads = sstable.getReadMeter().twoHourRate();
            if (totalColdReads + reads > maxColdReads)
                break;

            totalColdReads += reads;
            cutoffIndex++;
        }
        List<SSTableReader> hotSSTables = new ArrayList<>(sstables.subList(cutoffIndex, sstables.size()));
        List<SSTableReader> coldSSTables = sstables.subList(0, cutoffIndex);
        logger.debug("hotSSTables={}, coldSSTables={}", hotSSTables.size(), coldSSTables.size());
        if (hotSSTables.size() >= minThreshold)
            return hotSSTables;
        if (coldSSTables.size() < minThreshold)
            return Collections.emptyList();

        Map<SSTableReader, Set<SSTableReader>> overlapMap = new HashMap<>();
        for (int i = 0; i < coldSSTables.size(); i++)
        {
            SSTableReader sstable = coldSSTables.get(i);
            Set<SSTableReader> overlaps = new HashSet<>();
            for (int j = 0; j < coldSSTables.size(); j++)
            {
                SSTableReader innerSSTable = coldSSTables.get(j);
                if (ColumnNameHelper.overlaps(sstable.getSSTableMetadata().minColumnNames,
                                              sstable.getSSTableMetadata().maxColumnNames,
                                              innerSSTable.getSSTableMetadata().minColumnNames,
                                              innerSSTable.getSSTableMetadata().maxColumnNames,
                                              sstable.metadata.comparator))
                {
                    overlaps.add(innerSSTable);
                }
            }
            overlapMap.put(sstable, overlaps);
        }
        List<Set<SSTableReader>> overlapChains = new ArrayList<>();
        for (SSTableReader sstable : overlapMap.keySet())
            overlapChains.add(createOverlapChain(sstable, overlapMap));

        Collections.sort(overlapChains, new Comparator<Set<SSTableReader>>()
        {
            @Override
            public int compare(Set<SSTableReader> o1, Set<SSTableReader> o2)
            {
                return Longs.compare(SSTableReader.getTotalBytes(o2), SSTableReader.getTotalBytes(o1));
            }
        });
        for (Set<SSTableReader> overlapping : overlapChains)
        {
            // if we are expecting to only keep 70% of the keys after a compaction, run a compaction on these cold sstables:
            if (SSTableReader.estimateCompactionGain(overlapping) < 0.7)
                return new ArrayList<>(overlapping);
        }
        return Collections.emptyList();
    }

