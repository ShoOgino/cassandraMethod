    /**
     * Handle node leaving the ring. This can be either because the node was removed manually by
     * removetoken command or because of decommission or loadbalance
     *
     * @param endpoint If reason for leaving is decommission or loadbalance (LEFT_NORMALLY),
     * endpoint is the leaving node. If reason manual removetoken (REMOVE_TOKEN), endpoint
     * parameter is ignored and the operation is based on the token inside moveValue.
     * @param moveValue (REMOVE_TOKEN|LEFT_NORMALLY)<Delimiter><token>
     */
    private void handleStateLeft(InetAddress endpoint, String moveValue)
    {
        int index = moveValue.indexOf(Delimiter);
        assert (index != -1);
        String typeOfState = moveValue.substring(0, index);
        Token token = getPartitioner().getTokenFactory().fromString(moveValue.substring(index + 1));

        // endpoint itself is leaving
        if (typeOfState.equals(LEFT_NORMALLY))
        {
            if (logger_.isDebugEnabled())
                logger_.debug("Node " + endpoint + " state left, token " + token);

            // If the node is member, remove all references to it. If not, call
            // removeBootstrapToken just in case it is there (very unlikely chain of events)
            if (tokenMetadata_.isMember(endpoint))
            {
                if (!tokenMetadata_.getToken(endpoint).equals(token))
                    logger_.warn("Node " + endpoint + " 'left' token mismatch. Long network partition?");
                tokenMetadata_.removeEndpoint(endpoint);
                HintedHandOffManager.deleteHintsForEndPoint(endpoint);
            }
        }
        else
        {
            // if we're here, endpoint is not leaving but broadcasting remove token command
            assert (typeOfState.equals(REMOVE_TOKEN));
            InetAddress endpointThatLeft = tokenMetadata_.getEndpoint(token);
            // let's make sure that we're not removing ourselves. This can happen when a node
            // enters ring as a replacement for a removed node. removeToken for the old node is
            // still in gossip, so we will see it.
            if (FBUtilities.getLocalAddress().equals(endpointThatLeft))
            {
                logger_.info("Received removeToken gossip about myself. Is this node a replacement for a removed one?");
                return;
            }
            if (logger_.isDebugEnabled())
                logger_.debug("Token " + token + " removed manually (endpoint was " + ((endpointThatLeft == null) ? "unknown" : endpointThatLeft) + ")");
            if (endpointThatLeft != null)
            {
                removeEndpointLocally(endpointThatLeft);
            }
        }

        // remove token from bootstrap tokens just in case it is still there
        tokenMetadata_.removeBootstrapToken(token);
        calculatePendingRanges();
    }

