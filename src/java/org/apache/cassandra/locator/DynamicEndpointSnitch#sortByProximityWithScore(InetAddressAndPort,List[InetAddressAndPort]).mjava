    private void sortByProximityWithScore(final InetAddressAndPort address, List<InetAddressAndPort> addresses)
    {
        // Scores can change concurrently from a call to this method. But Collections.sort() expects
        // its comparator to be "stable", that is 2 endpoint should compare the same way for the duration
        // of the sort() call. As we copy the scores map on write, it is thus enough to alias the current
        // version of it during this call.
        final HashMap<InetAddressAndPort, Double> scores = this.scores;
        Collections.sort(addresses, new Comparator<InetAddressAndPort>()
        {
            public int compare(InetAddressAndPort a1, InetAddressAndPort a2)
            {
                return compareEndpoints(address, a1, a2, scores);
            }
        });
    }

