    /**
     * get a list of columns starting from a given column, in a specified order
     * only the latest version of a column is returned
     */
    public ColumnFamily getSliceFrom(String key, String cfName, String startColumn, String finishColumn, boolean isAscending, int offset, int count)
    throws IOException, ExecutionException, InterruptedException
    {
        lock_.readLock().lock();
        List<ColumnIterator> iterators = new ArrayList<ColumnIterator>();
        try
        {
            final ColumnFamily returnCF;
            ColumnIterator iter;
        
            /* add the current memtable */
            memtableLock_.readLock().lock();
            try
            {
                iter = memtable_.getColumnIterator(key, cfName, isAscending, startColumn);
                returnCF = iter.getColumnFamily();
            }
            finally
            {
                memtableLock_.readLock().unlock();            
            }        
            iterators.add(iter);

            /* add the memtables being flushed */
            List<Memtable> memtables = getUnflushedMemtables(cfName);
            for (Memtable memtable:memtables)
            {
                iter = memtable.getColumnIterator(key, cfName, isAscending, startColumn);
                returnCF.delete(iter.getColumnFamily());
                iterators.add(iter);
            }

            /* add the SSTables on disk */
            List<SSTableReader> sstables = new ArrayList<SSTableReader>(ssTables_.values());
            for (SSTableReader sstable : sstables)
            {
                iter = new SSTableColumnIterator(sstable.getFilename(), key, cfName, startColumn, isAscending);
                if (iter.hasNext())
                {
                    returnCF.delete(iter.getColumnFamily());
                    iterators.add(iter);
                }
            }

            // define a 'reduced' iterator that merges columns w/ the same name, which
            // greatly simplifies computing liveColumns in the presence of tombstones.
            Comparator<IColumn> comparator = new Comparator<IColumn>()
            {
                public int compare(IColumn c1, IColumn c2)
                {
                    return c1.name().compareTo(c2.name());
                }
            };
            if (!isAscending)
                comparator = new ReverseComparator(comparator);
            Iterator collated = IteratorUtils.collatedIterator(comparator, iterators);
            if (!collated.hasNext())
                return ColumnFamily.create(table_, cfName);
            ReducingIterator<IColumn> reduced = new ReducingIterator<IColumn>(collated)
            {
                ColumnFamily curCF = returnCF.cloneMeShallow();

                protected Object getKey(IColumn o)
                {
                    return o == null ? null : o.name();
                }

                public void reduce(IColumn current)
                {
                    curCF.addColumn(current);
                }

                protected IColumn getReduced()
                {
                    IColumn c = curCF.getAllColumns().first();
                    curCF.clear();
                    return c;
                }
            };

            // add unique columns to the CF container
            int liveColumns = 0;
            int limit = offset + count;
            for (IColumn column : reduced)
            {
                if (liveColumns >= limit)
                    break;
                if (!finishColumn.isEmpty()
                    && ((isAscending && column.name().compareTo(finishColumn) > 0))
                        || (!isAscending && column.name().compareTo(finishColumn) < 0))
                    break;
                if (!column.isMarkedForDelete())
                    liveColumns++;

                if (liveColumns > offset)
                    returnCF.addColumn(column);
            }

            return removeDeleted(returnCF);
        }
        finally
        {
            /* close all cursors */
            for (ColumnIterator ci : iterators)
            {
                try
                {
                    ci.close();
                }
                catch (Throwable th)
                {
                    logger_.error(th);
                }
            }

            lock_.readLock().unlock();
        }
    }

