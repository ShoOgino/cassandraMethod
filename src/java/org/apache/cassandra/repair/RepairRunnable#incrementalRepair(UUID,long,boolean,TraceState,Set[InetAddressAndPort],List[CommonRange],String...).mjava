    private void incrementalRepair(UUID parentSession,
                                   long startTime,
                                   boolean forceRepair,
                                   TraceState traceState,
                                   Set<InetAddressAndPort> allNeighbors,
                                   List<CommonRange> commonRanges,
                                   String... cfnames)
    {
        // the local node also needs to be included in the set of participants, since coordinator sessions aren't persisted
        Predicate<InetAddressAndPort> isAlive = FailureDetector.instance::isAlive;
        Set<InetAddressAndPort> allParticipants = ImmutableSet.<InetAddressAndPort>builder()
                                           .addAll(forceRepair ? Iterables.filter(allNeighbors, isAlive) : allNeighbors)
                                           .add(FBUtilities.getBroadcastAddressAndPort())
                                           .build();

        List<CommonRange> allRanges = filterCommonRanges(commonRanges, allParticipants, forceRepair);

        CoordinatorSession coordinatorSession = ActiveRepairService.instance.consistent.coordinated.registerSession(parentSession, allParticipants);
        ListeningExecutorService executor = createExecutor();
        AtomicBoolean hasFailure = new AtomicBoolean(false);
        ListenableFuture repairResult = coordinatorSession.execute(() -> submitRepairSessions(parentSession, true, executor, allRanges, cfnames),
                                                                   hasFailure);
        Collection<Range<Token>> ranges = new HashSet<>();
        for (Collection<Range<Token>> range : Iterables.transform(allRanges, cr -> cr.ranges))
        {
            ranges.addAll(range);
        }
        Futures.addCallback(repairResult, new RepairCompleteCallback(parentSession, ranges, startTime, traceState, hasFailure, executor));
    }

