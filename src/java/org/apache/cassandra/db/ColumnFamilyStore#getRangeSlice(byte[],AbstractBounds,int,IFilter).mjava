    /**
     *
     * @param super_column
     * @param range: either a Bounds, which includes start key, or a Range, which does not.
     * @param keyMax maximum number of keys to process, regardless of startKey/finishKey
     * @param columnFilter description of the columns we're interested in for each row
     * @throws ExecutionException
     * @throws InterruptedException
     */
    public List<Row> getRangeSlice(byte[] super_column, final AbstractBounds range, int keyMax, IFilter columnFilter)
    throws ExecutionException, InterruptedException
    {
        List<Row> rows = new ArrayList<Row>();
        boolean completed;
        if ((range instanceof Bounds || !((Range)range).isWrapAround()))
        {
            completed = getRangeRows(rows, super_column, range, keyMax, columnFilter);
        }
        else
        {
            // wrapped range
            Token min = partitioner_.getMinimumToken();
            Range first = new Range(range.left, min);
            completed = getRangeRows(rows, super_column, first, keyMax, columnFilter);
            if (!completed && min.compareTo(range.right) < 0)
            {
                Range second = new Range(min, range.right);
                getRangeRows(rows, super_column, second, keyMax, columnFilter);
            }
        }

        return rows;
    }

