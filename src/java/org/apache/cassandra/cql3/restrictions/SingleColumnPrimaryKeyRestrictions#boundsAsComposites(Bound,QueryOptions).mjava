    @Override
    public List<Composite> boundsAsComposites(Bound bound, QueryOptions options) throws InvalidRequestException
    {
        CBuilder builder = ctype.builder();
        List<ColumnDefinition> defs = new ArrayList<>(restrictions.getColumnDefs());

        CompositesBuilder compositeBuilder = new CompositesBuilder(builder, ctype);
        // The end-of-component of composite doesn't depend on whether the
        // component type is reversed or not (i.e. the ReversedType is applied
        // to the component comparator but not to the end-of-component itself),
        // it only depends on whether the slice is reversed
        int keyPosition = 0;
        for (ColumnDefinition def : defs)
        {
            // In a restriction, we always have Bound.START < Bound.END for the "base" comparator.
            // So if we're doing a reverse slice, we must inverse the bounds when giving them as start and end of the slice filter.
            // But if the actual comparator itself is reversed, we must inversed the bounds too.
            Bound b = !def.isReversedType() ? bound : bound.reverse();
            Restriction r = restrictions.getRestriction(def);
            if (keyPosition != def.position() || r.isContains())
                return compositeBuilder.buildWithEOC(bound.isEnd() ? EOC.END : EOC.START);

            if (r.isSlice())
            {
                if (!r.hasBound(b))
                {
                    // There wasn't any non EQ relation on that key, we select all records having the preceding component as prefix.
                    // For composites, if there was preceding component and we're computing the end, we must change the last component
                    // End-Of-Component, otherwise we would be selecting only one record.
                    return compositeBuilder.buildWithEOC(bound.isEnd() ? EOC.END : EOC.START);
                }

                ByteBuffer value = checkNotNull(r.bounds(b, options).get(0), "Invalid null clustering key part %s", r);
                compositeBuilder.addElementToAll(value);
                Composite.EOC eoc = eocFor(r, bound, b);
                return compositeBuilder.buildWithEOC(eoc);
            }

            List<ByteBuffer> values = r.values(options);

            if (values.isEmpty())
                return Collections.emptyList();

            compositeBuilder.addEachElementToAll(values);

            checkFalse(compositeBuilder.containsNull(), "Invalid null clustering key part %s", def.name);
            keyPosition++;
        }
        // Means no relation at all or everything was an equal
        // Note: if the builder is "full", there is no need to use the end-of-component bit. For columns selection,
        // it would be harmless to do it. However, we use this method got the partition key too. And when a query
        // with 2ndary index is done, and with the the partition provided with an EQ, we'll end up here, and in that
        // case using the eoc would be bad, since for the random partitioner we have no guarantee that
        // prefix.end() will sort after prefix (see #5240).
        EOC eoc = !compositeBuilder.hasRemaining() ? EOC.NONE : (bound.isEnd() ? EOC.END : EOC.START);
        return compositeBuilder.buildWithEOC(eoc);
    }

